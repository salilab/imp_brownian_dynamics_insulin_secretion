/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

#define PY_SSIZE_T_CLEAN


static int numpy_import_retval;



#define SWIG_VERSION 0x040101
#define SWIGPYTHON
#define SWIG_DIRECTORS
#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
#define SWIG_CASTRANK_MODE
#define SWIG_PYTHON_CAST_MODE

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
/* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
# include <math.h>
#endif

#if !defined(PY_SSIZE_T_CLEAN) && !defined(SWIG_NO_PY_SSIZE_T_CLEAN)
#define PY_SSIZE_T_CLEAN
#endif

#if __GNUC__ >= 7
#pragma GCC diagnostic push
#if defined(__cplusplus) && __cplusplus >=201703L
#pragma GCC diagnostic ignored "-Wregister" /* For python-2.7 headers that use register */
#endif
#endif

#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */

#if defined(_MSC_VER) && _MSC_VER >= 1929
/* Workaround compilation errors when redefining _DEBUG in MSVC 2019 version 16.10 and later
 * See https://github.com/swig/swig/issues/2090 */
# include <corecrt.h>
#endif

# undef _DEBUG
# include <Python.h>
# define _DEBUG 1
#else
# include <Python.h>
#endif

#if __GNUC__ >= 7
#pragma GCC diagnostic pop
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4
#define SWIG_POINTER_CLEAR         0x8
#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows returning the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
/* Runtime errors are < 0 */
#define SWIG_ERROR                 (-1)
/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
/* Errors < -200 are generic runtime specific errors */
#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)

#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del object mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  Choose the last
     name. It should be the most specific; a fully resolved name
     but not necessarily with default template parameters expanded. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13


/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03030000
  return (char *)PyUnicode_AsUTF8(str);
#else
  return PyString_AsString(str);
#endif
}

/* Was useful for Python 3.0.x-3.2.x - now provided only for compatibility
 * with any uses in user interface files. */
#define SWIG_Python_str_DelForPy3(x)


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

/* SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user interface files check for it. */
# define SWIGPY_USE_CAPSULE
#ifdef SWIGPYTHON_BUILTIN
# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule_builtin" SWIG_TYPE_TABLE_NAME
#else
# define SWIGPY_CAPSULE_ATTR_NAME "type_pointer_capsule" SWIG_TYPE_TABLE_NAME
#endif
# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION "." SWIGPY_CAPSULE_ATTR_NAME)

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#define Py_hash_t long
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred())
    PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    PyObject *old_str = PyObject_Str(value);
    const char *tmp = SWIG_Python_str_AsChar(old_str);
    PyErr_Clear();
    Py_XINCREF(type);
    if (tmp)
      PyErr_Format(type, "%s %s", tmp, mesg);
    else
      PyErr_Format(type, "%s", mesg);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

SWIGRUNTIME int
SWIG_Python_TypeErrorOccurred(PyObject *obj)
{
  PyObject *error;
  if (obj)
    return 0;
  error = PyErr_Occurred();
  return error && PyErr_GivenExceptionMatches(error, PyExc_TypeError);
}

SWIGRUNTIME void
SWIG_Python_RaiseOrModifyTypeError(const char *message)
{
  if (SWIG_Python_TypeErrorOccurred(NULL)) {
    /* Use existing TypeError to preserve stacktrace and enhance with given message */
    PyObject *newvalue;
    PyObject *type = NULL, *value = NULL, *traceback = NULL;
    PyErr_Fetch(&type, &value, &traceback);
#if PY_VERSION_HEX >= 0x03000000
    newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
#else
    newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
#endif
    if (newvalue) {
      Py_XDECREF(value);
      PyErr_Restore(type, newvalue, traceback);
    } else {
      PyErr_Restore(type, value, traceback);
    }
  } else {
    /* Raise TypeError using given message */
    PyErr_SetString(PyExc_TypeError, message);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    define SWIG_PYTHON_USE_GIL
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      if PY_VERSION_HEX < 0x03070000
#        define SWIG_PYTHON_INITIALIZE_THREADS PyEval_InitThreads()
#      else
#        define SWIG_PYTHON_INITIALIZE_THREADS
#      endif
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  const char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

#if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
# error "This version of SWIG only supports Python >= 2.7"
#endif

#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03030000
# error "This version of SWIG only supports Python 3 >= 3.3"
#endif

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      if (result) {
        PyList_SET_ITEM(result, 0, o2);
      } else {
        Py_DECREF(obj);
        return o2;
      }
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

SWIGINTERN int
SWIG_Python_CheckNoKeywords(PyObject *kwargs, const char *name) {
  int no_kwargs = 1;
  if (kwargs) {
    assert(PyDict_Check(kwargs));
    if (PyDict_Size(kwargs) > 0) {
      PyErr_Format(PyExc_TypeError, "%s() does not take keyword arguments", name);
      no_kwargs = 0;
    }
  }
  return no_kwargs;
}

/* A functor is a function object with one single object argument */
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
 
/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */
 
typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

SWIGINTERN PyObject *
swig_varlink_repr(PyObject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_InternFromString("<Swig global variables>");
#else
  return PyString_FromString("<Swig global variables>");
#endif
}

SWIGINTERN PyObject *
swig_varlink_str(PyObject *o) {
  swig_varlinkobject *v = (swig_varlinkobject *) o;
#if PY_VERSION_HEX >= 0x03000000
  PyObject *str = PyUnicode_InternFromString("(");
  PyObject *tail;
  PyObject *joined;
  swig_globalvar *var;
  for (var = v->vars; var; var=var->next) {
    tail = PyUnicode_FromString(var->name);
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
    if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
    }
  }
  tail = PyUnicode_InternFromString(")");
  joined = PyUnicode_Concat(str, tail);
  Py_DecRef(str);
  Py_DecRef(tail);
  str = joined;
#else
  PyObject *str = PyString_FromString("(");
  swig_globalvar *var;
  for (var = v->vars; var; var=var->next) {
    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
  }
  PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
  return str;
}

SWIGINTERN void
swig_varlink_dealloc(PyObject *o) {
  swig_varlinkobject *v = (swig_varlinkobject *) o;
  swig_globalvar *var = v->vars;
  while (var) {
    swig_globalvar *n = var->next;
    free(var->name);
    free(var);
    var = n;
  }
}

SWIGINTERN PyObject *
swig_varlink_getattr(PyObject *o, char *n) {
  swig_varlinkobject *v = (swig_varlinkobject *) o;
  PyObject *res = NULL;
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      res = (*var->get_attr)();
      break;
    }
    var = var->next;
  }
  if (res == NULL && !PyErr_Occurred()) {
    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
  }
  return res;
}

SWIGINTERN int
swig_varlink_setattr(PyObject *o, char *n, PyObject *p) {
  swig_varlinkobject *v = (swig_varlinkobject *) o;
  int res = 1;
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      res = (*var->set_attr)(p);
      break;
    }
    var = var->next;
  }
  if (res == 1 && !PyErr_Occurred()) {
    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
  }
  return res;
}

SWIGINTERN PyTypeObject*
swig_varlink_type(void) {
  static char varlink__doc__[] = "Swig var link object";
  static PyTypeObject varlink_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                  /* ob_size */
#endif
      "swigvarlink",                      /* tp_name */
      sizeof(swig_varlinkobject),         /* tp_basicsize */
      0,                                  /* tp_itemsize */
      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
#if PY_VERSION_HEX < 0x030800b4
      (printfunc)0,                       /*tp_print*/
#else
      (Py_ssize_t)0,                      /*tp_vectorcall_offset*/
#endif
      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
      0,                                  /* tp_compare */
      (reprfunc) swig_varlink_repr,       /* tp_repr */
      0,                                  /* tp_as_number */
      0,                                  /* tp_as_sequence */
      0,                                  /* tp_as_mapping */
      0,                                  /* tp_hash */
      0,                                  /* tp_call */
      (reprfunc) swig_varlink_str,        /* tp_str */
      0,                                  /* tp_getattro */
      0,                                  /* tp_setattro */
      0,                                  /* tp_as_buffer */
      0,                                  /* tp_flags */
      varlink__doc__,                     /* tp_doc */
      0,                                  /* tp_traverse */
      0,                                  /* tp_clear */
      0,                                  /* tp_richcompare */
      0,                                  /* tp_weaklistoffset */
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
      0,                                  /* tp_del */
      0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                  /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                  /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                  /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                  /* tp_allocs */
      0,                                  /* tp_frees */
      0,                                  /* tp_maxalloc */
      0,                                  /* tp_prev */
      0                                   /* tp_next */
#endif
    };
    varlink_type = tmp;
    type_init = 1;
    if (PyType_Ready(&varlink_type) < 0)
      return NULL;
  }
  return &varlink_type;
}

/* Create a variable linking object for use later */
SWIGINTERN PyObject *
SWIG_Python_newvarlink(void) {
  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
  if (result) {
    result->vars = 0;
  }
  return ((PyObject*) result);
}

SWIGINTERN void 
SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v = (swig_varlinkobject *) p;
  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  if (gv) {
    size_t size = strlen(name)+1;
    gv->name = (char *)malloc(size);
    if (gv->name) {
      memcpy(gv->name, name, size);
      gv->get_attr = get_attr;
      gv->set_attr = set_attr;
      gv->next = v->vars;
    }
  }
  v->vars = gv;
}


static PyObject *Swig_Globals_global = NULL;
  
SWIGINTERN PyObject *
SWIG_globals(void) {
  if (Swig_Globals_global == NULL) {
    Swig_Globals_global = SWIG_newvarlink();
  }
  return Swig_Globals_global;
}

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  int fail = data ? data->implicitconv : 0;
  if (fail)
    PyErr_SetString(PyExc_TypeError, "Implicit conversion is prohibited for explicit constructors.");
  return fail;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      Py_INCREF(obj);
      data->newargs = obj;
    } else {
      data->newraw = PyObject_GetAttrString(data->klass, "__new__");
      if (data->newraw) {
        data->newargs = PyTuple_New(1);
        if (data->newargs) {
          Py_INCREF(obj);
          PyTuple_SET_ITEM(data->newargs, 0, obj);
        } else {
          Py_DECREF(data->newraw);
          Py_DECREF(data->klass);
          free(data);
          return 0;
        }
      } else {
        Py_INCREF(obj);
        data->newargs = obj;
      }
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      data->delargs = !(PyCFunction_GET_FLAGS(data->destroy) & METH_O);
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data)
{
  Py_XDECREF(data->klass);
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
  free(data);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_XINCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    PyObject *val = SwigPyObject_long(v);
    if (val) {
      PyObject *ofmt;
      PyTuple_SET_ITEM(args, 0, val);
      ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
        res = PyUnicode_Format(ofmt,args);
#else
        res = PyString_Format(ofmt,args);
#endif
        Py_DECREF(ofmt);
      }
    }
    Py_DECREF(args);
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_repr(SwigPyObject *v)
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (repr && v->next) {
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
    if (nrep) {
# if PY_VERSION_HEX >= 0x03000000
      PyObject *joined = PyUnicode_Concat(repr, nrep);
      Py_DecRef(repr);
      Py_DecRef(nrep);
      repr = joined;
# else
      PyString_ConcatAndDel(&repr,nrep);
# endif
    } else {
      Py_DecRef(repr);
      repr = NULL;
    }
  }
  return repr;
}

/* We need a version taking two PyObject* parameters so it's a valid
 * PyCFunction to use in swigobject_methods[]. */
SWIGRUNTIME PyObject *
SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  return SwigPyObject_repr((SwigPyObject*)v);
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

static PyObject* Swig_Capsule_global = NULL;

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *type = NULL, *value = NULL, *traceback = NULL;
      PyErr_Fetch(&type, &value, &traceback);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        if (tmp) {
          res = SWIG_Python_CallFunctor(destroy, tmp);
        } else {
          res = 0;
        }
        Py_XDECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(type, value, traceback);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
    Py_XDECREF(Swig_Capsule_global);
  }
  Py_XDECREF(next);
#ifdef SWIGPYTHON_BUILTIN
  Py_XDECREF(sobj->dict);
#endif
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  ((SwigPyObject *)next)->next = sobj->next;
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
    return NULL;
  } else {
    SwigPyObject *sobj = (SwigPyObject *)v;
    PyObject *obj = PyBool_FromLong(sobj->own);
    if (val) {
      if (PyObject_IsTrue(val)) {
        Py_DECREF(SwigPyObject_acquire(v,args));
      } else {
        Py_DECREF(SwigPyObject_disown(v,args));
      }
    } 
    return obj;
  }
}

static PyMethodDef
swigobject_methods[] = {
  {"disown",  SwigPyObject_disown,  METH_NOARGS,  "releases ownership of the pointer"},
  {"acquire", SwigPyObject_acquire, METH_NOARGS,  "acquires ownership of the pointer"},
  {"own",     SwigPyObject_own,     METH_VARARGS, "returns/sets ownership of the pointer"},
  {"append",  SwigPyObject_append,  METH_O,       "appends another 'this' object"},
  {"next",    SwigPyObject_next,    METH_NOARGS,  "returns the next 'this' object"},
  {"__repr__",SwigPyObject_repr2,   METH_NOARGS,  "returns object representation"},
  {0, 0, 0, 0}  
};

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#else
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyObject",                       /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
#if PY_VERSION_HEX < 0x030800b4
      (printfunc)0,                         /*tp_print*/
#else
      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
#endif
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                    /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                    /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpyobject_type) != 0)
      return NULL;
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
#ifdef SWIGPYTHON_BUILTIN
    sobj->dict = 0;
#endif
    if (own == SWIG_POINTER_OWN) {
      /* Obtain a reference to the Python capsule wrapping the module information, so that the
       * module information is correctly destroyed after all SWIG python objects have been freed
       * by the GC (and corresponding destructors invoked) */
      Py_XINCREF(Swig_Capsule_global);
    }
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((const char *)v->pack, (const char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyPacked",                       /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
#if PY_VERSION_HEX < 0x030800b4
      (printfunc)0,                         /*tp_print*/
#else
      (Py_ssize_t)0,                        /*tp_vectorcall_offset*/
#endif
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                    /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                    /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpypacked_type) != 0)
      return NULL;
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

static PyObject *Swig_This_global = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (Swig_This_global == NULL)
    Swig_This_global = SWIG_Python_str_FromChar("this");
  return Swig_This_global;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !sobj->own) {
      res = SWIG_ERROR_RELEASE_NOT_OWNED;
    } else {
      if (own)
        *own = *own | sobj->own;
      if (flags & SWIG_POINTER_DISOWN) {
        sobj->own = 0;
      }
      if (flags & SWIG_POINTER_CLEAR) {
        sobj->ptr = 0;
      }
      res = SWIG_OK;
    }
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
      if (!SWIG_IsOK(res) && obj == Py_None) {
        if (ptr)
          *ptr = 0;
        if (PyErr_Occurred())
          PyErr_Clear();
        res = SWIG_OK;
      }
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    swig_cast_info *tc;

    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc)
      return SWIG_ERROR;
    tc = SWIG_TypeCheck(desc,ty);
    if (tc) {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    } else {
      return SWIG_ERROR;
    }
    return SWIG_OK;
  }
}

/* Convert a packed pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
        PyObject *dict = *dictptr;
        if (dict == NULL) {
          dict = PyDict_New();
          *dictptr = dict;
        }
        if (dict) {
          PyDict_SetItem(dict, SWIG_This(), swig_this);
        } else{
          Py_DECREF(inst);
          inst = 0;
        }
      }
#else
      if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
        Py_DECREF(inst);
        inst = 0;
      }
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *empty_args = PyTuple_New(0);
    if (empty_args) {
      PyObject *empty_kwargs = PyDict_New();
      if (empty_kwargs) {
        inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
        Py_DECREF(empty_kwargs);
        if (inst) {
          if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
            Py_DECREF(inst);
            inst = 0;
          } else {
            PyType_Modified(Py_TYPE(inst));
          }
        }
      }
      Py_DECREF(empty_args);
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
}

SWIGRUNTIME int
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
  PyObject **dictptr = _PyObject_GetDictPtr(inst);
  if (dictptr != NULL) {
    PyObject *dict = *dictptr;
    if (dict == NULL) {
      dict = PyDict_New();
      *dictptr = dict;
    }
    if (dict) {
      return PyDict_SetItem(dict, SWIG_This(), swig_this);
    } else{
      return -1;
    }
  }
#endif
  return PyObject_SetAttr(inst, SWIG_This(), swig_this);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      Py_DECREF(SwigPyObject_append((PyObject*) sthis, obj[1]));
    } else {
      if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
        return NULL;
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      if (newobj) {
        newobj->dict = 0;
      }
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

static PyObject *Swig_TypeCache_global = NULL;

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  if (Swig_TypeCache_global == NULL) {
    Swig_TypeCache_global = PyDict_New();
  }
  return Swig_TypeCache_global;
}

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
#ifdef SWIG_LINK_RUNTIME
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
  }
#else
  void *type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
  if (PyErr_Occurred()) {
    PyErr_Clear();
    type_pointer = (void *)0;
  }
#endif
  return (swig_module_info *) type_pointer;
}


static int interpreter_counter = 0; // how many (sub-)interpreters are using swig_module's types

SWIGRUNTIME void
SWIG_Python_DestroyModule(PyObject *obj)
{
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
  swig_type_info **types = swig_module->types;
  size_t i;
  if (--interpreter_counter != 0) // another sub-interpreter may still be using the swig_module's types
    return;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      ty->clientdata = 0;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  Swig_This_global = NULL;
  Py_DECREF(SWIG_globals());
  Swig_Globals_global = NULL;
  Py_DECREF(SWIG_Python_TypeCache());
  Swig_TypeCache_global = NULL;
  Swig_Capsule_global = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    if (PyModule_AddObject(module, SWIGPY_CAPSULE_ATTR_NAME, pointer) == 0) {
      ++interpreter_counter;
      Swig_Capsule_global = pointer;
    } else {
      Py_DECREF(pointer);
    }
  } else {
    Py_XDECREF(pointer);
  }
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
      if (obj) {
        PyDict_SetItem(cache, key, obj);
        Py_DECREF(obj);
      }
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      PyObject *old_str = PyObject_Str(value);
      const char *tmp = SWIG_Python_str_AsChar(old_str);
      const char *errmesg = tmp ? tmp : "Invalid error message";
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, errmesg);
      } else {
	PyErr_Format(type, "%s %s", errmesg, mesg);
      }
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) != 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
      if (!encoded_name)
        goto done;
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 

/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that Python proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_DIRECTOR_PYTHON_HEADER_
#define SWIG_DIRECTOR_PYTHON_HEADER_

#include <string>
#include <iostream>
#include <exception>
#include <vector>
#include <map>


/*
  Use -DSWIG_PYTHON_DIRECTOR_NO_VTABLE if you don't want to generate a 'virtual
  table', and avoid multiple GetAttr calls to retrieve the python
  methods.
*/

#ifndef SWIG_PYTHON_DIRECTOR_NO_VTABLE
#ifndef SWIG_PYTHON_DIRECTOR_VTABLE
#define SWIG_PYTHON_DIRECTOR_VTABLE
#endif
#endif



/*
  Use -DSWIG_DIRECTOR_NO_UEH if you prefer to avoid the use of the
  Undefined Exception Handler provided by swig.
*/
#ifndef SWIG_DIRECTOR_NO_UEH
#ifndef SWIG_DIRECTOR_UEH
#define SWIG_DIRECTOR_UEH
#endif
#endif


/*
  Use -DSWIG_DIRECTOR_NORTTI if you prefer to avoid the use of the
  native C++ RTTI and dynamic_cast<>. But be aware that directors
  could stop working when using this option.
*/
#ifdef SWIG_DIRECTOR_NORTTI
/*
   When we don't use the native C++ RTTI, we implement a minimal one
   only for Directors.
*/
# ifndef SWIG_DIRECTOR_RTDIR
# define SWIG_DIRECTOR_RTDIR

namespace Swig {
  class Director;
  SWIGINTERN std::map<void *, Director *>& get_rtdir_map() {
    static std::map<void *, Director *> rtdir_map;
    return rtdir_map;
  }

  SWIGINTERNINLINE void set_rtdir(void *vptr, Director *rtdir) {
    get_rtdir_map()[vptr] = rtdir;
  }

  SWIGINTERNINLINE Director *get_rtdir(void *vptr) {
    std::map<void *, Director *>::const_iterator pos = get_rtdir_map().find(vptr);
    Director *rtdir = (pos != get_rtdir_map().end()) ? pos->second : 0;
    return rtdir;
  }
}
# endif /* SWIG_DIRECTOR_RTDIR */

# define SWIG_DIRECTOR_CAST(ARG) Swig::get_rtdir(static_cast<void *>(ARG))
# define SWIG_DIRECTOR_RGTR(ARG1, ARG2) Swig::set_rtdir(static_cast<void *>(ARG1), ARG2)

#else

# define SWIG_DIRECTOR_CAST(ARG) dynamic_cast<Swig::Director *>(ARG)
# define SWIG_DIRECTOR_RGTR(ARG1, ARG2)

#endif /* SWIG_DIRECTOR_NORTTI */

extern "C" {
  struct swig_type_info;
}

namespace Swig {

  /* memory handler */
  struct GCItem {
    virtual ~GCItem() {}

    virtual int get_own() const {
      return 0;
    }
  };

  struct GCItem_var {
    GCItem_var(GCItem *item = 0) : _item(item) {
    }

    GCItem_var& operator=(GCItem *item) {
      GCItem *tmp = _item;
      _item = item;
      delete tmp;
      return *this;
    }

    ~GCItem_var() {
      delete _item;
    }

    GCItem * operator->() const {
      return _item;
    }

  private:
    GCItem *_item;
  };

  struct GCItem_Object : GCItem {
    GCItem_Object(int own) : _own(own) {
    }

    virtual ~GCItem_Object() {
    }

    int get_own() const {
      return _own;
    }

  private:
    int _own;
  };

  template <typename Type>
  struct GCItem_T : GCItem {
    GCItem_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCItem_T() {
      delete _ptr;
    }

  private:
    Type *_ptr;
  };

  template <typename Type>
  struct GCArray_T : GCItem {
    GCArray_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCArray_T() {
      delete[] _ptr;
    }

  private:
    Type *_ptr;
  };

  /* base class for director exceptions */
  class DirectorException : public std::exception {
  protected:
    std::string swig_msg;
  public:
    DirectorException(PyObject *error, const char *hdr ="", const char *msg ="") : swig_msg(hdr) {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      if (msg[0]) {
        swig_msg += " ";
        swig_msg += msg;
      }
      if (!PyErr_Occurred()) {
        PyErr_SetString(error, what());
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
    }

    virtual ~DirectorException() throw() {
    }

    /* Deprecated, use what() instead */
    const char *getMessage() const {
      return what();
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }

    static void raise(PyObject *error, const char *msg) {
      throw DirectorException(error, msg);
    }

    static void raise(const char *msg) {
      raise(PyExc_RuntimeError, msg);
    }
  };

  /* type mismatch in the return value from a python method call */
  class DirectorTypeMismatchException : public DirectorException {
  public:
    DirectorTypeMismatchException(PyObject *error, const char *msg="")
      : DirectorException(error, "SWIG director type mismatch", msg) {
    }

    DirectorTypeMismatchException(const char *msg="")
      : DirectorException(PyExc_TypeError, "SWIG director type mismatch", msg) {
    }

    static void raise(PyObject *error, const char *msg) {
      throw DirectorTypeMismatchException(error, msg);
    }

    static void raise(const char *msg) {
      throw DirectorTypeMismatchException(msg);
    }
  };

  /* any python exception that occurs during a director method call */
  class DirectorMethodException : public DirectorException {
  public:
    DirectorMethodException(const char *msg = "")
      : DirectorException(PyExc_RuntimeError, "SWIG director method error.", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorMethodException(msg);
    }
  };

  /* attempt to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public DirectorException {
  public:
    DirectorPureVirtualException(const char *msg = "")
      : DirectorException(PyExc_RuntimeError, "SWIG director pure virtual method called", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorPureVirtualException(msg);
    }
  };


#if defined(SWIG_PYTHON_THREADS)
/*  __THREAD__ is the old macro to activate some thread support */
# if !defined(__THREAD__)
#   define __THREAD__ 1
# endif
#endif

#ifdef __THREAD__
# include "pythread.h"
  class Guard {
    PyThread_type_lock &mutex_;

  public:
    Guard(PyThread_type_lock & mutex) : mutex_(mutex) {
      PyThread_acquire_lock(mutex_, WAIT_LOCK);
    }

    ~Guard() {
      PyThread_release_lock(mutex_);
    }
  };
# define SWIG_GUARD(mutex) Guard _guard(mutex)
#else
# define SWIG_GUARD(mutex)
#endif

  /* director base class */
  class Director {
  private:
    /* pointer to the wrapped python object */
    PyObject *swig_self;
    /* flag indicating whether the object is owned by python or c++ */
    mutable bool swig_disown_flag;

    /* decrement the reference count of the wrapped python object */
    void swig_decref() const {
      if (swig_disown_flag) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_DECREF(swig_self);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }

  public:
    /* wrap a python object. */
    Director(PyObject *self) : swig_self(self), swig_disown_flag(false) {
    }

    /* discard our reference at destruction */
    virtual ~Director() {
      swig_decref();
    }

    /* return a pointer to the wrapped python object */
    PyObject *swig_get_self() const {
      return swig_self;
    }

    /* acquire ownership of the wrapped python object (the sense of "disown" is from python) */
    void swig_disown() const {
      if (!swig_disown_flag) {
        swig_disown_flag=true;
        swig_incref();
      }
    }

    /* increase the reference count of the wrapped python object */
    void swig_incref() const {
      if (swig_disown_flag) {
        Py_INCREF(swig_self);
      }
    }

    /* methods to implement pseudo protected director members */
    virtual bool swig_get_inner(const char * /* swig_protected_method_name */) const {
      return true;
    }

    virtual void swig_set_inner(const char * /* swig_protected_method_name */, bool /* swig_val */) const {
    }

  /* ownership management */
  private:
    typedef std::map<void *, GCItem_var> swig_ownership_map;
    mutable swig_ownership_map swig_owner;
#ifdef __THREAD__
    static PyThread_type_lock swig_mutex_own;
#endif

  public:
    template <typename Type>
    void swig_acquire_ownership_array(Type *vptr) const {
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCArray_T<Type>(vptr);
      }
    }

    template <typename Type>
    void swig_acquire_ownership(Type *vptr) const {
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCItem_T<Type>(vptr);
      }
    }

    void swig_acquire_ownership_obj(void *vptr, int own) const {
      if (vptr && own) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCItem_Object(own);
      }
    }

    int swig_release_ownership(void *vptr) const {
      int own = 0;
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_ownership_map::iterator iter = swig_owner.find(vptr);
        if (iter != swig_owner.end()) {
          own = iter->second->get_own();
          swig_owner.erase(iter);
        }
      }
      return own;
    }

    template <typename Type>
    static PyObject *swig_pyobj_disown(PyObject *pyobj, PyObject *SWIGUNUSEDPARM(args)) {
      SwigPyObject *sobj = (SwigPyObject *)pyobj;
      sobj->own = 0;
      Director *d = SWIG_DIRECTOR_CAST(reinterpret_cast<Type *>(sobj->ptr));
      if (d)
        d->swig_disown();
      return PyWeakref_NewProxy(pyobj, NULL);
    }
  };

#ifdef __THREAD__
  PyThread_type_lock Director::swig_mutex_own = PyThread_allocate_lock();
#endif
}

#endif

/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Argument swig_types[0]
#define SWIGTYPE_p_ContainedIndexType swig_types[1]
#define SWIGTYPE_p_ContainedIndexTypes swig_types[2]
#define SWIGTYPE_p_ContainedType swig_types[3]
#define SWIGTYPE_p_ContainedTypes swig_types[4]
#define SWIGTYPE_p_DecoratorHasTraits swig_types[5]
#define SWIGTYPE_p_DecoratorTraits swig_types[6]
#define SWIGTYPE_p_Eigen__ArrayXXd swig_types[7]
#define SWIGTYPE_p_Eigen__ArrayXXf swig_types[8]
#define SWIGTYPE_p_Eigen__Matrix3d swig_types[9]
#define SWIGTYPE_p_Eigen__MatrixXd swig_types[10]
#define SWIGTYPE_p_Eigen__MatrixXf swig_types[11]
#define SWIGTYPE_p_Eigen__Vector3d swig_types[12]
#define SWIGTYPE_p_Eigen__VectorXd swig_types[13]
#define SWIGTYPE_p_Eigen__VectorXf swig_types[14]
#define SWIGTYPE_p_ExtendedIndex swig_types[15]
#define SWIGTYPE_p_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t swig_types[16]
#define SWIGTYPE_p_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t swig_types[17]
#define SWIGTYPE_p_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t swig_types[18]
#define SWIGTYPE_p_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t swig_types[19]
#define SWIGTYPE_p_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t swig_types[20]
#define SWIGTYPE_p_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t swig_types[21]
#define SWIGTYPE_p_IMP__AttributeOptimizer swig_types[22]
#define SWIGTYPE_p_IMP__CheckLevel swig_types[23]
#define SWIGTYPE_p_IMP__Configuration swig_types[24]
#define SWIGTYPE_p_IMP__ConfigurationSet swig_types[25]
#define SWIGTYPE_p_IMP__Constraint swig_types[26]
#define SWIGTYPE_p_IMP__Container swig_types[27]
#define SWIGTYPE_p_IMP__CreateLogContext swig_types[28]
#define SWIGTYPE_p_IMP__Decorator swig_types[29]
#define SWIGTYPE_p_IMP__DerivativeAccumulator swig_types[30]
#define SWIGTYPE_p_IMP__EvaluationState swig_types[31]
#define SWIGTYPE_p_IMP__FloatIndex swig_types[32]
#define SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t swig_types[33]
#define SWIGTYPE_p_IMP__KeyT_0_t swig_types[34]
#define SWIGTYPE_p_IMP__KeyT_10_t swig_types[35]
#define SWIGTYPE_p_IMP__KeyT_11_t swig_types[36]
#define SWIGTYPE_p_IMP__KeyT_12_t swig_types[37]
#define SWIGTYPE_p_IMP__KeyT_13_t swig_types[38]
#define SWIGTYPE_p_IMP__KeyT_14_t swig_types[39]
#define SWIGTYPE_p_IMP__KeyT_15_t swig_types[40]
#define SWIGTYPE_p_IMP__KeyT_1_t swig_types[41]
#define SWIGTYPE_p_IMP__KeyT_2_t swig_types[42]
#define SWIGTYPE_p_IMP__KeyT_34897493_t swig_types[43]
#define SWIGTYPE_p_IMP__KeyT_3_t swig_types[44]
#define SWIGTYPE_p_IMP__KeyT_4_t swig_types[45]
#define SWIGTYPE_p_IMP__KeyT_5_t swig_types[46]
#define SWIGTYPE_p_IMP__KeyT_6_t swig_types[47]
#define SWIGTYPE_p_IMP__KeyT_7_t swig_types[48]
#define SWIGTYPE_p_IMP__KeyT_8_t swig_types[49]
#define SWIGTYPE_p_IMP__KeyT_9_t swig_types[50]
#define SWIGTYPE_p_IMP__Model swig_types[51]
#define SWIGTYPE_p_IMP__ModelObject swig_types[52]
#define SWIGTYPE_p_IMP__NonCopyable swig_types[53]
#define SWIGTYPE_p_IMP__Object swig_types[54]
#define SWIGTYPE_p_IMP__Optimizer swig_types[55]
#define SWIGTYPE_p_IMP__OptimizerState swig_types[56]
#define SWIGTYPE_p_IMP__PairContainer swig_types[57]
#define SWIGTYPE_p_IMP__PairModifier swig_types[58]
#define SWIGTYPE_p_IMP__PairPredicate swig_types[59]
#define SWIGTYPE_p_IMP__PairScore swig_types[60]
#define SWIGTYPE_p_IMP__Particle swig_types[61]
#define SWIGTYPE_p_IMP__ParticleAdaptor swig_types[62]
#define SWIGTYPE_p_IMP__ParticleIndexesAdaptor swig_types[63]
#define SWIGTYPE_p_IMP__ParticleInputs swig_types[64]
#define SWIGTYPE_p_IMP__QuadContainer swig_types[65]
#define SWIGTYPE_p_IMP__QuadModifier swig_types[66]
#define SWIGTYPE_p_IMP__QuadPredicate swig_types[67]
#define SWIGTYPE_p_IMP__QuadScore swig_types[68]
#define SWIGTYPE_p_IMP__RAII swig_types[69]
#define SWIGTYPE_p_IMP__Refiner swig_types[70]
#define SWIGTYPE_p_IMP__Restraint swig_types[71]
#define SWIGTYPE_p_IMP__RestraintInfo swig_types[72]
#define SWIGTYPE_p_IMP__RestraintSet swig_types[73]
#define SWIGTYPE_p_IMP__Sampler swig_types[74]
#define SWIGTYPE_p_IMP__SaveToConfigurationSetOptimizerState swig_types[75]
#define SWIGTYPE_p_IMP__ScopedSetAttributeT_IMP__KeyT_0_t_double_t swig_types[76]
#define SWIGTYPE_p_IMP__ScoreAccumulator swig_types[77]
#define SWIGTYPE_p_IMP__ScoreState swig_types[78]
#define SWIGTYPE_p_IMP__ScoringFunction swig_types[79]
#define SWIGTYPE_p_IMP__SetCheckState swig_types[80]
#define SWIGTYPE_p_IMP__SetLogState swig_types[81]
#define SWIGTYPE_p_IMP__SetLogTarget swig_types[82]
#define SWIGTYPE_p_IMP__SetNumberOfThreads swig_types[83]
#define SWIGTYPE_p_IMP__SingletonContainer swig_types[84]
#define SWIGTYPE_p_IMP__SingletonContainerAdaptor swig_types[85]
#define SWIGTYPE_p_IMP__SingletonModifier swig_types[86]
#define SWIGTYPE_p_IMP__SingletonPredicate swig_types[87]
#define SWIGTYPE_p_IMP__SingletonScore swig_types[88]
#define SWIGTYPE_p_IMP__TripletContainer swig_types[89]
#define SWIGTYPE_p_IMP__TripletModifier swig_types[90]
#define SWIGTYPE_p_IMP__TripletPredicate swig_types[91]
#define SWIGTYPE_p_IMP__TripletScore swig_types[92]
#define SWIGTYPE_p_IMP__UnaryFunction swig_types[93]
#define SWIGTYPE_p_IMP__Undecorator swig_types[94]
#define SWIGTYPE_p_IMP__Value swig_types[95]
#define SWIGTYPE_p_IMP__VectorT_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t swig_types[96]
#define SWIGTYPE_p_IMP__VectorT_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t swig_types[97]
#define SWIGTYPE_p_IMP__VectorT_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t swig_types[98]
#define SWIGTYPE_p_IMP__VectorT_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t swig_types[99]
#define SWIGTYPE_p_IMP__VectorT_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t swig_types[100]
#define SWIGTYPE_p_IMP__VectorT_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t swig_types[101]
#define SWIGTYPE_p_IMP__VectorT_IMP__DerivativeAccumulator_t swig_types[102]
#define SWIGTYPE_p_IMP__VectorT_IMP__EvaluationState_t swig_types[103]
#define SWIGTYPE_p_IMP__VectorT_IMP__FloatIndex_t swig_types[104]
#define SWIGTYPE_p_IMP__VectorT_IMP__IndexT_IMP__ParticleIndexTag_t_t swig_types[105]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_0_t_t swig_types[106]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_10_t_t swig_types[107]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_11_t_t swig_types[108]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_12_t_t swig_types[109]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_13_t_t swig_types[110]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_14_t_t swig_types[111]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_15_t_t swig_types[112]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_1_t_t swig_types[113]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_2_t_t swig_types[114]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_34897493_t_t swig_types[115]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_3_t_t swig_types[116]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_4_t_t swig_types[117]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_5_t_t swig_types[118]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_6_t_t swig_types[119]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_7_t_t swig_types[120]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_8_t_t swig_types[121]
#define SWIGTYPE_p_IMP__VectorT_IMP__KeyT_9_t_t swig_types[122]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__AttributeOptimizer_t_t swig_types[123]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__ConfigurationSet_t_t swig_types[124]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__Configuration_t_t swig_types[125]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__Constraint_t_t swig_types[126]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__Container_t_t swig_types[127]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__ModelObject_t_t swig_types[128]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__Model_t_t swig_types[129]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__Object_t_t swig_types[130]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__OptimizerState_t_t swig_types[131]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__Optimizer_t_t swig_types[132]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__PairContainer_t_t swig_types[133]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__PairModifier_t_t swig_types[134]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__PairPredicate_t_t swig_types[135]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__PairScore_t_t swig_types[136]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__QuadContainer_t_t swig_types[137]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__QuadModifier_t_t swig_types[138]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__QuadPredicate_t_t swig_types[139]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__QuadScore_t_t swig_types[140]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__Refiner_t_t swig_types[141]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__RestraintSet_t_t swig_types[142]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__Restraint_t_t swig_types[143]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__Sampler_t_t swig_types[144]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__ScoreState_t_t swig_types[145]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__ScoringFunction_t_t swig_types[146]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__SingletonContainer_t_t swig_types[147]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__SingletonModifier_t_t swig_types[148]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__SingletonPredicate_t_t swig_types[149]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__SingletonScore_t_t swig_types[150]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__TripletContainer_t_t swig_types[151]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__TripletModifier_t_t swig_types[152]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__TripletPredicate_t_t swig_types[153]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__TripletScore_t_t swig_types[154]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__UnaryFunction_t_t swig_types[155]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__Undecorator_t_t swig_types[156]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__algebra__VectorKDMetric_t_t swig_types[157]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__AllBipartitePairContainer_t_t swig_types[158]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__AllPairContainer_t_t swig_types[159]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__ClosePairContainer_t_t swig_types[160]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__ConnectingPairContainer_t_t swig_types[161]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__ConsecutivePairContainer_t_t swig_types[162]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListPairContainer_t_t swig_types[163]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListQuadContainer_t_t swig_types[164]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListSingletonContainer_t_t swig_types[165]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListTripletContainer_t_t swig_types[166]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerPairFilter_t_t swig_types[167]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerQuadFilter_t_t swig_types[168]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerSingletonFilter_t_t swig_types[169]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerTripletFilter_t_t swig_types[170]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__ListPairContainer_t_t swig_types[171]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__ListQuadContainer_t_t swig_types[172]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__ListSingletonContainer_t_t swig_types[173]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__ListTripletContainer_t_t swig_types[174]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumPairScore_t_t swig_types[175]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumQuadScore_t_t swig_types[176]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumSingletonScore_t_t swig_types[177]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumTripletScore_t_t swig_types[178]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__PairsConstraint_t_t swig_types[179]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__PairsOptimizerState_t_t swig_types[180]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__PairsRestraint_t_t swig_types[181]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsConstraint_t_t swig_types[182]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsOptimizerState_t_t swig_types[183]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsRestraint_t_t swig_types[184]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsConstraint_t_t swig_types[185]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsOptimizerState_t_t swig_types[186]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsRestraint_t_t swig_types[187]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsConstraint_t_t swig_types[188]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsOptimizerState_t_t swig_types[189]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsRestraint_t_t swig_types[190]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__core__DistancePairScore_t_t swig_types[191]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicDistancePairScore_t_t swig_types[192]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t swig_types[193]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicWell_t_t swig_types[194]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__core__MonteCarloMover_t_t swig_types[195]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometryConstraint_t_t swig_types[196]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometry_t_t swig_types[197]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__display__Geometry_t_t swig_types[198]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__display__TextWriter_t_t swig_types[199]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__display__Writer_t_t swig_types[200]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t swig_types[201]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t swig_types[202]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t swig_types[203]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstOptimizer_t_t swig_types[204]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstPairScore_t_t swig_types[205]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstRestraint_t_t swig_types[206]
#define SWIGTYPE_p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstSingletonScore_t_t swig_types[207]
#define SWIGTYPE_p_IMP__VectorT_IMP__ScoreAccumulator_t swig_types[208]
#define SWIGTYPE_p_IMP__VectorT_IMP__SetCheckState_t swig_types[209]
#define SWIGTYPE_p_IMP__VectorT_IMP__SetLogState_t swig_types[210]
#define SWIGTYPE_p_IMP__VectorT_IMP__TextInput_t swig_types[211]
#define SWIGTYPE_p_IMP__VectorT_IMP__TextOutput_t swig_types[212]
#define SWIGTYPE_p_IMP__VectorT_IMP__VectorT_IMP__VectorT_double_t_t_t swig_types[213]
#define SWIGTYPE_p_IMP__VectorT_IMP__VectorT_IMP__VectorT_int_t_t_t swig_types[214]
#define SWIGTYPE_p_IMP__VectorT_IMP__VectorT_IMP__VectorT_std__string_t_t_t swig_types[215]
#define SWIGTYPE_p_IMP__VectorT_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t_t swig_types[216]
#define SWIGTYPE_p_IMP__VectorT_IMP__VectorT_WeakPointerT_IMP__Particle_t_t_t swig_types[217]
#define SWIGTYPE_p_IMP__VectorT_IMP__VectorT_double_t_t swig_types[218]
#define SWIGTYPE_p_IMP__VectorT_IMP__VectorT_int_t_t swig_types[219]
#define SWIGTYPE_p_IMP__VectorT_IMP__VectorT_std__pairT_double_double_t_t_t swig_types[220]
#define SWIGTYPE_p_IMP__VectorT_IMP__VectorT_std__pairT_int_int_t_t_t swig_types[221]
#define SWIGTYPE_p_IMP__VectorT_IMP__VectorT_std__string_t_t swig_types[222]
#define SWIGTYPE_p_IMP__VectorT_IMP__VersionInfo_t swig_types[223]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__AttributeOptimizer_t_t swig_types[224]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__ConfigurationSet_t_t swig_types[225]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__Configuration_t_t swig_types[226]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__Constraint_t_t swig_types[227]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__Container_t_t swig_types[228]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t swig_types[229]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__Model_t_t swig_types[230]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__Object_t_t swig_types[231]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__OptimizerState_t_t swig_types[232]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__Optimizer_t_t swig_types[233]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__PairContainer_t_t swig_types[234]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__PairModifier_t_t swig_types[235]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__PairPredicate_t_t swig_types[236]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__PairScore_t_t swig_types[237]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadContainer_t_t swig_types[238]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadModifier_t_t swig_types[239]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadPredicate_t_t swig_types[240]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadScore_t_t swig_types[241]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__Refiner_t_t swig_types[242]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__RestraintSet_t_t swig_types[243]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__Restraint_t_t swig_types[244]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__Sampler_t_t swig_types[245]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoreState_t_t swig_types[246]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoringFunction_t_t swig_types[247]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonContainer_t_t swig_types[248]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonModifier_t_t swig_types[249]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonPredicate_t_t swig_types[250]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonScore_t_t swig_types[251]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletContainer_t_t swig_types[252]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletModifier_t_t swig_types[253]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletPredicate_t_t swig_types[254]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletScore_t_t swig_types[255]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__UnaryFunction_t_t swig_types[256]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__Undecorator_t_t swig_types[257]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__algebra__VectorKDMetric_t_t swig_types[258]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllBipartitePairContainer_t_t swig_types[259]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllPairContainer_t_t swig_types[260]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ClosePairContainer_t_t swig_types[261]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConnectingPairContainer_t_t swig_types[262]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConsecutivePairContainer_t_t swig_types[263]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListPairContainer_t_t swig_types[264]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListQuadContainer_t_t swig_types[265]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListSingletonContainer_t_t swig_types[266]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListTripletContainer_t_t swig_types[267]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerPairFilter_t_t swig_types[268]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerQuadFilter_t_t swig_types[269]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerSingletonFilter_t_t swig_types[270]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerTripletFilter_t_t swig_types[271]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListPairContainer_t_t swig_types[272]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListQuadContainer_t_t swig_types[273]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListSingletonContainer_t_t swig_types[274]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListTripletContainer_t_t swig_types[275]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumPairScore_t_t swig_types[276]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumQuadScore_t_t swig_types[277]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumSingletonScore_t_t swig_types[278]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumTripletScore_t_t swig_types[279]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsConstraint_t_t swig_types[280]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsOptimizerState_t_t swig_types[281]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsRestraint_t_t swig_types[282]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsConstraint_t_t swig_types[283]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsOptimizerState_t_t swig_types[284]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsRestraint_t_t swig_types[285]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsConstraint_t_t swig_types[286]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsOptimizerState_t_t swig_types[287]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsRestraint_t_t swig_types[288]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsConstraint_t_t swig_types[289]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsOptimizerState_t_t swig_types[290]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsRestraint_t_t swig_types[291]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__DistancePairScore_t_t swig_types[292]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicDistancePairScore_t_t swig_types[293]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t swig_types[294]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicWell_t_t swig_types[295]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__MonteCarloMover_t_t swig_types[296]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometryConstraint_t_t swig_types[297]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometry_t_t swig_types[298]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Geometry_t_t swig_types[299]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__display__TextWriter_t_t swig_types[300]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Writer_t_t swig_types[301]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t swig_types[302]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t swig_types[303]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t swig_types[304]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstOptimizer_t_t swig_types[305]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstPairScore_t_t swig_types[306]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstRestraint_t_t swig_types[307]
#define SWIGTYPE_p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstSingletonScore_t_t swig_types[308]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_1_t_t swig_types[309]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_2_t_t swig_types[310]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_3_t_t swig_types[311]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_4_t_t swig_types[312]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_5_t_t swig_types[313]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_6_t_t swig_types[314]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT__1_t_t swig_types[315]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_1_t_t swig_types[316]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_2_t_t swig_types[317]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_3_t_t swig_types[318]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_4_t_t swig_types[319]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_5_t_t swig_types[320]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_6_t_t swig_types[321]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__BoundingBoxDT__1_t_t swig_types[322]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Cone3D_t swig_types[323]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__ConnollySurfacePoint_t swig_types[324]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Cylinder3D_t swig_types[325]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_1_t_t swig_types[326]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_2_t_t swig_types[327]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_3_t_t swig_types[328]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_4_t_t swig_types[329]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_5_t_t swig_types[330]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_6_t_t swig_types[331]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT__1_t_t swig_types[332]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Ellipsoid3D_t swig_types[333]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_1_t_t swig_types[334]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_2_t_t swig_types[335]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_3_t_t swig_types[336]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_4_t_t swig_types[337]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_5_t_t swig_types[338]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_6_t_t swig_types[339]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT__1_t_t swig_types[340]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__FixedXYZ_t swig_types[341]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Gaussian3D_t swig_types[342]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__GridIndexDT_1_t_t swig_types[343]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__GridIndexDT_2_t_t swig_types[344]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__GridIndexDT_3_t_t swig_types[345]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__GridIndexDT_4_t_t swig_types[346]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__GridIndexDT_5_t_t swig_types[347]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__GridIndexDT_6_t_t swig_types[348]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__GridIndexDT__1_t_t swig_types[349]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Line3D_t swig_types[350]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__LinearFit2D_t swig_types[351]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_1_t_t swig_types[352]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_2_t_t swig_types[353]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_3_t_t swig_types[354]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_4_t_t swig_types[355]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_5_t_t swig_types[356]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_6_t_t swig_types[357]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT__1_t_t swig_types[358]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__ParabolicFit2D_t swig_types[359]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Plane3D_t swig_types[360]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_1_t_t swig_types[361]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_2_t_t swig_types[362]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_3_t_t swig_types[363]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_4_t_t swig_types[364]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_5_t_t swig_types[365]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_6_t_t swig_types[366]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT__1_t_t swig_types[367]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__ReferenceFrame3D_t swig_types[368]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Reflection3D_t swig_types[369]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Rotation2D_t swig_types[370]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Rotation3D_t swig_types[371]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Segment3D_t swig_types[372]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__SphereDT_1_t_t swig_types[373]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__SphereDT_2_t_t swig_types[374]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__SphereDT_3_t_t swig_types[375]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__SphereDT_4_t_t swig_types[376]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__SphereDT_5_t_t swig_types[377]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__SphereDT_6_t_t swig_types[378]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__SphereDT__1_t_t swig_types[379]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__SpherePatch3D_t swig_types[380]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__SphericalVector3D_t swig_types[381]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Transformation2D_t swig_types[382]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Transformation3D_t swig_types[383]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__Triangle3D_t swig_types[384]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_1_t_t swig_types[385]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_2_t_t swig_types[386]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_3_t_t swig_types[387]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_4_t_t swig_types[388]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_5_t_t swig_types[389]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_6_t_t swig_types[390]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT__1_t_t swig_types[391]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_1_t_t swig_types[392]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_2_t_t swig_types[393]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_3_t_t swig_types[394]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_4_t_t swig_types[395]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_5_t_t swig_types[396]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_6_t_t swig_types[397]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__UnitSimplexDT__1_t_t swig_types[398]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__VectorDT_1_t_t swig_types[399]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__VectorDT_2_t_t swig_types[400]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__VectorDT_3_t_t swig_types[401]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__VectorDT_4_t_t swig_types[402]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__VectorDT_5_t_t swig_types[403]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__VectorDT_6_t_t swig_types[404]
#define SWIGTYPE_p_IMP__VectorT_IMP__algebra__VectorDT__1_t_t swig_types[405]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__BinormalTerm_t swig_types[406]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__Centroid_t swig_types[407]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__Cover_t swig_types[408]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__DirectionAngle_t swig_types[409]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__Direction_t swig_types[410]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__Gaussian_t swig_types[411]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__HierarchyCounter_t swig_types[412]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__HierarchyTraits_t swig_types[413]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__Hierarchy_t swig_types[414]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__MonteCarloMoverResult_t swig_types[415]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__Reference_t swig_types[416]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__RigidBodyMember_t swig_types[417]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__RigidBody_t swig_types[418]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__RigidMember_t swig_types[419]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__Surface_t swig_types[420]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__Typed_t swig_types[421]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__XYZR_t swig_types[422]
#define SWIGTYPE_p_IMP__VectorT_IMP__core__XYZ_t swig_types[423]
#define SWIGTYPE_p_IMP__VectorT_IMP__display__Color_t swig_types[424]
#define SWIGTYPE_p_IMP__VectorT_IMP__display__Colored_t swig_types[425]
#define SWIGTYPE_p_IMP__VectorT_IMP__display__GeometryProcessor_t swig_types[426]
#define SWIGTYPE_p_IMP__VectorT_IMP__display__WriterAdaptor_t swig_types[427]
#define SWIGTYPE_p_IMP__VectorT_IMP__internal___Protection_t swig_types[428]
#define SWIGTYPE_p_IMP__VectorT_IMP__internal___TestValue_t swig_types[429]
#define SWIGTYPE_p_IMP__VectorT_IMP__internal___TrivialDecorator_t swig_types[430]
#define SWIGTYPE_p_IMP__VectorT_IMP__internal___TrivialDerivedDecorator_t swig_types[431]
#define SWIGTYPE_p_IMP__VectorT_IMP__internal___TrivialTraitsDecorator_t swig_types[432]
#define SWIGTYPE_p_IMP__VectorT_PointerT_IMP__Particle_t_t swig_types[433]
#define SWIGTYPE_p_IMP__VectorT_WeakPointerT_IMP__Particle_t_t swig_types[434]
#define SWIGTYPE_p_IMP__VectorT_double_t swig_types[435]
#define SWIGTYPE_p_IMP__VectorT_int_t swig_types[436]
#define SWIGTYPE_p_IMP__VectorT_std__pairT_IMP__algebra__VectorDT_3_t_double_t_t swig_types[437]
#define SWIGTYPE_p_IMP__VectorT_std__pairT_double_double_t_t swig_types[438]
#define SWIGTYPE_p_IMP__VectorT_std__pairT_int_int_t_t swig_types[439]
#define SWIGTYPE_p_IMP__VectorT_std__string_t swig_types[440]
#define SWIGTYPE_p_IMP__VersionInfo swig_types[441]
#define SWIGTYPE_p_IMP__WarningContext swig_types[442]
#define SWIGTYPE_p_IMP__algebra__BoundedGridRangeDT_1_t swig_types[443]
#define SWIGTYPE_p_IMP__algebra__BoundedGridRangeDT_2_t swig_types[444]
#define SWIGTYPE_p_IMP__algebra__BoundedGridRangeDT_3_t swig_types[445]
#define SWIGTYPE_p_IMP__algebra__BoundedGridRangeDT_4_t swig_types[446]
#define SWIGTYPE_p_IMP__algebra__BoundedGridRangeDT_5_t swig_types[447]
#define SWIGTYPE_p_IMP__algebra__BoundedGridRangeDT_6_t swig_types[448]
#define SWIGTYPE_p_IMP__algebra__BoundedGridRangeDT__1_t swig_types[449]
#define SWIGTYPE_p_IMP__algebra__BoundingBoxDT_1_t swig_types[450]
#define SWIGTYPE_p_IMP__algebra__BoundingBoxDT_2_t swig_types[451]
#define SWIGTYPE_p_IMP__algebra__BoundingBoxDT_3_t swig_types[452]
#define SWIGTYPE_p_IMP__algebra__BoundingBoxDT_4_t swig_types[453]
#define SWIGTYPE_p_IMP__algebra__BoundingBoxDT_5_t swig_types[454]
#define SWIGTYPE_p_IMP__algebra__BoundingBoxDT_6_t swig_types[455]
#define SWIGTYPE_p_IMP__algebra__BoundingBoxDT__1_t swig_types[456]
#define SWIGTYPE_p_IMP__algebra__Cone3D swig_types[457]
#define SWIGTYPE_p_IMP__algebra__ConnollySurfacePoint swig_types[458]
#define SWIGTYPE_p_IMP__algebra__Cylinder3D swig_types[459]
#define SWIGTYPE_p_IMP__algebra__DefaultEmbeddingDT_1_t swig_types[460]
#define SWIGTYPE_p_IMP__algebra__DefaultEmbeddingDT_2_t swig_types[461]
#define SWIGTYPE_p_IMP__algebra__DefaultEmbeddingDT_3_t swig_types[462]
#define SWIGTYPE_p_IMP__algebra__DefaultEmbeddingDT_4_t swig_types[463]
#define SWIGTYPE_p_IMP__algebra__DefaultEmbeddingDT_5_t swig_types[464]
#define SWIGTYPE_p_IMP__algebra__DefaultEmbeddingDT_6_t swig_types[465]
#define SWIGTYPE_p_IMP__algebra__DefaultEmbeddingDT__1_t swig_types[466]
#define SWIGTYPE_p_IMP__algebra__DynamicNearestNeighbor3D swig_types[467]
#define SWIGTYPE_p_IMP__algebra__Ellipsoid3D swig_types[468]
#define SWIGTYPE_p_IMP__algebra__EuclideanVectorKDMetric swig_types[469]
#define SWIGTYPE_p_IMP__algebra__ExtendedGridIndexDT_1_t swig_types[470]
#define SWIGTYPE_p_IMP__algebra__ExtendedGridIndexDT_2_t swig_types[471]
#define SWIGTYPE_p_IMP__algebra__ExtendedGridIndexDT_3_t swig_types[472]
#define SWIGTYPE_p_IMP__algebra__ExtendedGridIndexDT_4_t swig_types[473]
#define SWIGTYPE_p_IMP__algebra__ExtendedGridIndexDT_5_t swig_types[474]
#define SWIGTYPE_p_IMP__algebra__ExtendedGridIndexDT_6_t swig_types[475]
#define SWIGTYPE_p_IMP__algebra__ExtendedGridIndexDT__1_t swig_types[476]
#define SWIGTYPE_p_IMP__algebra__FixedXYZ swig_types[477]
#define SWIGTYPE_p_IMP__algebra__Gaussian3D swig_types[478]
#define SWIGTYPE_p_IMP__algebra__GeometricPrimitiveDT_1_t swig_types[479]
#define SWIGTYPE_p_IMP__algebra__GeometricPrimitiveDT_2_t swig_types[480]
#define SWIGTYPE_p_IMP__algebra__GeometricPrimitiveDT_3_t swig_types[481]
#define SWIGTYPE_p_IMP__algebra__GeometricPrimitiveDT_4_t swig_types[482]
#define SWIGTYPE_p_IMP__algebra__GeometricPrimitiveDT_5_t swig_types[483]
#define SWIGTYPE_p_IMP__algebra__GeometricPrimitiveDT_6_t swig_types[484]
#define SWIGTYPE_p_IMP__algebra__GeometricPrimitiveDT__1_t swig_types[485]
#define SWIGTYPE_p_IMP__algebra__GridIndexDT_1_t swig_types[486]
#define SWIGTYPE_p_IMP__algebra__GridIndexDT_2_t swig_types[487]
#define SWIGTYPE_p_IMP__algebra__GridIndexDT_3_t swig_types[488]
#define SWIGTYPE_p_IMP__algebra__GridIndexDT_4_t swig_types[489]
#define SWIGTYPE_p_IMP__algebra__GridIndexDT_5_t swig_types[490]
#define SWIGTYPE_p_IMP__algebra__GridIndexDT_6_t swig_types[491]
#define SWIGTYPE_p_IMP__algebra__GridIndexDT__1_t swig_types[492]
#define SWIGTYPE_p_IMP__algebra__Line3D swig_types[493]
#define SWIGTYPE_p_IMP__algebra__LinearFit2D swig_types[494]
#define SWIGTYPE_p_IMP__algebra__LogEmbeddingDT_1_t swig_types[495]
#define SWIGTYPE_p_IMP__algebra__LogEmbeddingDT_2_t swig_types[496]
#define SWIGTYPE_p_IMP__algebra__LogEmbeddingDT_3_t swig_types[497]
#define SWIGTYPE_p_IMP__algebra__LogEmbeddingDT_4_t swig_types[498]
#define SWIGTYPE_p_IMP__algebra__LogEmbeddingDT_5_t swig_types[499]
#define SWIGTYPE_p_IMP__algebra__LogEmbeddingDT_6_t swig_types[500]
#define SWIGTYPE_p_IMP__algebra__LogEmbeddingDT__1_t swig_types[501]
#define SWIGTYPE_p_IMP__algebra__MaxVectorKDMetric swig_types[502]
#define SWIGTYPE_p_IMP__algebra__NearestNeighborDT_1_t swig_types[503]
#define SWIGTYPE_p_IMP__algebra__NearestNeighborDT_2_t swig_types[504]
#define SWIGTYPE_p_IMP__algebra__NearestNeighborDT_3_t swig_types[505]
#define SWIGTYPE_p_IMP__algebra__NearestNeighborDT_4_t swig_types[506]
#define SWIGTYPE_p_IMP__algebra__NearestNeighborDT_5_t swig_types[507]
#define SWIGTYPE_p_IMP__algebra__NearestNeighborDT_6_t swig_types[508]
#define SWIGTYPE_p_IMP__algebra__NearestNeighborDT__1_t swig_types[509]
#define SWIGTYPE_p_IMP__algebra__ParabolicFit2D swig_types[510]
#define SWIGTYPE_p_IMP__algebra__Plane3D swig_types[511]
#define SWIGTYPE_p_IMP__algebra__PrincipalComponentAnalysisDT_1_t swig_types[512]
#define SWIGTYPE_p_IMP__algebra__PrincipalComponentAnalysisDT_2_t swig_types[513]
#define SWIGTYPE_p_IMP__algebra__PrincipalComponentAnalysisDT_3_t swig_types[514]
#define SWIGTYPE_p_IMP__algebra__PrincipalComponentAnalysisDT_4_t swig_types[515]
#define SWIGTYPE_p_IMP__algebra__PrincipalComponentAnalysisDT_5_t swig_types[516]
#define SWIGTYPE_p_IMP__algebra__PrincipalComponentAnalysisDT_6_t swig_types[517]
#define SWIGTYPE_p_IMP__algebra__PrincipalComponentAnalysisDT__1_t swig_types[518]
#define SWIGTYPE_p_IMP__algebra__ReferenceFrame3D swig_types[519]
#define SWIGTYPE_p_IMP__algebra__Reflection3D swig_types[520]
#define SWIGTYPE_p_IMP__algebra__Rotation2D swig_types[521]
#define SWIGTYPE_p_IMP__algebra__Rotation3D swig_types[522]
#define SWIGTYPE_p_IMP__algebra__Segment3D swig_types[523]
#define SWIGTYPE_p_IMP__algebra__SphereDT_1_t swig_types[524]
#define SWIGTYPE_p_IMP__algebra__SphereDT_2_t swig_types[525]
#define SWIGTYPE_p_IMP__algebra__SphereDT_3_t swig_types[526]
#define SWIGTYPE_p_IMP__algebra__SphereDT_4_t swig_types[527]
#define SWIGTYPE_p_IMP__algebra__SphereDT_5_t swig_types[528]
#define SWIGTYPE_p_IMP__algebra__SphereDT_6_t swig_types[529]
#define SWIGTYPE_p_IMP__algebra__SphereDT__1_t swig_types[530]
#define SWIGTYPE_p_IMP__algebra__SpherePatch3D swig_types[531]
#define SWIGTYPE_p_IMP__algebra__SphericalVector3D swig_types[532]
#define SWIGTYPE_p_IMP__algebra__Transformation2D swig_types[533]
#define SWIGTYPE_p_IMP__algebra__Transformation3D swig_types[534]
#define SWIGTYPE_p_IMP__algebra__Triangle3D swig_types[535]
#define SWIGTYPE_p_IMP__algebra__UnboundedGridRangeDT_1_t swig_types[536]
#define SWIGTYPE_p_IMP__algebra__UnboundedGridRangeDT_2_t swig_types[537]
#define SWIGTYPE_p_IMP__algebra__UnboundedGridRangeDT_3_t swig_types[538]
#define SWIGTYPE_p_IMP__algebra__UnboundedGridRangeDT_4_t swig_types[539]
#define SWIGTYPE_p_IMP__algebra__UnboundedGridRangeDT_5_t swig_types[540]
#define SWIGTYPE_p_IMP__algebra__UnboundedGridRangeDT_6_t swig_types[541]
#define SWIGTYPE_p_IMP__algebra__UnboundedGridRangeDT__1_t swig_types[542]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexBaseDT_1_t swig_types[543]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexBaseDT_2_t swig_types[544]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexBaseDT_3_t swig_types[545]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexBaseDT_4_t swig_types[546]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexBaseDT_5_t swig_types[547]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexBaseDT_6_t swig_types[548]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexBaseDT__1_t swig_types[549]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexDT_1_t swig_types[550]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexDT_2_t swig_types[551]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexDT_3_t swig_types[552]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexDT_4_t swig_types[553]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexDT_5_t swig_types[554]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexDT_6_t swig_types[555]
#define SWIGTYPE_p_IMP__algebra__UnitSimplexDT__1_t swig_types[556]
#define SWIGTYPE_p_IMP__algebra__VectorBaseDT_1_t swig_types[557]
#define SWIGTYPE_p_IMP__algebra__VectorBaseDT_2_t swig_types[558]
#define SWIGTYPE_p_IMP__algebra__VectorBaseDT_3_t swig_types[559]
#define SWIGTYPE_p_IMP__algebra__VectorBaseDT_4_t swig_types[560]
#define SWIGTYPE_p_IMP__algebra__VectorBaseDT_5_t swig_types[561]
#define SWIGTYPE_p_IMP__algebra__VectorBaseDT_6_t swig_types[562]
#define SWIGTYPE_p_IMP__algebra__VectorBaseDT__1_t swig_types[563]
#define SWIGTYPE_p_IMP__algebra__VectorDT_1_t swig_types[564]
#define SWIGTYPE_p_IMP__algebra__VectorDT_2_t swig_types[565]
#define SWIGTYPE_p_IMP__algebra__VectorDT_3_t swig_types[566]
#define SWIGTYPE_p_IMP__algebra__VectorDT_4_t swig_types[567]
#define SWIGTYPE_p_IMP__algebra__VectorDT_5_t swig_types[568]
#define SWIGTYPE_p_IMP__algebra__VectorDT_6_t swig_types[569]
#define SWIGTYPE_p_IMP__algebra__VectorDT__1_t swig_types[570]
#define SWIGTYPE_p_IMP__algebra__VectorKDMetric swig_types[571]
#define SWIGTYPE_p_IMP__container__AllBipartitePairContainer swig_types[572]
#define SWIGTYPE_p_IMP__container__AllPairContainer swig_types[573]
#define SWIGTYPE_p_IMP__container__CloseBipartitePairContainer swig_types[574]
#define SWIGTYPE_p_IMP__container__ClosePairContainer swig_types[575]
#define SWIGTYPE_p_IMP__container__ConnectingPairContainer swig_types[576]
#define SWIGTYPE_p_IMP__container__ConsecutivePairContainer swig_types[577]
#define SWIGTYPE_p_IMP__container__ConsecutivePairFilter swig_types[578]
#define SWIGTYPE_p_IMP__container__DistributePairsScoreState swig_types[579]
#define SWIGTYPE_p_IMP__container__DistributeQuadsScoreState swig_types[580]
#define SWIGTYPE_p_IMP__container__DistributeSingletonsScoreState swig_types[581]
#define SWIGTYPE_p_IMP__container__DistributeTripletsScoreState swig_types[582]
#define SWIGTYPE_p_IMP__container__DynamicListPairContainer swig_types[583]
#define SWIGTYPE_p_IMP__container__DynamicListQuadContainer swig_types[584]
#define SWIGTYPE_p_IMP__container__DynamicListSingletonContainer swig_types[585]
#define SWIGTYPE_p_IMP__container__DynamicListTripletContainer swig_types[586]
#define SWIGTYPE_p_IMP__container__EventPairsOptimizerState swig_types[587]
#define SWIGTYPE_p_IMP__container__EventQuadsOptimizerState swig_types[588]
#define SWIGTYPE_p_IMP__container__EventSingletonsOptimizerState swig_types[589]
#define SWIGTYPE_p_IMP__container__EventTripletsOptimizerState swig_types[590]
#define SWIGTYPE_p_IMP__container__ExclusiveConsecutivePairContainer swig_types[591]
#define SWIGTYPE_p_IMP__container__ExclusiveConsecutivePairFilter swig_types[592]
#define SWIGTYPE_p_IMP__container__InContainerPairFilter swig_types[593]
#define SWIGTYPE_p_IMP__container__InContainerQuadFilter swig_types[594]
#define SWIGTYPE_p_IMP__container__InContainerSingletonFilter swig_types[595]
#define SWIGTYPE_p_IMP__container__InContainerTripletFilter swig_types[596]
#define SWIGTYPE_p_IMP__container__ListPairContainer swig_types[597]
#define SWIGTYPE_p_IMP__container__ListQuadContainer swig_types[598]
#define SWIGTYPE_p_IMP__container__ListSingletonContainer swig_types[599]
#define SWIGTYPE_p_IMP__container__ListTripletContainer swig_types[600]
#define SWIGTYPE_p_IMP__container__MinimumPairRestraint swig_types[601]
#define SWIGTYPE_p_IMP__container__MinimumPairScore swig_types[602]
#define SWIGTYPE_p_IMP__container__MinimumQuadRestraint swig_types[603]
#define SWIGTYPE_p_IMP__container__MinimumQuadScore swig_types[604]
#define SWIGTYPE_p_IMP__container__MinimumSingletonRestraint swig_types[605]
#define SWIGTYPE_p_IMP__container__MinimumSingletonScore swig_types[606]
#define SWIGTYPE_p_IMP__container__MinimumTripletRestraint swig_types[607]
#define SWIGTYPE_p_IMP__container__MinimumTripletScore swig_types[608]
#define SWIGTYPE_p_IMP__container__PairContainerSet swig_types[609]
#define SWIGTYPE_p_IMP__container__PairContainerStatistics swig_types[610]
#define SWIGTYPE_p_IMP__container__PairsConstraint swig_types[611]
#define SWIGTYPE_p_IMP__container__PairsOptimizerState swig_types[612]
#define SWIGTYPE_p_IMP__container__PairsRestraint swig_types[613]
#define SWIGTYPE_p_IMP__container__PredicatePairsRestraint swig_types[614]
#define SWIGTYPE_p_IMP__container__PredicateQuadsRestraint swig_types[615]
#define SWIGTYPE_p_IMP__container__PredicateSingletonsRestraint swig_types[616]
#define SWIGTYPE_p_IMP__container__PredicateTripletsRestraint swig_types[617]
#define SWIGTYPE_p_IMP__container__QuadContainerSet swig_types[618]
#define SWIGTYPE_p_IMP__container__QuadContainerStatistics swig_types[619]
#define SWIGTYPE_p_IMP__container__QuadsConstraint swig_types[620]
#define SWIGTYPE_p_IMP__container__QuadsOptimizerState swig_types[621]
#define SWIGTYPE_p_IMP__container__QuadsRestraint swig_types[622]
#define SWIGTYPE_p_IMP__container__SingletonContainerSet swig_types[623]
#define SWIGTYPE_p_IMP__container__SingletonContainerStatistics swig_types[624]
#define SWIGTYPE_p_IMP__container__SingletonsConstraint swig_types[625]
#define SWIGTYPE_p_IMP__container__SingletonsOptimizerState swig_types[626]
#define SWIGTYPE_p_IMP__container__SingletonsRestraint swig_types[627]
#define SWIGTYPE_p_IMP__container__TripletContainerSet swig_types[628]
#define SWIGTYPE_p_IMP__container__TripletContainerStatistics swig_types[629]
#define SWIGTYPE_p_IMP__container__TripletsConstraint swig_types[630]
#define SWIGTYPE_p_IMP__container__TripletsOptimizerState swig_types[631]
#define SWIGTYPE_p_IMP__container__TripletsRestraint swig_types[632]
#define SWIGTYPE_p_IMP__core__AllSamePairPredicate swig_types[633]
#define SWIGTYPE_p_IMP__core__AllSameQuadPredicate swig_types[634]
#define SWIGTYPE_p_IMP__core__AllSameSingletonPredicate swig_types[635]
#define SWIGTYPE_p_IMP__core__AllSameTripletPredicate swig_types[636]
#define SWIGTYPE_p_IMP__core__AngleRestraint swig_types[637]
#define SWIGTYPE_p_IMP__core__AngleTripletScore swig_types[638]
#define SWIGTYPE_p_IMP__core__AttributeSingletonPredicate swig_types[639]
#define SWIGTYPE_p_IMP__core__BallMover swig_types[640]
#define SWIGTYPE_p_IMP__core__BinormalTerm swig_types[641]
#define SWIGTYPE_p_IMP__core__BoxSweepClosePairsFinder swig_types[642]
#define SWIGTYPE_p_IMP__core__Centroid swig_types[643]
#define SWIGTYPE_p_IMP__core__CentroidOfRefined swig_types[644]
#define SWIGTYPE_p_IMP__core__ChecksScoreState swig_types[645]
#define SWIGTYPE_p_IMP__core__ChildrenRefiner swig_types[646]
#define SWIGTYPE_p_IMP__core__ClosePairsFinder swig_types[647]
#define SWIGTYPE_p_IMP__core__ClosePairsPairScore swig_types[648]
#define SWIGTYPE_p_IMP__core__ClosedCubicSpline swig_types[649]
#define SWIGTYPE_p_IMP__core__ClusterProvenance swig_types[650]
#define SWIGTYPE_p_IMP__core__CoinFlipPairPredicate swig_types[651]
#define SWIGTYPE_p_IMP__core__CoinFlipQuadPredicate swig_types[652]
#define SWIGTYPE_p_IMP__core__CoinFlipSingletonPredicate swig_types[653]
#define SWIGTYPE_p_IMP__core__CoinFlipTripletPredicate swig_types[654]
#define SWIGTYPE_p_IMP__core__CombineProvenance swig_types[655]
#define SWIGTYPE_p_IMP__core__ConjugateGradients swig_types[656]
#define SWIGTYPE_p_IMP__core__ConnectivityRestraint swig_types[657]
#define SWIGTYPE_p_IMP__core__ConstantPairPredicate swig_types[658]
#define SWIGTYPE_p_IMP__core__ConstantQuadPredicate swig_types[659]
#define SWIGTYPE_p_IMP__core__ConstantRestraint swig_types[660]
#define SWIGTYPE_p_IMP__core__ConstantSingletonPredicate swig_types[661]
#define SWIGTYPE_p_IMP__core__ConstantTripletPredicate swig_types[662]
#define SWIGTYPE_p_IMP__core__Cosine swig_types[663]
#define SWIGTYPE_p_IMP__core__Cover swig_types[664]
#define SWIGTYPE_p_IMP__core__CoverRefined swig_types[665]
#define SWIGTYPE_p_IMP__core__DerivativesFromRefined swig_types[666]
#define SWIGTYPE_p_IMP__core__DerivativesToRefined swig_types[667]
#define SWIGTYPE_p_IMP__core__DiameterRestraint swig_types[668]
#define SWIGTYPE_p_IMP__core__DihedralRestraint swig_types[669]
#define SWIGTYPE_p_IMP__core__Direction swig_types[670]
#define SWIGTYPE_p_IMP__core__DirectionAngle swig_types[671]
#define SWIGTYPE_p_IMP__core__DirectionMover swig_types[672]
#define SWIGTYPE_p_IMP__core__DistancePairScore swig_types[673]
#define SWIGTYPE_p_IMP__core__DistanceRestraint swig_types[674]
#define SWIGTYPE_p_IMP__core__EdgePairGeometry swig_types[675]
#define SWIGTYPE_p_IMP__core__EdgePairsGeometry swig_types[676]
#define SWIGTYPE_p_IMP__core__ExcludedVolumeRestraint swig_types[677]
#define SWIGTYPE_p_IMP__core__FilterProvenance swig_types[678]
#define SWIGTYPE_p_IMP__core__FixedRefiner swig_types[679]
#define SWIGTYPE_p_IMP__core__Gaussian swig_types[680]
#define SWIGTYPE_p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t swig_types[681]
#define SWIGTYPE_p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t swig_types[682]
#define SWIGTYPE_p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t swig_types[683]
#define SWIGTYPE_p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t swig_types[684]
#define SWIGTYPE_p_IMP__core__GridClosePairsFinder swig_types[685]
#define SWIGTYPE_p_IMP__core__Harmonic swig_types[686]
#define SWIGTYPE_p_IMP__core__HarmonicDistancePairScore swig_types[687]
#define SWIGTYPE_p_IMP__core__HarmonicLowerBound swig_types[688]
#define SWIGTYPE_p_IMP__core__HarmonicSphereDistancePairScore swig_types[689]
#define SWIGTYPE_p_IMP__core__HarmonicSurfaceDepthPairScore swig_types[690]
#define SWIGTYPE_p_IMP__core__HarmonicSurfaceDistancePairScore swig_types[691]
#define SWIGTYPE_p_IMP__core__HarmonicSurfaceHeightPairScore swig_types[692]
#define SWIGTYPE_p_IMP__core__HarmonicUpperBound swig_types[693]
#define SWIGTYPE_p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore swig_types[694]
#define SWIGTYPE_p_IMP__core__HarmonicUpperBoundSphereDistancePairScore swig_types[695]
#define SWIGTYPE_p_IMP__core__HarmonicWell swig_types[696]
#define SWIGTYPE_p_IMP__core__Hierarchy swig_types[697]
#define SWIGTYPE_p_IMP__core__HierarchyCounter swig_types[698]
#define SWIGTYPE_p_IMP__core__HierarchyTraits swig_types[699]
#define SWIGTYPE_p_IMP__core__InBoundingBox3DSingletonPredicate swig_types[700]
#define SWIGTYPE_p_IMP__core__IsCollisionPairPredicate swig_types[701]
#define SWIGTYPE_p_IMP__core__KClosePairsPairScore swig_types[702]
#define SWIGTYPE_p_IMP__core__LateralSurfaceConstraint swig_types[703]
#define SWIGTYPE_p_IMP__core__LeavesRefiner swig_types[704]
#define SWIGTYPE_p_IMP__core__Linear swig_types[705]
#define SWIGTYPE_p_IMP__core__LogNormalMover swig_types[706]
#define SWIGTYPE_p_IMP__core__MCCGSampler swig_types[707]
#define SWIGTYPE_p_IMP__core__MSConnectivityRestraint swig_types[708]
#define SWIGTYPE_p_IMP__core__MinimumRestraint swig_types[709]
#define SWIGTYPE_p_IMP__core__MonteCarlo swig_types[710]
#define SWIGTYPE_p_IMP__core__MonteCarloMover swig_types[711]
#define SWIGTYPE_p_IMP__core__MonteCarloMoverResult swig_types[712]
#define SWIGTYPE_p_IMP__core__MonteCarloWithBasinHopping swig_types[713]
#define SWIGTYPE_p_IMP__core__MonteCarloWithLocalOptimization swig_types[714]
#define SWIGTYPE_p_IMP__core__MoveStatisticsScoreState swig_types[715]
#define SWIGTYPE_p_IMP__core__MultipleBinormalRestraint swig_types[716]
#define SWIGTYPE_p_IMP__core__NearestNeighborsClosePairsFinder swig_types[717]
#define SWIGTYPE_p_IMP__core__NeighborsTable swig_types[718]
#define SWIGTYPE_p_IMP__core__NonRigidMember swig_types[719]
#define SWIGTYPE_p_IMP__core__NormalMover swig_types[720]
#define SWIGTYPE_p_IMP__core__NormalizedSphereDistancePairScore swig_types[721]
#define SWIGTYPE_p_IMP__core__OpenCubicSpline swig_types[722]
#define SWIGTYPE_p_IMP__core__OrderedTypePairPredicate swig_types[723]
#define SWIGTYPE_p_IMP__core__OrderedTypeQuadPredicate swig_types[724]
#define SWIGTYPE_p_IMP__core__OrderedTypeSingletonPredicate swig_types[725]
#define SWIGTYPE_p_IMP__core__OrderedTypeTripletPredicate swig_types[726]
#define SWIGTYPE_p_IMP__core__PairConstraint swig_types[727]
#define SWIGTYPE_p_IMP__core__PairRestraint swig_types[728]
#define SWIGTYPE_p_IMP__core__Provenance swig_types[729]
#define SWIGTYPE_p_IMP__core__Provenanced swig_types[730]
#define SWIGTYPE_p_IMP__core__QuadConstraint swig_types[731]
#define SWIGTYPE_p_IMP__core__QuadRestraint swig_types[732]
#define SWIGTYPE_p_IMP__core__QuadraticClosePairsFinder swig_types[733]
#define SWIGTYPE_p_IMP__core__Reference swig_types[734]
#define SWIGTYPE_p_IMP__core__RefinedPairsPairScore swig_types[735]
#define SWIGTYPE_p_IMP__core__RestraintsScoringFunction swig_types[736]
#define SWIGTYPE_p_IMP__core__RigidBody swig_types[737]
#define SWIGTYPE_p_IMP__core__RigidBodyAnglePairScore swig_types[738]
#define SWIGTYPE_p_IMP__core__RigidBodyDerivativeGeometry swig_types[739]
#define SWIGTYPE_p_IMP__core__RigidBodyDerivativesGeometry swig_types[740]
#define SWIGTYPE_p_IMP__core__RigidBodyDistancePairScore swig_types[741]
#define SWIGTYPE_p_IMP__core__RigidBodyFrameGeometry swig_types[742]
#define SWIGTYPE_p_IMP__core__RigidBodyFramesGeometry swig_types[743]
#define SWIGTYPE_p_IMP__core__RigidBodyHierarchyGeometry swig_types[744]
#define SWIGTYPE_p_IMP__core__RigidBodyMember swig_types[745]
#define SWIGTYPE_p_IMP__core__RigidBodyMover swig_types[746]
#define SWIGTYPE_p_IMP__core__RigidBodyTorque swig_types[747]
#define SWIGTYPE_p_IMP__core__RigidBodyTunneler swig_types[748]
#define SWIGTYPE_p_IMP__core__RigidBodyUmbrella swig_types[749]
#define SWIGTYPE_p_IMP__core__RigidClosePairsFinder swig_types[750]
#define SWIGTYPE_p_IMP__core__RigidMember swig_types[751]
#define SWIGTYPE_p_IMP__core__RigidMembersRefiner swig_types[752]
#define SWIGTYPE_p_IMP__core__SampleProvenance swig_types[753]
#define SWIGTYPE_p_IMP__core__ScriptProvenance swig_types[754]
#define SWIGTYPE_p_IMP__core__SerialMover swig_types[755]
#define SWIGTYPE_p_IMP__core__SingletonConstraint swig_types[756]
#define SWIGTYPE_p_IMP__core__SingletonRestraint swig_types[757]
#define SWIGTYPE_p_IMP__core__SoftSpherePairScore swig_types[758]
#define SWIGTYPE_p_IMP__core__SoftSubSurfacePairScore swig_types[759]
#define SWIGTYPE_p_IMP__core__SoftSuperSurfacePairScore swig_types[760]
#define SWIGTYPE_p_IMP__core__SoftwareProvenance swig_types[761]
#define SWIGTYPE_p_IMP__core__SphereDistancePairScore swig_types[762]
#define SWIGTYPE_p_IMP__core__SphereDistanceToSingletonScore swig_types[763]
#define SWIGTYPE_p_IMP__core__SteepestDescent swig_types[764]
#define SWIGTYPE_p_IMP__core__StructureProvenance swig_types[765]
#define SWIGTYPE_p_IMP__core__SubsetMover swig_types[766]
#define SWIGTYPE_p_IMP__core__Surface swig_types[767]
#define SWIGTYPE_p_IMP__core__SurfaceDepthPairScore swig_types[768]
#define SWIGTYPE_p_IMP__core__SurfaceDistancePairScore swig_types[769]
#define SWIGTYPE_p_IMP__core__SurfaceGeometry swig_types[770]
#define SWIGTYPE_p_IMP__core__SurfaceGeometryConstraint swig_types[771]
#define SWIGTYPE_p_IMP__core__SurfaceHeightPairScore swig_types[772]
#define SWIGTYPE_p_IMP__core__SurfaceMover swig_types[773]
#define SWIGTYPE_p_IMP__core__SurfaceSymmetryConstraint swig_types[774]
#define SWIGTYPE_p_IMP__core__SurfaceTetheredChain swig_types[775]
#define SWIGTYPE_p_IMP__core__TableRefiner swig_types[776]
#define SWIGTYPE_p_IMP__core__Transform swig_types[777]
#define SWIGTYPE_p_IMP__core__TransformationAndReflectionSymmetry swig_types[778]
#define SWIGTYPE_p_IMP__core__TransformationSymmetry swig_types[779]
#define SWIGTYPE_p_IMP__core__TransformationSymmetryMover swig_types[780]
#define SWIGTYPE_p_IMP__core__TransformedDistancePairScore swig_types[781]
#define SWIGTYPE_p_IMP__core__TripletConstraint swig_types[782]
#define SWIGTYPE_p_IMP__core__TripletRestraint swig_types[783]
#define SWIGTYPE_p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_t swig_types[784]
#define SWIGTYPE_p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_t swig_types[785]
#define SWIGTYPE_p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_t swig_types[786]
#define SWIGTYPE_p_IMP__core__Typed swig_types[787]
#define SWIGTYPE_p_IMP__core__TypedPairScore swig_types[788]
#define SWIGTYPE_p_IMP__core__UnorderedTypePairPredicate swig_types[789]
#define SWIGTYPE_p_IMP__core__UnorderedTypeQuadPredicate swig_types[790]
#define SWIGTYPE_p_IMP__core__UnorderedTypeSingletonPredicate swig_types[791]
#define SWIGTYPE_p_IMP__core__UnorderedTypeTripletPredicate swig_types[792]
#define SWIGTYPE_p_IMP__core__VolumeRestraint swig_types[793]
#define SWIGTYPE_p_IMP__core__WeightedDerivativesToRefined swig_types[794]
#define SWIGTYPE_p_IMP__core__WeightedSphereDistancePairScore swig_types[795]
#define SWIGTYPE_p_IMP__core__WeightedSum swig_types[796]
#define SWIGTYPE_p_IMP__core__WeightedSumOfExponential swig_types[797]
#define SWIGTYPE_p_IMP__core__WriteRestraintScoresOptimizerState swig_types[798]
#define SWIGTYPE_p_IMP__core__XYZ swig_types[799]
#define SWIGTYPE_p_IMP__core__XYZDerivativeGeometry swig_types[800]
#define SWIGTYPE_p_IMP__core__XYZDerivativesGeometry swig_types[801]
#define SWIGTYPE_p_IMP__core__XYZR swig_types[802]
#define SWIGTYPE_p_IMP__core__XYZRGeometry swig_types[803]
#define SWIGTYPE_p_IMP__core__XYZRsGeometry swig_types[804]
#define SWIGTYPE_p_IMP__display__BoundingBoxGeometry swig_types[805]
#define SWIGTYPE_p_IMP__display__Color swig_types[806]
#define SWIGTYPE_p_IMP__display__Colored swig_types[807]
#define SWIGTYPE_p_IMP__display__CylinderGeometry swig_types[808]
#define SWIGTYPE_p_IMP__display__EllipsoidGeometry swig_types[809]
#define SWIGTYPE_p_IMP__display__FilterGeometry swig_types[810]
#define SWIGTYPE_p_IMP__display__Geometry swig_types[811]
#define SWIGTYPE_p_IMP__display__GeometrySet swig_types[812]
#define SWIGTYPE_p_IMP__display__IsosurfaceGeometry swig_types[813]
#define SWIGTYPE_p_IMP__display__LabelGeometry swig_types[814]
#define SWIGTYPE_p_IMP__display__PairGeometry swig_types[815]
#define SWIGTYPE_p_IMP__display__PairsGeometry swig_types[816]
#define SWIGTYPE_p_IMP__display__PlaneGeometry swig_types[817]
#define SWIGTYPE_p_IMP__display__PointGeometry swig_types[818]
#define SWIGTYPE_p_IMP__display__PolygonGeometry swig_types[819]
#define SWIGTYPE_p_IMP__display__PymolWriter swig_types[820]
#define SWIGTYPE_p_IMP__display__ReferenceFrameGeometry swig_types[821]
#define SWIGTYPE_p_IMP__display__RestraintGeometry swig_types[822]
#define SWIGTYPE_p_IMP__display__RestraintSetGeometry swig_types[823]
#define SWIGTYPE_p_IMP__display__SegmentGeometry swig_types[824]
#define SWIGTYPE_p_IMP__display__SingletonGeometry swig_types[825]
#define SWIGTYPE_p_IMP__display__SingletonsGeometry swig_types[826]
#define SWIGTYPE_p_IMP__display__SkinSurfaceGeometry swig_types[827]
#define SWIGTYPE_p_IMP__display__SphereGeometry swig_types[828]
#define SWIGTYPE_p_IMP__display__SurfaceMeshGeometry swig_types[829]
#define SWIGTYPE_p_IMP__display__TextWriter swig_types[830]
#define SWIGTYPE_p_IMP__display__TriangleGeometry swig_types[831]
#define SWIGTYPE_p_IMP__display__WriteOptimizerState swig_types[832]
#define SWIGTYPE_p_IMP__display__Writer swig_types[833]
#define SWIGTYPE_p_IMP__display__WriterAdaptor swig_types[834]
#define SWIGTYPE_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState swig_types[835]
#define SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator swig_types[836]
#define SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator swig_types[837]
#define SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState swig_types[838]
#define SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator swig_types[839]
#define SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore swig_types[840]
#define SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator swig_types[841]
#define SWIGTYPE_p_IMP__insulinsecretion__VesicleDockingOptimizerState swig_types[842]
#define SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore swig_types[843]
#define SWIGTYPE_p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_t swig_types[844]
#define SWIGTYPE_p_IMP__internal___ConstOptimizer swig_types[845]
#define SWIGTYPE_p_IMP__internal___ConstPairScore swig_types[846]
#define SWIGTYPE_p_IMP__internal___ConstRestraint swig_types[847]
#define SWIGTYPE_p_IMP__internal___ConstSingletonScore swig_types[848]
#define SWIGTYPE_p_IMP__internal___LogPairScore swig_types[849]
#define SWIGTYPE_p_IMP__internal___Protection swig_types[850]
#define SWIGTYPE_p_IMP__internal___TestObject swig_types[851]
#define SWIGTYPE_p_IMP__internal___TestValue swig_types[852]
#define SWIGTYPE_p_IMP__internal___TrivialDecorator swig_types[853]
#define SWIGTYPE_p_IMP__internal___TrivialDerivedDecorator swig_types[854]
#define SWIGTYPE_p_IMP__internal___TrivialTraitsDecorator swig_types[855]
#define SWIGTYPE_p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__HarmonicLowerBound_t swig_types[856]
#define SWIGTYPE_p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t swig_types[857]
#define SWIGTYPE_p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t swig_types[858]
#define SWIGTYPE_p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_t swig_types[859]
#define SWIGTYPE_p_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t swig_types[860]
#define SWIGTYPE_p_IMP__score_functor__SphereDistanceT_IMP__score_functor__HarmonicLowerBound_t swig_types[861]
#define SWIGTYPE_p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__HarmonicUpperBound_t_t swig_types[862]
#define SWIGTYPE_p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t swig_types[863]
#define SWIGTYPE_p_IMP__score_functor__SphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t swig_types[864]
#define SWIGTYPE_p_Index swig_types[865]
#define SWIGTYPE_p_IndexArgument swig_types[866]
#define SWIGTYPE_p_Modifier swig_types[867]
#define SWIGTYPE_p_P swig_types[868]
#define SWIGTYPE_p_ParentDecorator swig_types[869]
#define SWIGTYPE_p_PassContainedIndexType swig_types[870]
#define SWIGTYPE_p_PassIndexArgument swig_types[871]
#define SWIGTYPE_p_ScoreIsGoodPair swig_types[872]
#define SWIGTYPE_p_VertexDescriptor swig_types[873]
#define SWIGTYPE_p_VertexDescriptors swig_types[874]
#define SWIGTYPE_p_VertexName swig_types[875]
#define SWIGTYPE_p_char swig_types[876]
#define SWIGTYPE_p_double swig_types[877]
#define SWIGTYPE_p_first_type swig_types[878]
#define SWIGTYPE_p_float swig_types[879]
#define SWIGTYPE_p_int swig_types[880]
#define SWIGTYPE_p_second_type swig_types[881]
#define SWIGTYPE_p_size_t swig_types[882]
#define SWIGTYPE_p_std__invalid_argument swig_types[883]
#define SWIGTYPE_p_std__ostream swig_types[884]
#define SWIGTYPE_p_std__pairT_IMP__algebra__VectorDT_3_t_IMP__algebra__VectorDT_4_t_t swig_types[885]
#define SWIGTYPE_p_std__pairT_IMP__algebra__VectorDT_3_t_double_t swig_types[886]
#define SWIGTYPE_p_std__pairT_IMP__algebra__VectorDT_3_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t swig_types[887]
#define SWIGTYPE_p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t swig_types[888]
#define SWIGTYPE_p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_4_t_t swig_types[889]
#define SWIGTYPE_p_std__pairT_double_double_t swig_types[890]
#define SWIGTYPE_p_std__pairT_int_int_t swig_types[891]
#define SWIGTYPE_p_std__pairT_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t swig_types[892]
#define SWIGTYPE_p_std__string swig_types[893]
#define SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator swig_types[894]
#define SWIGTYPE_p_unsigned_int swig_types[895]
static swig_type_info *swig_types[897];
static swig_module_info swig_module = {swig_types, 896, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#ifdef SWIG_TypeQuery
# undef SWIG_TypeQuery
#endif
#define SWIG_TypeQuery SWIG_Python_TypeQuery

/*-----------------------------------------------
              @(target):= _IMP_insulinsecretion.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__IMP_insulinsecretion

#else
#  define SWIG_init    init_IMP_insulinsecretion

#endif
#define SWIG_name    "_IMP_insulinsecretion"

#ifdef __cplusplus
#include <utility>
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigSmartPointer {
    T *ptr;
    SwigSmartPointer(T *p) : ptr(p) { }
    ~SwigSmartPointer() { delete ptr; }
    SwigSmartPointer& operator=(SwigSmartPointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
    void reset(T *p) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = p; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigSmartPointer tmp(new T(t)); pointer = tmp; return *this; }
#if __cplusplus >=201103L
  SwigValueWrapper& operator=(T&& t) { SwigSmartPointer tmp(new T(std::move(t))); pointer = tmp; return *this; }
  operator T&&() const { return std::move(*pointer.ptr); }
#else
  operator T&() const { return *pointer.ptr; }
#endif
  T *operator&() const { return pointer.ptr; }
  static void reset(SwigValueWrapper& t, T *p) { t.pointer.reset(p); }
};

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
template <typename T> T SwigValueInit() {
  return T();
}

#if __cplusplus >=201103L
# define SWIG_STD_MOVE(OBJ) std::move(OBJ)
#else
# define SWIG_STD_MOVE(OBJ) OBJ
#endif

#endif


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(_obj);      
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_XINCREF(_obj);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      SWIG_PYTHON_THREAD_END_BLOCK;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XDECREF(_obj);
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}


namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}


#include <boost/version.hpp>
#include <boost/exception/all.hpp>

#include <boost/type_traits/is_convertible.hpp>
#include <boost/utility/enable_if.hpp>
#include <exception>
// for serialization/pickle support
#include <cereal/archives/binary.hpp>

#ifdef __cplusplus
extern "C"
#endif

// suppress warning
SWIGEXPORT
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init();


#include "IMP.h"
#include "IMP/kernel_config.h"


#include <IMP/internal/swig.h>


#include <IMP/internal/swig_base.h>


#include <IMP/internal/swig_helpers.h>


#include <IMP/internal/swig_helpers_base.h>


#include "IMP/cgal.h"
#include "IMP/cgal/cgal_config.h"


#include "IMP/algebra.h"
#include "IMP/algebra/algebra_config.h"


#include <IMP/algebra/internal/swig.h>


#include "IMP/display.h"
#include "IMP/display/display_config.h"


#include "IMP/score_functor.h"
#include "IMP/score_functor/score_functor_config.h"


#include "IMP/core.h"
#include "IMP/core/core_config.h"


#include "IMP/container.h"
#include "IMP/container/container_config.h"


#include "IMP/insulinsecretion.h"
#include "IMP/insulinsecretion/insulinsecretion_config.h"


#include <iostream>

#if PY_VERSION_HEX >= 0x03020000
# define SWIGPY_SLICEOBJECT PyObject
#else
# define SWIGPY_SLICEOBJECT PySliceObject
#endif


#include <typeinfo>
#include <stdexcept>


#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <string>


#include <stddef.h>


namespace swig {
  struct stop_iteration {
  };

  struct IMP_INSULINSECRETION_SwigPyIterator {
  private:
    SwigPtr_PyObject _seq;

  protected:
    IMP_INSULINSECRETION_SwigPyIterator(PyObject *seq) : _seq(seq)
    {
    }
      
  public:
    virtual ~IMP_INSULINSECRETION_SwigPyIterator() {}

    // Access iterator method, required by Python
    virtual PyObject *value() const = 0;

    // Forward iterator method, required by Python
    virtual IMP_INSULINSECRETION_SwigPyIterator *incr(size_t n = 1) = 0;
    
    // Backward iterator method, very common in C++, but not required in Python
    virtual IMP_INSULINSECRETION_SwigPyIterator *decr(size_t /*n*/ = 1)
    {
      throw stop_iteration();
    }

    // Random access iterator methods, but not required in Python
    virtual ptrdiff_t distance(const IMP_INSULINSECRETION_SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }

    virtual bool equal (const IMP_INSULINSECRETION_SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }
    
    // C++ common/needed methods
    virtual IMP_INSULINSECRETION_SwigPyIterator *copy() const = 0;

    PyObject *next()     
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      PyObject *obj = value();
      incr();       
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads
      return obj;     
    }

    /* Make an alias for Python 3.x */
    PyObject *__next__()
    {
      return next();
    }

    PyObject *previous()
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      decr();
      PyObject *obj = value();
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads       
      return obj;
    }

    IMP_INSULINSECRETION_SwigPyIterator *advance(ptrdiff_t n)
    {
      return  (n > 0) ?  incr(n) : decr(-n);
    }
      
    bool operator == (const IMP_INSULINSECRETION_SwigPyIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const IMP_INSULINSECRETION_SwigPyIterator& x) const
    {
      return ! operator==(x);
    }
      
    IMP_INSULINSECRETION_SwigPyIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    IMP_INSULINSECRETION_SwigPyIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    IMP_INSULINSECRETION_SwigPyIterator* operator + (ptrdiff_t n) const
    {
      return copy()->advance(n);
    }

    IMP_INSULINSECRETION_SwigPyIterator* operator - (ptrdiff_t n) const
    {
      return copy()->advance(-n);
    }
      
    ptrdiff_t operator - (const IMP_INSULINSECRETION_SwigPyIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::SwigPyIterator *");
	init = 1;
      }	
      return desc;
    }    
  };

#if defined(SWIGPYTHON_BUILTIN)
  inline PyObject* make_output_iterator_builtin (PyObject *pyself)
  {
    Py_INCREF(pyself);
    return pyself;
  }
#endif
}


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else
#endif
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, 0, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
      if (val) *val = (unsigned long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  }
#endif
  return res;
}


  #define SWIG_From_long   PyInt_FromLong 


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_long_SS_long  (long long value)
{
  return ((value < LONG_MIN) || (value > LONG_MAX)) ?
    PyLong_FromLongLong(value) : PyInt_FromLong(static_cast< long >(value));
}
#endif


SWIGINTERNINLINE PyObject *
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    return SWIG_From_long  (static_cast< long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(ptrdiff_t) <= sizeof(long long) */
    return SWIG_From_long_SS_long  (static_cast< long long >(value));
  }
#endif
}


SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_long_SS_long (PyObject *obj, long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    long long v = PyLong_AsLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    long v;
    res = SWIG_AsVal_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    const double mant_min = -mant_max;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, mant_min, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, mant_min, mant_max)) {
      if (val) *val = (long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    long v;
    res = SWIG_AsVal_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(ptrdiff_t) <= sizeof(long long)) {
    long long v;
    res = SWIG_AsVal_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  }
#endif
  return res;
}


#include <algorithm>


#include <vector>


#include <utility>


SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}


IMP_CLANG_PRAGMA(diagnostic ignored "-Wdeprecated")
IMP_CLANG_PRAGMA(diagnostic ignored "-Wdeprecated-declarations")
IMP_CLANG_PRAGMA(diagnostic ignored "-Wunused-function")

IMP_GCC_PRAGMA(diagnostic ignored "-Wstrict-aliasing")
IMP_GCC_PRAGMA(diagnostic ignored "-Wdeprecated-declarations")
IMP_GCC_PRAGMA(diagnostic ignored "-Wsign-compare")
IMP_GCC_PRAGMA(diagnostic ignored "-Wunused-label")
IMP_GCC_PRAGMA(diagnostic ignored "-Wunused-but-set-variable")

/* SWIG generates long class names with wrappers that use certain Boost classes,
   longer than the 255 character name length for MSVC. This shouldn't affect
   the code, but does result in a lot of warning output, so disable this warning
   for clarity. */
IMP_VC_PRAGMA(warning( disable: 4503 ))



  // make sure this is early enough
#include <IMP/exception.h>


static PyObject *imp_exception, *imp_internal_exception, *imp_model_exception,
                *imp_usage_exception, *imp_index_exception, *imp_io_exception,
    *imp_value_exception, *imp_event_exception, *imp_type_exception;


#include <boost/version.hpp>
#if !defined(BOOST_FILESYSTEM_VERSION)
#define BOOST_FILESYSTEM_VERSION 3
#include <boost/filesystem.hpp>
#endif

  /* Code to convert C++ exceptions into scripting language errors. Saves
     having lots of catch statements in every single wrapper. */
  static void handle_imp_exception(void)
  {
    try {
      throw;
    /* Map std:: exceptions to IMP equivalents */
    } catch (const std::out_of_range &e) {
      PyErr_SetString(imp_index_exception, e.what());
    } catch (const std::domain_error &e) {
      PyErr_SetString(imp_value_exception, e.what());
    } catch (const std::ios::failure &e) {
      PyErr_SetString(imp_io_exception, e.what());
    } catch (const std::length_error &e) {
      /* Internal error, such as attempt to resize a vector beyond max size */
      PyErr_SetString(imp_internal_exception, e.what());
    /* Map IMP exceptions to Python objects */
    } catch (const IMP::IndexException &e) {
      PyErr_SetString(imp_index_exception, e.what());
    } catch (const IMP::ValueException &e) {
      PyErr_SetString(imp_value_exception, e.what());
    } catch (const IMP::InternalException &e) {
      PyErr_SetString(imp_internal_exception, e.what());
    } catch (const IMP::TypeException &e) {
      PyErr_SetString(imp_type_exception, e.what());
    } catch (const IMP::ModelException &e) {
      PyErr_SetString(imp_model_exception, e.what());
    } catch (const IMP::UsageException &e) {
      PyErr_SetString(imp_usage_exception, e.what());
    } catch (const IMP::IOException &e) {
      PyErr_SetString(imp_io_exception, e.what());
    } catch (const IMP::EventException &e) {
      PyErr_SetString(imp_event_exception, e.what());
    } catch (const IMP::Exception &e) {
      PyErr_SetString(imp_exception, e.what());
    /* Map Boost exceptions to Python exceptions */
    } catch (boost::filesystem::filesystem_error &e) {
      PyErr_SetString(imp_io_exception, e.what());
    /* Catch memory allocation errors, if raised */
    } catch (const std::bad_alloc &e) {
      PyErr_SetString(PyExc_MemoryError, e.what());
    /* Catch any other exceptions raised */
    } catch (const std::exception &e) {
      PyErr_SetString(PyExc_RuntimeError,
                      e.what());
    } catch (const boost::exception &e) {
      PyErr_SetString(PyExc_RuntimeError,
                      boost::diagnostic_information(e).c_str());
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Unknown error caught by Python wrapper");
    }
  /* SWIG_exception contains "goto fail" so make sure the label is defined */
  fail:
    return;
  }


// Silence warnings about old NumPy API
#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include <numpy/arrayobject.h>


#include <IMP/Object.h>
#include <IMP/Pointer.h>


// Adapter class that acts like an output std::streambuf but delegates to
// a Python file-like object, p
  class PyOutFileAdapter : public IMP::Object
{

  std::unique_ptr<std::ostream> ostr_;

  struct StreamBuf:public std::streambuf {
    PyObject *write_method_;
    std::vector<char> buffer_;
    char fmat_[5];
    StreamBuf(PyObject *wm): write_method_(wm),
                             buffer_(1024){
      strcpy(fmat_, "(s#)");
      setp(&buffer_.front(), &buffer_.front() + buffer_.size());
      // to make errors occur earlier
      PyObject *result = PyObject_CallFunction(write_method_, fmat_, fmat_,
#if PY_VERSION_HEX >= 0x02050000 && defined(PY_SSIZE_T_CLEAN)
                          (Py_ssize_t)0);
#else
                          (int)0);
#endif
      if (!result) {
#if PY_VERSION_HEX >= 0x03000000
        PyErr_Clear();
        // Failed to write string (Unicode); try bytes instead
        fmat_[1] = 'y';
        result = PyObject_CallFunction(write_method_, fmat_, fmat_,
#if PY_VERSION_HEX >= 0x02050000 && defined(PY_SSIZE_T_CLEAN)
                          (Py_ssize_t)0);
#else
                          (int)0);
#endif
        if (!result) {
          throw std::ostream::failure("Python error on write");
        } else {
          Py_DECREF(result);
        }
#else
        // Python exception will be reraised when SWIG method finishes
        throw std::ostream::failure("Python error on write");
#endif
      } else {
        Py_DECREF(result);
      }
    }
  protected:
    virtual int_type overflow(int_type c) {
      if (c != EOF) {
        sync();
        *pptr() = c;
        pbump(1);
      }
      return c;
    }

    virtual int_type sync() {
      // Python API uses char* arguments rather than const char*, so create
      // here to quell the compiler warning
      int num = pptr() - pbase();
      if (num <= 0) {
        return 0;
      }
      PyObject *result = PyObject_CallFunction(write_method_, fmat_, pbase(),
#if PY_VERSION_HEX >= 0x02050000 && defined(PY_SSIZE_T_CLEAN)
                                               (Py_ssize_t)num);
#else
                                               (int)num);
#endif
      if (!result) {
        // Python exception will be reraised when SWIG method finishes
        throw std::ostream::failure("Python error on write");
      } else {
        pbump(-num);
        Py_DECREF(result);
        return 0;
      }
    }

    virtual std::streamsize xsputn(const char *s, std::streamsize n) {
      if (static_cast<std::size_t>(n) > buffer_.size() * 2) {
        // Only take this route for large buffers, since two Python calls will
        // result per call (one here, potentially one in sync) rather than one per
        // buffer_.size() characters via the regular buffering
        sync();
        PyObject *result = PyObject_CallFunction(write_method_, fmat_, s,
#if PY_VERSION_HEX >= 0x02050000 && defined(PY_SSIZE_T_CLEAN)
                                                 (Py_ssize_t)n);
#else
                                                 (int)n);
#endif
        if (!result) {
          throw std::ostream::failure("Python error on write");
        } else {
          Py_DECREF(result);
        }
        return n;
      } else {
        // Use the regular buffering mechanism
        for (std::streamsize i = 0; i < n; ++i) {
          if (sputc(s[i]) == EOF) {
            return i;
          }
        }
      return n;
      }
    }
  public:
    virtual ~StreamBuf() {
      Py_XDECREF(write_method_);
    }
  };
  std::unique_ptr<StreamBuf> stream_buf_;
public:
 PyOutFileAdapter():IMP::Object("PyOutFileAdapter") {
  }
  std::string get_type_name() const {return "Python output file";}
  IMP::VersionInfo get_version_info() const {
    return IMP::VersionInfo("IMP", IMP::get_module_version());
  }
  void pubsync() {
    stream_buf_->pubsync();
  }
  // Given a Python file object, return an ostream that will write to this
  // object, or NULL if the object is not suitable.
  std::ostream* set_python_file(PyObject *p) {
    PyObject *wm=PyObject_GetAttrString(p, "write");
    if (!wm) {
      return NULL;
    }
    stream_buf_= std::unique_ptr<StreamBuf>(new StreamBuf(wm));

    IMP_INTERNAL_CHECK(!ostr_.get(), "Already set the stream.");
    ostr_ = std::unique_ptr<std::ostream>(new std::ostream(stream_buf_.get()));
    ostr_->exceptions(std::ostream::badbit);
    return ostr_.get();
    fail:
    return NULL;
  }


 private:
  virtual ~PyOutFileAdapter() {
    try {
      if (stream_buf_.get()) pubsync();
    } catch (...) {
      // at this point we have no choice but to eat it
    }
  }
};

// Base for input adapters
class InAdapter : public std::streambuf
{
};

// Adapter class that acts like an input std::streambuf but delegates to
// C-style stdio via a FILE pointer
class PyInCFileAdapter : public InAdapter
{
  FILE *fh_;
public:
  PyInCFileAdapter(FILE *fh) : fh_(fh) {}
  virtual ~PyInCFileAdapter(){
  }
protected:
  virtual int_type uflow() {
    return getc(fh_);
  }

  virtual int_type underflow() {
    int c = getc(fh_);
    if (c != EOF) {
      ungetc(c, fh_);
    }
    return c;
  }

  virtual std::streamsize xsgetn(char *s, std::streamsize n) {
    return fread(s, 1, n, fh_);
  }

  virtual int_type pbackfail(int c) {
    return c == EOF ? EOF : ungetc(c, fh_);
  }

  virtual int_type sync() {
    return fflush(fh_);
  }
};

// Adapter class that acts like an input std::streambuf but delegates to
// a Python file-like object
class PyInFilelikeAdapter : public InAdapter
{
  PyObject *read_method_;
  // Last character peeked from the stream by underflow(), or -1
  int peeked_;
public:
  PyInFilelikeAdapter(PyObject *read_method)
    :  read_method_(read_method), peeked_(-1) {}
  virtual ~PyInFilelikeAdapter() {
    Py_DECREF(read_method_);
    if (peeked_ != -1) {
      IMP_WARN("One excess character read from Python stream - "
               "cannot be put back." << std::endl)
    }
  }
protected:
  virtual int_type uflow() {
    int c;
    c = (peeked_ == -1 ? underflow() : peeked_);
    peeked_ = -1;
    return c;
  }

  virtual int_type underflow() {
    static char fmt[] = "(i)";
    if (peeked_!= -1) return peeked_;
    PyObject *result = PyObject_CallFunction(read_method_, fmt,
#if PY_VERSION_HEX >= 0x02050000 && defined(PY_SSIZE_T_CLEAN)
                                             (Py_ssize_t)1);
#else
                                             (int)1);
#endif
    if (!result) {
      // Python exception will be reraised when SWIG method finishes
      throw std::ostream::failure("Python error on read");
    } else {
      if (PyString_Check(result)) {
        if (PyString_Size(result) == 1) {
          int c = peeked_ = PyString_AsString(result)[0];
          Py_DECREF(result);
          return c;
        } else {
          Py_DECREF(result);
          return EOF;
        }
      } else {
        Py_DECREF(result);
        PyErr_SetString(PyExc_TypeError, "Python file-like object read method "
                        "should return a string");
        throw std::ostream::failure("Python error on read");
      }
    }
  }

  virtual std::streamsize xsgetn(char *s, std::streamsize n) {
    static char fmt[] = "(i)";
    PyObject *result = PyObject_CallFunction(read_method_, fmt,
#if PY_VERSION_HEX >= 0x02050000 && defined(PY_SSIZE_T_CLEAN)
                                             (Py_ssize_t)n);
#else
                                             (int)n);
#endif
    if (!result) {
      throw std::ostream::failure("Python error on read");
    } else {
      if (PyString_Check(result)) {
        int len = PyString_Size(result);
        char *str = PyString_AsString(result);
        if (len > n) {
          Py_DECREF(result);
          PyErr_SetString(PyExc_IOError, "Python file-like object read method "
                          "returned data longer than the input buffer");
          throw std::ostream::failure("Python error on read");
        } else {
          memcpy(s, str, len);
          Py_DECREF(result);
          return len;
        }
      } else {
        Py_DECREF(result);
        PyErr_SetString(PyExc_TypeError, "Python file-like object read method "
                        "should return a string");
        throw std::ostream::failure("Python error on read");
      }
    }
  }
};

// Adapter class that delegates C++ stream input to a Python object.

// It is rather expensive to call the Python 'read' method for every character
// (and we cannot read multiple bytes from the Python file, since there is no
// way to put them back if we read too many; even if the stream is seekable
// there is no guarantee we can restore the file position unless it is opened
// in binary mode). Thus, we try to use the underlying FILE pointer (only
// available for real files, not for file-like objects) if possible. This may
// fail on Windows where different C runtimes can make FILE pointers unusable:
// http://www.python.org/doc/faq/windows/#pyrun-simplefile-crashes-on-windows-but-not-on-unix-why

// Note that this is still not optimal, since the streambuf is not buffered;
// uflow() or underflow() virtual methods will be called for each character
// (unless xsgetn can be used). This could be alleviated (at the expense of
// making the classes rather more complex) by buffering if the underlying file
// is seekable:
//   populate_buffer() {
//     pos_ = (fgetpos() or Python tell());
//     fill buffer with fread(buffer_size) or Python read(buffer_size);
//   }
//   sync() {
//     fsetpos(pos_) or Python seek(pos_);
//     chars_consumed = gptr() - eback();
//     read and discard char array with
//                      fread(chars_consumed) or Python read(chars_consumed);
//     empty buffer;
//   }
//   uflow() and underflow() call populate_buffer(); sync ensures that future
//   reads from the underlying file will reread characters currently between
//   gptr() and egptr(). Note that we cannot simply do
//   fseek(fh, gptr() - egptr(), SEEK_CUR) in sync since this doesn't work with
//   text files on Windows, or with Python file-like objects, where the only
//   inputs to seek() that have defined behavior are offsets previously
//   returned by tell().

   class PyInFileAdapter: public IMP::Object
{
  virtual ~PyInFileAdapter(){
  }
  std::unique_ptr<InAdapter> streambuf_;
  std::unique_ptr<std::istream> istr_;
public:
 PyInFileAdapter(): IMP::Object("PyInFileAdapter") {}
  std::string get_type_name() const {return "Python input file";}
  IMP::VersionInfo get_version_info() const {
    return IMP::VersionInfo("IMP", IMP::get_module_version());
  }
  // Given a Python file object, return an istream that will read from this
  // object, or NULL if the object is not suitable.
  std::istream* set_python_file(PyObject *p) {
    // Is the object a 'real' C-style FILE ?
    bool real_file;
    /* Cannot reliably detect a "real" file pointer on Windows
       (differing C runtimes) so always use a file-like approach here;
       in Python 3 all files are only file-like */
#if PY_VERSION_HEX >= 0x03000000 || defined(_MSC_VER)
    real_file = false;
#else
    try {
      real_file = (PyFile_Check(p) && ftell(PyFile_AsFile(p)) != -1);
    } catch(...) {
      real_file = false;
    }
#endif

#if PY_VERSION_HEX < 0x03000000
    if (real_file) {
      streambuf_ = std::unique_ptr<InAdapter>(new PyInCFileAdapter(PyFile_AsFile(p)));
    } else 
#endif
    {
      PyObject *read_method;
      if (!(read_method = PyObject_GetAttrString(p, "read"))) {
        return NULL;
      }
      streambuf_ = std::unique_ptr<InAdapter>(new PyInFilelikeAdapter(read_method));
    }
    IMP_INTERNAL_CHECK(!istr_.get(), "Already set the stream.");
    istr_ = std::unique_ptr<std::istream>(new std::istream(streambuf_.get()));
    istr_->exceptions(std::istream::badbit);
    return istr_.get();
  }
};


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
  if (PyBytes_Check(obj))
#else
  if (PyUnicode_Check(obj))
#endif
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
    int ret = SWIG_OK;
#if PY_VERSION_HEX>=0x03000000
#if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    if (!obj)
      return SWIG_TypeError;
    if (alloc)
      *alloc = SWIG_NEWOBJ;
#endif
    if (PyBytes_AsStringAndSize(obj, &cstr, &len) == -1)
      return SWIG_TypeError;
#else
    if (PyString_AsStringAndSize(obj, &cstr, &len) == -1)
      return SWIG_TypeError;
#endif
    if (cptr) {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = reinterpret_cast< char* >(memcpy(new char[len + 1], cstr, sizeof(char)*(len + 1)));
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
	*cptr = PyBytes_AsString(obj);
#else
	assert(0); /* Should never reach here with Unicode strings in Python 3 */
#endif
#else
	*cptr = SWIG_Python_str_AsChar(obj);
        if (!*cptr)
          ret = SWIG_TypeError;
#endif
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    Py_XDECREF(obj);
#endif
    return ret;
  } else {
#if defined(SWIG_PYTHON_2_UNICODE)
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
#error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
#endif
#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (!obj)
        return SWIG_TypeError;
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = reinterpret_cast< char* >(memcpy(new char[len + 1], cstr, sizeof(char)*(len + 1)));
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
#endif
#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}





SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


#define IMP_SWIG_CPP_WARNING(string) IMP_WARN_PREPROCESS(string)
  

template <class M>
struct ConvertEigenMatrix {
  static std::pair<int, int> get_dimensions(PyObject* o) {
    int outer = PySequence_Length(o);
    PyReceivePointer inner(PySequence_GetItem(o, 0));
    return std::make_pair(outer, PySequence_Length(inner));
  }

  template <class SwigData>
  static M get_cpp_object(PyObject* o, SwigData st) {
    if (!get_is_cpp_object(o, st)) {
      IMP_THROW("Argument not of correct type", ValueException);
    }
    std::pair<int,int> dim= get_dimensions(o);
    M ret(dim.first, dim.second);
    for (unsigned int i = 0; i < dim.first; ++i) {
      PyReceivePointer inner(PySequence_GetItem(o, i));
      for (unsigned int j = 0; j < dim.second; ++j) {
        PyReceivePointer item(PySequence_GetItem(inner, j));
        ret(i, j) = PyFloat_AsDouble(item);
      }
    }
    return ret;
  }
  template <class SwigData>
  static bool get_is_cpp_object(PyObject* in, SwigData st) {
    if (!in || !PySequence_Check(in)) {
      return false;
    }
    int inner = -1;
    for (unsigned int i = 0; i < PySequence_Length(in); ++i) {
      PyReceivePointer o(PySequence_GetItem(in, i));
      if (!o || !PySequence_Check(o)) {
        return false;
      }
      if (inner == -1) {
        inner = PySequence_Length(o);
      } else {
        if (PySequence_Length(o) != inner) return false;
      }
    }
    return true;
  }
  template <class SwigData>
  static PyObject* create_python_object(const M& t, SwigData st, int OWN) {
#if IMP_KERNEL_HAS_NUMPY
    // We are called for both float and double. Map to equivalent NumPy
    // types by checking the size of the type (a little ugly)
    BOOST_STATIC_ASSERT(sizeof(typename M::Scalar) == sizeof(double) ||
                        sizeof(typename M::Scalar) == sizeof(float));
    if (numpy_import_retval == 0) {
      npy_intp dims[2];
      dims[0] = t.rows();
      dims[1] = t.cols();
      int typenum = sizeof(typename M::Scalar) == sizeof(double)
                    ? NPY_DOUBLE : NPY_FLOAT;
      // Eigen matrices are column major by default; numpy is row major
      // by default, so force column major (Fortran-contiguous style)
      PyReceivePointer ret(PyArray_NewFromDescr(
             &PyArray_Type, PyArray_DescrFromType(typenum), 2, dims,
             NULL, NULL, NPY_ARRAY_F_CONTIGUOUS, NULL));
      if (t.rows()*t.cols() > 0) {
        PyObject *obj = ret;
        memcpy(PyArray_DATA((PyArrayObject *)obj), t.data(),
               t.rows() * t.cols() * sizeof(typename M::Scalar));
      }
      return ret.release();
    } else {
#endif
    PyReceivePointer ret(PyList_New(t.rows()));
    for (unsigned int i = 0; i < t.rows(); ++i) {
      PyReceivePointer inner(PyList_New(t.cols()));
      for (unsigned int j = 0; j < t.cols(); ++j) {
        PyReceivePointer o(PyFloat_FromDouble(t(i,j)));
        // this does not increment the ref count
        IMP_PYTHON_CALL(PyList_SetItem(inner, j, o.release()));
      }
      IMP_PYTHON_CALL(PyList_SetItem(ret, i, inner.release()));
    }
    return ret.release();
#if IMP_KERNEL_HAS_NUMPY
    }
#endif

  }
};

template <class M>
struct ConvertEigenVector {
  static int get_dimension(PyObject* o) {
    return PySequence_Length(o);
  }

  template <class SwigData>
  static M get_cpp_object(PyObject* o, SwigData st) {
    if (!get_is_cpp_object(o, st)) {
      IMP_THROW("Argument not of correct type", ValueException);
    }
    int dim= get_dimension(o);
    M ret(dim);
    for (unsigned int i = 0; i < dim; ++i) {
      PyReceivePointer item(PySequence_GetItem(o, i));
      ret(i) = PyFloat_AsDouble(item);
    }
    return ret;
  }
  template <class SwigData>
  static bool get_is_cpp_object(PyObject* in, SwigData st) {
    if (!in || !PySequence_Check(in)) {
      return false;
    }
    for (unsigned int i = 0; i < PySequence_Length(in); ++i) {
      PyReceivePointer o(PySequence_GetItem(in, i));
      if (!o) {
        return false;
      }
    }
    return true;
  }
  template <class SwigData>
  static PyObject* create_python_object(const M& t, SwigData st, int OWN) {
#if IMP_KERNEL_HAS_NUMPY
    // We are called for both float and double. Map to equivalent NumPy
    // types by checking the size of the type (a little ugly)
    BOOST_STATIC_ASSERT(sizeof(typename M::Scalar) == sizeof(double) ||
                        sizeof(typename M::Scalar) == sizeof(float));
    if (numpy_import_retval == 0) {
      npy_intp dims[2];
      dims[0] = t.rows();
      PyReceivePointer ret(PyArray_SimpleNew(1, dims,
                   sizeof(typename M::Scalar) == sizeof(double)
                   ? NPY_DOUBLE : NPY_FLOAT));
      if (t.rows() > 0) {
        PyObject *obj = ret;
        memcpy(PyArray_DATA((PyArrayObject *)obj), t.data(),
               t.rows() * sizeof(typename M::Scalar));
      }
      return ret.release();
    } else {
#endif
    PyReceivePointer ret(PyList_New(t.rows()));
    for (unsigned int i = 0; i < t.rows(); ++i) {
      PyReceivePointer o(PyFloat_FromDouble(t(i)));
      // this does not increment the ref count
      IMP_PYTHON_CALL(PyList_SetItem(ret, i, o.release()));
    }
    return ret.release();
#if IMP_KERNEL_HAS_NUMPY
    }
#endif
  }
};

  

  BOOST_STATIC_ASSERT(Convert< IMP::insulinsecretion::SecretionCounterDecorator >::converter==3);


  BOOST_STATIC_ASSERT(Convert< IMP::insulinsecretion::MaturationStateDecorator >::converter==3);


  BOOST_STATIC_ASSERT(Convert< IMP::insulinsecretion::DockingStateDecorator >::converter==3);


  BOOST_STATIC_ASSERT(Convert< IMP::insulinsecretion::CaChannelStateDecorator >::converter==3);


  #define SWIG_From_double   PyFloat_FromDouble 

SWIGINTERN std::string IMP_insulinsecretion_VesicleTraffickingSingletonScore___str__(IMP::insulinsecretion::VesicleTraffickingSingletonScore const *self){
    std::ostringstream oss;
    oss << '"' << self->get_name() << '"';
    return oss.str();
  }

SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
      return PyBytes_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#else
      return PyUnicode_DecodeUTF8(carray, static_cast< Py_ssize_t >(size), "surrogateescape");
#endif
#else
      return PyString_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject *
SWIG_From_std_string  (const std::string& s)
{
  return SWIG_FromCharPtrAndSize(s.data(), s.size());
}

SWIGINTERN std::string IMP_insulinsecretion_VesicleTraffickingSingletonScore___repr__(IMP::insulinsecretion::VesicleTraffickingSingletonScore const *self){
    std::ostringstream oss;
    oss << '"' << self->get_name() << '"';
    return oss.str();
  }

SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}

SWIGINTERN std::string IMP_insulinsecretion_InsulinSecretionOptimizerState___str__(IMP::insulinsecretion::InsulinSecretionOptimizerState const *self){
    std::ostringstream oss;
    oss << '"' << self->get_name() << '"';
    return oss.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_InsulinSecretionOptimizerState___repr__(IMP::insulinsecretion::InsulinSecretionOptimizerState const *self){
    std::ostringstream oss;
    oss << '"' << self->get_name() << '"';
    return oss.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_CaChannelOpeningOptimizerState___str__(IMP::insulinsecretion::CaChannelOpeningOptimizerState const *self){
    std::ostringstream oss;
    oss << '"' << self->get_name() << '"';
    return oss.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_CaChannelOpeningOptimizerState___repr__(IMP::insulinsecretion::CaChannelOpeningOptimizerState const *self){
    std::ostringstream oss;
    oss << '"' << self->get_name() << '"';
    return oss.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_VesicleDockingOptimizerState___str__(IMP::insulinsecretion::VesicleDockingOptimizerState const *self){
    std::ostringstream oss;
    oss << '"' << self->get_name() << '"';
    return oss.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_VesicleDockingOptimizerState___repr__(IMP::insulinsecretion::VesicleDockingOptimizerState const *self){
    std::ostringstream oss;
    oss << '"' << self->get_name() << '"';
    return oss.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_RadialDistributionFunctionSingletonScore___str__(IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *self){
    std::ostringstream oss;
    oss << '"' << self->get_name() << '"';
    return oss.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_RadialDistributionFunctionSingletonScore___repr__(IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *self){
    std::ostringstream oss;
    oss << '"' << self->get_name() << '"';
    return oss.str();
  }

SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r;
  if (!PyBool_Check(obj))
    return SWIG_ERROR;
  r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}

SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatKey k,IMP::Float v,bool opt){
   self->get_particle()->add_attribute(k, v, opt);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Float IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_2(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::IntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Int IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::IntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::IntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::IntKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::IntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_3(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatsKey a0,IMP::Floats a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Floats IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_2(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_2(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatsKey a0,IMP::Floats a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_2(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatsKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_2(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_4(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::IntsKey a0,IMP::Ints a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Ints IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_3(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::IntsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_3(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::IntsKey a0,IMP::Ints a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_3(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::IntsKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_3(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::IntsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}

SWIGINTERN int
SWIG_AsPtr_std_string (PyObject * obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}

SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_5(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::StringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::String IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_4(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::StringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_4(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::StringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_4(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::StringKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_4(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::StringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_6(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::ParticleIndexKey a0,IMP::Particle *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Particle *IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_5(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::ParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_5(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::ParticleIndexKey a0,IMP::Particle *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_5(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::ParticleIndexKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_5(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::ParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_7(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::ObjectKey a0,IMP::Object *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Object *IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_6(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::ObjectKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_6(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::ObjectKey a0,IMP::Object *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_6(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::ObjectKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_6(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::ObjectKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_8(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseFloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Float IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_7(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseFloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_7(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseFloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_7(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseFloatKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_7(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseFloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_9(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseIntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Int IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_8(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseIntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_8(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseIntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_8(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseIntKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_8(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseIntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_10(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseStringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::String IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_9(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseStringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_9(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseStringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_9(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseStringKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_9(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseStringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_11(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseParticleIndexKey a0,IMP::ParticleIndex a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::ParticleIndex IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_10(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_10(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseParticleIndexKey a0,IMP::ParticleIndex a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_10(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseParticleIndexKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_10(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::SparseParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN double IMP_insulinsecretion_SecretionCounterDecorator_get_derivative(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_derivative(a0);
}
SWIGINTERN std::string IMP_insulinsecretion_SecretionCounterDecorator_get_name(IMP::insulinsecretion::SecretionCounterDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->get_name();
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_clear_caches(IMP::insulinsecretion::SecretionCounterDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->clear_caches();
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_name(IMP::insulinsecretion::SecretionCounterDecorator *self,std::string a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->set_name(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_check_level(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::CheckLevel a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->set_check_level(a0);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_add_to_derivative(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatKey a0,double a1,IMP::DerivativeAccumulator a2){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->add_to_derivative(a0, a1, a2);
}
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator_set_is_optimized(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatKey a0,bool a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_is_optimized(a0, a1);
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator_get_is_optimized(IMP::insulinsecretion::SecretionCounterDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_is_optimized(a0);
}
SWIGINTERN IMP::CheckLevel IMP_insulinsecretion_SecretionCounterDecorator_get_check_level(IMP::insulinsecretion::SecretionCounterDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->get_check_level();
}
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___eq____SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::insulinsecretion::SecretionCounterDecorator o){
     return *self ==o;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___ne____SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::insulinsecretion::SecretionCounterDecorator o){
     return *self !=o;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___le____SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::insulinsecretion::SecretionCounterDecorator o){
     return *self <= o;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___lt____SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::insulinsecretion::SecretionCounterDecorator o){
     return *self < o;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___ge____SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::insulinsecretion::SecretionCounterDecorator o){
     return *self >= o;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___gt____SWIG_0(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::insulinsecretion::SecretionCounterDecorator o){
     return *self > o;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___eq____SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::Particle *d){
    return self->get_particle() == d;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___ne____SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::Particle *d){
     return self->get_particle() != d;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___le____SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::Particle *d){
     return self->get_particle() <= d;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___lt____SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::Particle *d){
     return self->get_particle() < d;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___ge____SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::Particle *d){
     return self->get_particle() >= d;
  }
SWIGINTERN bool IMP_insulinsecretion_SecretionCounterDecorator___gt____SWIG_1(IMP::insulinsecretion::SecretionCounterDecorator const *self,IMP::Particle *d){
     return self->get_particle() > d;
  }
SWIGINTERN std::size_t IMP_insulinsecretion_SecretionCounterDecorator___hash__(IMP::insulinsecretion::SecretionCounterDecorator const *self){
     return self->__hash__();
  }
SWIGINTERN std::string IMP_insulinsecretion_SecretionCounterDecorator___str__(IMP::insulinsecretion::SecretionCounterDecorator const *self){
    std::ostringstream out;
    self->show(out);
    return out.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_SecretionCounterDecorator___repr__(IMP::insulinsecretion::SecretionCounterDecorator const *self){
    std::ostringstream out;
    self->show(out);
    return out.str();
  }
SWIGINTERN PyObject *IMP_insulinsecretion_SecretionCounterDecorator__get_as_binary(IMP::insulinsecretion::SecretionCounterDecorator const *self){
    std::ostringstream oss;
    cereal::BinaryOutputArchive ba(oss);
    ba(*self);
    std::string s = oss.str();
    PyObject *p = PyBytes_FromStringAndSize(s.data(), s.size());
    if (p) {
      return p;
    } else {
      throw IMP::IndexException("PyBytes_FromStringAndSize failed");
    }
  }
SWIGINTERN void IMP_insulinsecretion_SecretionCounterDecorator__set_from_binary(IMP::insulinsecretion::SecretionCounterDecorator *self,PyObject *p){
    char *buf;
    Py_ssize_t len;
    if (PyBytes_AsStringAndSize(p, &buf, &len) < 0) {
      throw IMP::IndexException("PyBytes_AsStringAndSize failed");
    }
    std::string s(buf, len);
    std::istringstream iss(s);
    cereal::BinaryInputArchive ba(iss);
    ba(*self);
  }
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_0(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatKey k,IMP::Float v,bool opt){
   self->get_particle()->add_attribute(k, v, opt);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_1(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Float IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_0(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_0(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_0(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_0(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_2(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::IntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Int IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_1(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::IntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_1(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::IntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_1(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::IntKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_1(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::IntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_3(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatsKey a0,IMP::Floats a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Floats IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_2(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_2(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatsKey a0,IMP::Floats a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_2(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatsKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_2(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_4(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::IntsKey a0,IMP::Ints a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Ints IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_3(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::IntsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_3(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::IntsKey a0,IMP::Ints a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_3(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::IntsKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_3(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::IntsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_5(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::StringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::String IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_4(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::StringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_4(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::StringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_4(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::StringKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_4(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::StringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_6(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::ParticleIndexKey a0,IMP::Particle *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Particle *IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_5(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::ParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_5(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::ParticleIndexKey a0,IMP::Particle *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_5(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::ParticleIndexKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_5(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::ParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_7(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::ObjectKey a0,IMP::Object *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Object *IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_6(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::ObjectKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_6(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::ObjectKey a0,IMP::Object *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_6(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::ObjectKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_6(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::ObjectKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_8(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseFloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Float IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_7(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseFloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_7(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseFloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_7(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseFloatKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_7(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseFloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_9(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseIntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Int IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_8(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseIntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_8(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseIntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_8(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseIntKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_8(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseIntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_10(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseStringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::String IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_9(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseStringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_9(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseStringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_9(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseStringKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_9(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseStringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_11(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseParticleIndexKey a0,IMP::ParticleIndex a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::ParticleIndex IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_10(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_10(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseParticleIndexKey a0,IMP::ParticleIndex a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_10(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseParticleIndexKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_10(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::SparseParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN double IMP_insulinsecretion_MaturationStateDecorator_get_derivative(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_derivative(a0);
}
SWIGINTERN std::string IMP_insulinsecretion_MaturationStateDecorator_get_name(IMP::insulinsecretion::MaturationStateDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->get_name();
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_clear_caches(IMP::insulinsecretion::MaturationStateDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->clear_caches();
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_name(IMP::insulinsecretion::MaturationStateDecorator *self,std::string a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->set_name(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_check_level(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::CheckLevel a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->set_check_level(a0);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_add_to_derivative(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatKey a0,double a1,IMP::DerivativeAccumulator a2){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->add_to_derivative(a0, a1, a2);
}
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator_set_is_optimized(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatKey a0,bool a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_is_optimized(a0, a1);
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator_get_is_optimized(IMP::insulinsecretion::MaturationStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_is_optimized(a0);
}
SWIGINTERN IMP::CheckLevel IMP_insulinsecretion_MaturationStateDecorator_get_check_level(IMP::insulinsecretion::MaturationStateDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->get_check_level();
}
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___eq____SWIG_0(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::insulinsecretion::MaturationStateDecorator o){
     return *self ==o;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___ne____SWIG_0(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::insulinsecretion::MaturationStateDecorator o){
     return *self !=o;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___le____SWIG_0(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::insulinsecretion::MaturationStateDecorator o){
     return *self <= o;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___lt____SWIG_0(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::insulinsecretion::MaturationStateDecorator o){
     return *self < o;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___ge____SWIG_0(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::insulinsecretion::MaturationStateDecorator o){
     return *self >= o;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___gt____SWIG_0(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::insulinsecretion::MaturationStateDecorator o){
     return *self > o;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___eq____SWIG_1(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::Particle *d){
    return self->get_particle() == d;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___ne____SWIG_1(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() != d;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___le____SWIG_1(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() <= d;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___lt____SWIG_1(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() < d;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___ge____SWIG_1(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() >= d;
  }
SWIGINTERN bool IMP_insulinsecretion_MaturationStateDecorator___gt____SWIG_1(IMP::insulinsecretion::MaturationStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() > d;
  }
SWIGINTERN std::size_t IMP_insulinsecretion_MaturationStateDecorator___hash__(IMP::insulinsecretion::MaturationStateDecorator const *self){
     return self->__hash__();
  }
SWIGINTERN std::string IMP_insulinsecretion_MaturationStateDecorator___str__(IMP::insulinsecretion::MaturationStateDecorator const *self){
    std::ostringstream out;
    self->show(out);
    return out.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_MaturationStateDecorator___repr__(IMP::insulinsecretion::MaturationStateDecorator const *self){
    std::ostringstream out;
    self->show(out);
    return out.str();
  }
SWIGINTERN PyObject *IMP_insulinsecretion_MaturationStateDecorator__get_as_binary(IMP::insulinsecretion::MaturationStateDecorator const *self){
    std::ostringstream oss;
    cereal::BinaryOutputArchive ba(oss);
    ba(*self);
    std::string s = oss.str();
    PyObject *p = PyBytes_FromStringAndSize(s.data(), s.size());
    if (p) {
      return p;
    } else {
      throw IMP::IndexException("PyBytes_FromStringAndSize failed");
    }
  }
SWIGINTERN void IMP_insulinsecretion_MaturationStateDecorator__set_from_binary(IMP::insulinsecretion::MaturationStateDecorator *self,PyObject *p){
    char *buf;
    Py_ssize_t len;
    if (PyBytes_AsStringAndSize(p, &buf, &len) < 0) {
      throw IMP::IndexException("PyBytes_AsStringAndSize failed");
    }
    std::string s(buf, len);
    std::istringstream iss(s);
    cereal::BinaryInputArchive ba(iss);
    ba(*self);
  }
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_0(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatKey k,IMP::Float v,bool opt){
   self->get_particle()->add_attribute(k, v, opt);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_1(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Float IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_0(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_0(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_0(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_0(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_2(IMP::insulinsecretion::DockingStateDecorator *self,IMP::IntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Int IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_1(IMP::insulinsecretion::DockingStateDecorator *self,IMP::IntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_1(IMP::insulinsecretion::DockingStateDecorator *self,IMP::IntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_1(IMP::insulinsecretion::DockingStateDecorator *self,IMP::IntKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_1(IMP::insulinsecretion::DockingStateDecorator *self,IMP::IntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_3(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatsKey a0,IMP::Floats a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Floats IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_2(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_2(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatsKey a0,IMP::Floats a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_2(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatsKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_2(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_4(IMP::insulinsecretion::DockingStateDecorator *self,IMP::IntsKey a0,IMP::Ints a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Ints IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_3(IMP::insulinsecretion::DockingStateDecorator *self,IMP::IntsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_3(IMP::insulinsecretion::DockingStateDecorator *self,IMP::IntsKey a0,IMP::Ints a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_3(IMP::insulinsecretion::DockingStateDecorator *self,IMP::IntsKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_3(IMP::insulinsecretion::DockingStateDecorator *self,IMP::IntsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_5(IMP::insulinsecretion::DockingStateDecorator *self,IMP::StringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::String IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_4(IMP::insulinsecretion::DockingStateDecorator *self,IMP::StringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_4(IMP::insulinsecretion::DockingStateDecorator *self,IMP::StringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_4(IMP::insulinsecretion::DockingStateDecorator *self,IMP::StringKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_4(IMP::insulinsecretion::DockingStateDecorator *self,IMP::StringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_6(IMP::insulinsecretion::DockingStateDecorator *self,IMP::ParticleIndexKey a0,IMP::Particle *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Particle *IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_5(IMP::insulinsecretion::DockingStateDecorator *self,IMP::ParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_5(IMP::insulinsecretion::DockingStateDecorator *self,IMP::ParticleIndexKey a0,IMP::Particle *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_5(IMP::insulinsecretion::DockingStateDecorator *self,IMP::ParticleIndexKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_5(IMP::insulinsecretion::DockingStateDecorator *self,IMP::ParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_7(IMP::insulinsecretion::DockingStateDecorator *self,IMP::ObjectKey a0,IMP::Object *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Object *IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_6(IMP::insulinsecretion::DockingStateDecorator *self,IMP::ObjectKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_6(IMP::insulinsecretion::DockingStateDecorator *self,IMP::ObjectKey a0,IMP::Object *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_6(IMP::insulinsecretion::DockingStateDecorator *self,IMP::ObjectKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_6(IMP::insulinsecretion::DockingStateDecorator *self,IMP::ObjectKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_8(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseFloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Float IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_7(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseFloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_7(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseFloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_7(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseFloatKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_7(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseFloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_9(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseIntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Int IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_8(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseIntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_8(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseIntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_8(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseIntKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_8(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseIntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_10(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseStringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::String IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_9(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseStringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_9(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseStringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_9(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseStringKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_9(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseStringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_11(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseParticleIndexKey a0,IMP::ParticleIndex a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::ParticleIndex IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_10(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_10(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseParticleIndexKey a0,IMP::ParticleIndex a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_10(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseParticleIndexKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_10(IMP::insulinsecretion::DockingStateDecorator *self,IMP::SparseParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN double IMP_insulinsecretion_DockingStateDecorator_get_derivative(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_derivative(a0);
}
SWIGINTERN std::string IMP_insulinsecretion_DockingStateDecorator_get_name(IMP::insulinsecretion::DockingStateDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->get_name();
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_clear_caches(IMP::insulinsecretion::DockingStateDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->clear_caches();
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_name(IMP::insulinsecretion::DockingStateDecorator *self,std::string a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->set_name(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_check_level(IMP::insulinsecretion::DockingStateDecorator *self,IMP::CheckLevel a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->set_check_level(a0);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_add_to_derivative(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatKey a0,double a1,IMP::DerivativeAccumulator a2){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->add_to_derivative(a0, a1, a2);
}
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator_set_is_optimized(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatKey a0,bool a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_is_optimized(a0, a1);
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator_get_is_optimized(IMP::insulinsecretion::DockingStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_is_optimized(a0);
}
SWIGINTERN IMP::CheckLevel IMP_insulinsecretion_DockingStateDecorator_get_check_level(IMP::insulinsecretion::DockingStateDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->get_check_level();
}
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___eq____SWIG_0(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::insulinsecretion::DockingStateDecorator o){
     return *self ==o;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___ne____SWIG_0(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::insulinsecretion::DockingStateDecorator o){
     return *self !=o;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___le____SWIG_0(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::insulinsecretion::DockingStateDecorator o){
     return *self <= o;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___lt____SWIG_0(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::insulinsecretion::DockingStateDecorator o){
     return *self < o;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___ge____SWIG_0(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::insulinsecretion::DockingStateDecorator o){
     return *self >= o;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___gt____SWIG_0(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::insulinsecretion::DockingStateDecorator o){
     return *self > o;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___eq____SWIG_1(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::Particle *d){
    return self->get_particle() == d;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___ne____SWIG_1(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() != d;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___le____SWIG_1(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() <= d;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___lt____SWIG_1(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() < d;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___ge____SWIG_1(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() >= d;
  }
SWIGINTERN bool IMP_insulinsecretion_DockingStateDecorator___gt____SWIG_1(IMP::insulinsecretion::DockingStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() > d;
  }
SWIGINTERN std::size_t IMP_insulinsecretion_DockingStateDecorator___hash__(IMP::insulinsecretion::DockingStateDecorator const *self){
     return self->__hash__();
  }
SWIGINTERN std::string IMP_insulinsecretion_DockingStateDecorator___str__(IMP::insulinsecretion::DockingStateDecorator const *self){
    std::ostringstream out;
    self->show(out);
    return out.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_DockingStateDecorator___repr__(IMP::insulinsecretion::DockingStateDecorator const *self){
    std::ostringstream out;
    self->show(out);
    return out.str();
  }
SWIGINTERN PyObject *IMP_insulinsecretion_DockingStateDecorator__get_as_binary(IMP::insulinsecretion::DockingStateDecorator const *self){
    std::ostringstream oss;
    cereal::BinaryOutputArchive ba(oss);
    ba(*self);
    std::string s = oss.str();
    PyObject *p = PyBytes_FromStringAndSize(s.data(), s.size());
    if (p) {
      return p;
    } else {
      throw IMP::IndexException("PyBytes_FromStringAndSize failed");
    }
  }
SWIGINTERN void IMP_insulinsecretion_DockingStateDecorator__set_from_binary(IMP::insulinsecretion::DockingStateDecorator *self,PyObject *p){
    char *buf;
    Py_ssize_t len;
    if (PyBytes_AsStringAndSize(p, &buf, &len) < 0) {
      throw IMP::IndexException("PyBytes_AsStringAndSize failed");
    }
    std::string s(buf, len);
    std::istringstream iss(s);
    cereal::BinaryInputArchive ba(iss);
    ba(*self);
  }
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatKey k,IMP::Float v,bool opt){
   self->get_particle()->add_attribute(k, v, opt);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Float IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_2(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::IntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Int IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::IntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::IntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::IntKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::IntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_3(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatsKey a0,IMP::Floats a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Floats IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_2(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_2(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatsKey a0,IMP::Floats a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_2(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatsKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_2(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_4(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::IntsKey a0,IMP::Ints a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Ints IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_3(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::IntsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_3(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::IntsKey a0,IMP::Ints a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_3(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::IntsKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_3(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::IntsKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_5(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::StringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::String IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_4(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::StringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_4(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::StringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_4(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::StringKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_4(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::StringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_6(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::ParticleIndexKey a0,IMP::Particle *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Particle *IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_5(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::ParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_5(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::ParticleIndexKey a0,IMP::Particle *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_5(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::ParticleIndexKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_5(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::ParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_7(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::ObjectKey a0,IMP::Object *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Object *IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_6(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::ObjectKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_6(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::ObjectKey a0,IMP::Object *a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_6(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::ObjectKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_6(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::ObjectKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_8(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseFloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Float IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_7(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseFloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_7(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseFloatKey a0,IMP::Float a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_7(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseFloatKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_7(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseFloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_9(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseIntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::Int IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_8(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseIntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_8(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseIntKey a0,IMP::Int a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_8(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseIntKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_8(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseIntKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_10(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseStringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::String IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_9(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseStringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_9(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseStringKey a0,IMP::String a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_9(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseStringKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_9(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseStringKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_11(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseParticleIndexKey a0,IMP::ParticleIndex a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->add_attribute(a0, a1);
}
SWIGINTERN IMP::ParticleIndex IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_10(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_value(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_10(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseParticleIndexKey a0,IMP::ParticleIndex a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_value(a0, a1);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_10(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseParticleIndexKey a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->remove_attribute(a0);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_10(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::SparseParticleIndexKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->has_attribute(a0);
}
SWIGINTERN double IMP_insulinsecretion_CaChannelStateDecorator_get_derivative(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_derivative(a0);
}
SWIGINTERN std::string IMP_insulinsecretion_CaChannelStateDecorator_get_name(IMP::insulinsecretion::CaChannelStateDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->get_name();
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_clear_caches(IMP::insulinsecretion::CaChannelStateDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->clear_caches();
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_name(IMP::insulinsecretion::CaChannelStateDecorator *self,std::string a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->set_name(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_check_level(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::CheckLevel a0){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->set_check_level(a0);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_add_to_derivative(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatKey a0,double a1,IMP::DerivativeAccumulator a2){
      do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   self->get_particle()->add_to_derivative(a0, a1, a2);
}
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator_set_is_optimized(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatKey a0,bool a1){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  self->get_particle()->set_is_optimized(a0, a1);
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator_get_is_optimized(IMP::insulinsecretion::CaChannelStateDecorator *self,IMP::FloatKey a0){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
  return self->get_particle()->get_is_optimized(a0);
}
SWIGINTERN IMP::CheckLevel IMP_insulinsecretion_CaChannelStateDecorator_get_check_level(IMP::insulinsecretion::CaChannelStateDecorator *self){
     do {                                                                          if (IMP::get_check_level() >= IMP::USAGE && !(self->get_particle())) {            std::ostringstream imp_check_oss;                                           imp_check_oss << "Usage check failure: " << "Null particle" << IMP::get_context_message()                      << std::endl;                                                 IMP::handle_error(imp_check_oss.str().c_str());                       throw IMP::UsageException(imp_check_oss.str().c_str());             }                                                                         } while (false);
   return self->get_particle()->get_check_level();
}
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___eq____SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::insulinsecretion::CaChannelStateDecorator o){
     return *self ==o;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___ne____SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::insulinsecretion::CaChannelStateDecorator o){
     return *self !=o;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___le____SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::insulinsecretion::CaChannelStateDecorator o){
     return *self <= o;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___lt____SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::insulinsecretion::CaChannelStateDecorator o){
     return *self < o;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___ge____SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::insulinsecretion::CaChannelStateDecorator o){
     return *self >= o;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___gt____SWIG_0(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::insulinsecretion::CaChannelStateDecorator o){
     return *self > o;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___eq____SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::Particle *d){
    return self->get_particle() == d;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___ne____SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() != d;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___le____SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() <= d;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___lt____SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() < d;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___ge____SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() >= d;
  }
SWIGINTERN bool IMP_insulinsecretion_CaChannelStateDecorator___gt____SWIG_1(IMP::insulinsecretion::CaChannelStateDecorator const *self,IMP::Particle *d){
     return self->get_particle() > d;
  }
SWIGINTERN std::size_t IMP_insulinsecretion_CaChannelStateDecorator___hash__(IMP::insulinsecretion::CaChannelStateDecorator const *self){
     return self->__hash__();
  }
SWIGINTERN std::string IMP_insulinsecretion_CaChannelStateDecorator___str__(IMP::insulinsecretion::CaChannelStateDecorator const *self){
    std::ostringstream out;
    self->show(out);
    return out.str();
  }
SWIGINTERN std::string IMP_insulinsecretion_CaChannelStateDecorator___repr__(IMP::insulinsecretion::CaChannelStateDecorator const *self){
    std::ostringstream out;
    self->show(out);
    return out.str();
  }
SWIGINTERN PyObject *IMP_insulinsecretion_CaChannelStateDecorator__get_as_binary(IMP::insulinsecretion::CaChannelStateDecorator const *self){
    std::ostringstream oss;
    cereal::BinaryOutputArchive ba(oss);
    ba(*self);
    std::string s = oss.str();
    PyObject *p = PyBytes_FromStringAndSize(s.data(), s.size());
    if (p) {
      return p;
    } else {
      throw IMP::IndexException("PyBytes_FromStringAndSize failed");
    }
  }
SWIGINTERN void IMP_insulinsecretion_CaChannelStateDecorator__set_from_binary(IMP::insulinsecretion::CaChannelStateDecorator *self,PyObject *p){
    char *buf;
    Py_ssize_t len;
    if (PyBytes_AsStringAndSize(p, &buf, &len) < 0) {
      throw IMP::IndexException("PyBytes_AsStringAndSize failed");
    }
    std::string s(buf, len);
    std::istringstream iss(s);
    cereal::BinaryInputArchive ba(iss);
    ba(*self);
  }


/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "wrap.h-in"

#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_delete_IMP_INSULINSECRETION_SwigPyIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IMP_INSULINSECRETION_SwigPyIterator" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_value" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)((swig::IMP_INSULINSECRETION_SwigPyIterator const *)arg1)->value();
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_incr__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_incr" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_incr" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  try {
    result = (swig::IMP_INSULINSECRETION_SwigPyIterator *)(arg1)->incr(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_incr__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_incr" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  try {
    result = (swig::IMP_INSULINSECRETION_SwigPyIterator *)(arg1)->incr();
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_incr(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator_incr", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_size_t(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_IMP_INSULINSECRETION_SwigPyIterator_incr__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_IMP_INSULINSECRETION_SwigPyIterator_incr__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'IMP_INSULINSECRETION_SwigPyIterator_incr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    swig::IMP_INSULINSECRETION_SwigPyIterator::incr(size_t)\n"
    "    swig::IMP_INSULINSECRETION_SwigPyIterator::incr()\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_decr__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_decr" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_decr" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  try {
    result = (swig::IMP_INSULINSECRETION_SwigPyIterator *)(arg1)->decr(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_decr__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_decr" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  try {
    result = (swig::IMP_INSULINSECRETION_SwigPyIterator *)(arg1)->decr();
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_decr(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator_decr", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_size_t(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_IMP_INSULINSECRETION_SwigPyIterator_decr__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_IMP_INSULINSECRETION_SwigPyIterator_decr__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'IMP_INSULINSECRETION_SwigPyIterator_decr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    swig::IMP_INSULINSECRETION_SwigPyIterator::decr(size_t)\n"
    "    swig::IMP_INSULINSECRETION_SwigPyIterator::decr()\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_distance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ptrdiff_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator_distance", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_distance" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_distance" "', argument " "2"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IMP_INSULINSECRETION_SwigPyIterator_distance" "', argument " "2"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp2);
  try {
    result = ((swig::IMP_INSULINSECRETION_SwigPyIterator const *)arg1)->distance((swig::IMP_INSULINSECRETION_SwigPyIterator const &)*arg2);
  } catch(std::invalid_argument &_e) {
    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
  }
  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_equal(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator_equal", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_equal" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_equal" "', argument " "2"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IMP_INSULINSECRETION_SwigPyIterator_equal" "', argument " "2"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp2);
  try {
    result = (bool)((swig::IMP_INSULINSECRETION_SwigPyIterator const *)arg1)->equal((swig::IMP_INSULINSECRETION_SwigPyIterator const &)*arg2);
  } catch(std::invalid_argument &_e) {
    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_copy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_copy" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  result = (swig::IMP_INSULINSECRETION_SwigPyIterator *)((swig::IMP_INSULINSECRETION_SwigPyIterator const *)arg1)->copy();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_next(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_next" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->next();
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator___next__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___next__" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->__next__();
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_previous(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_previous" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->previous();
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator_advance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator_advance", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_advance" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator_advance" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::IMP_INSULINSECRETION_SwigPyIterator *)(arg1)->advance(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator___eq__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___eq__" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IMP_INSULINSECRETION_SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp2);
  result = (bool)((swig::IMP_INSULINSECRETION_SwigPyIterator const *)arg1)->operator ==((swig::IMP_INSULINSECRETION_SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator___ne__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___ne__" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IMP_INSULINSECRETION_SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp2);
  result = (bool)((swig::IMP_INSULINSECRETION_SwigPyIterator const *)arg1)->operator !=((swig::IMP_INSULINSECRETION_SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator___iadd__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator___iadd__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___iadd__" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___iadd__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::IMP_INSULINSECRETION_SwigPyIterator *) &(arg1)->operator +=(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator___isub__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator___isub__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___isub__" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___isub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::IMP_INSULINSECRETION_SwigPyIterator *) &(arg1)->operator -=(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator___add__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator___add__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___add__" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___add__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::IMP_INSULINSECRETION_SwigPyIterator *)((swig::IMP_INSULINSECRETION_SwigPyIterator const *)arg1)->operator +(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator___sub____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___sub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::IMP_INSULINSECRETION_SwigPyIterator *)((swig::IMP_INSULINSECRETION_SwigPyIterator const *)arg1)->operator -(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator___sub____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg1 = (swig::IMP_INSULINSECRETION_SwigPyIterator *) 0 ;
  swig::IMP_INSULINSECRETION_SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  ptrdiff_t result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IMP_INSULINSECRETION_SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IMP_INSULINSECRETION_SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::IMP_INSULINSECRETION_SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::IMP_INSULINSECRETION_SwigPyIterator * >(argp2);
  result = ((swig::IMP_INSULINSECRETION_SwigPyIterator const *)arg1)->operator -((swig::IMP_INSULINSECRETION_SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_IMP_INSULINSECRETION_SwigPyIterator___sub__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "IMP_INSULINSECRETION_SwigPyIterator___sub__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_IMP_INSULINSECRETION_SwigPyIterator___sub____SWIG_1(self, argc, argv);
    case 2:
      return _wrap_IMP_INSULINSECRETION_SwigPyIterator___sub____SWIG_0(self, argc, argv);
    case 3:
      return _wrap_IMP_INSULINSECRETION_SwigPyIterator___sub____SWIG_1(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *IMP_INSULINSECRETION_SwigPyIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_swig__IMP_INSULINSECRETION_SwigPyIterator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap__ostream_write(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = (std::ostream *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  size_t size2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "_ostream_write", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_ostream_write" "', argument " "1"" of type '" "std::ostream *""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, &size2, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_ostream_write" "', argument " "2"" of type '" "(const char *osa_buf, int osa_len)""'");
  }
  arg2 = (char *) buf2;					       
  arg3 = (int) size2 - 1;
  {
    try {
      (arg1)->write((char const *)arg2,arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete _ostream_write
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_ostream_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_std__ostream, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap__object_cast_to_VesicleTraffickingSingletonScore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::Object *arg1 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::insulinsecretion::VesicleTraffickingSingletonScore *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_object_cast_to_VesicleTraffickingSingletonScore" "', argument " "1"" of type '" "IMP::Object *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Object * >(argp1);
  {
    try {
      result = (IMP::insulinsecretion::VesicleTraffickingSingletonScore *)IMP::SWIGTEMPLATEDISAMBIGUATOR object_cast< IMP::insulinsecretion::VesicleTraffickingSingletonScore >(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete _object_cast_to_VesicleTraffickingSingletonScore
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__object_cast_to_InsulinSecretionOptimizerState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::Object *arg1 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::insulinsecretion::InsulinSecretionOptimizerState *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_object_cast_to_InsulinSecretionOptimizerState" "', argument " "1"" of type '" "IMP::Object *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Object * >(argp1);
  {
    try {
      result = (IMP::insulinsecretion::InsulinSecretionOptimizerState *)IMP::SWIGTEMPLATEDISAMBIGUATOR object_cast< IMP::insulinsecretion::InsulinSecretionOptimizerState >(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete _object_cast_to_InsulinSecretionOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__object_cast_to_CaChannelOpeningOptimizerState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::Object *arg1 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::insulinsecretion::CaChannelOpeningOptimizerState *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_object_cast_to_CaChannelOpeningOptimizerState" "', argument " "1"" of type '" "IMP::Object *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Object * >(argp1);
  {
    try {
      result = (IMP::insulinsecretion::CaChannelOpeningOptimizerState *)IMP::SWIGTEMPLATEDISAMBIGUATOR object_cast< IMP::insulinsecretion::CaChannelOpeningOptimizerState >(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete _object_cast_to_CaChannelOpeningOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__object_cast_to_VesicleDockingOptimizerState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::Object *arg1 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::insulinsecretion::VesicleDockingOptimizerState *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_object_cast_to_VesicleDockingOptimizerState" "', argument " "1"" of type '" "IMP::Object *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Object * >(argp1);
  {
    try {
      result = (IMP::insulinsecretion::VesicleDockingOptimizerState *)IMP::SWIGTEMPLATEDISAMBIGUATOR object_cast< IMP::insulinsecretion::VesicleDockingOptimizerState >(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete _object_cast_to_VesicleDockingOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__VesicleDockingOptimizerState, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__object_cast_to_RadialDistributionFunctionSingletonScore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::Object *arg1 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_object_cast_to_RadialDistributionFunctionSingletonScore" "', argument " "1"" of type '" "IMP::Object *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Object * >(argp1);
  {
    try {
      result = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *)IMP::SWIGTEMPLATEDISAMBIGUATOR object_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore >(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete _object_cast_to_RadialDistributionFunctionSingletonScore
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_VesicleTraffickingSingletonScore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::algebra::Vector3D arg1 ;
  double arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  IMP::insulinsecretion::VesicleTraffickingSingletonScore *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_VesicleTraffickingSingletonScore", 2, 2, swig_obj)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__algebra__VectorDT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VesicleTraffickingSingletonScore" "', argument " "1"" of type '" "IMP::algebra::Vector3D""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VesicleTraffickingSingletonScore" "', argument " "1"" of type '" "IMP::algebra::Vector3D""'");
    } else {
      IMP::algebra::Vector3D * temp = reinterpret_cast< IMP::algebra::Vector3D * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_VesicleTraffickingSingletonScore" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (IMP::insulinsecretion::VesicleTraffickingSingletonScore *)new IMP::insulinsecretion::VesicleTraffickingSingletonScore(arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_VesicleTraffickingSingletonScore
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(SWIG_POINTER_NEW & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, SWIG_POINTER_NEW | SWIG_POINTER_OWN);
  }
  if (result) result->ref();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VesicleTraffickingSingletonScore_set_k(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleTraffickingSingletonScore *arg1 = (IMP::insulinsecretion::VesicleTraffickingSingletonScore *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "VesicleTraffickingSingletonScore_set_k", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VesicleTraffickingSingletonScore_set_k" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleTraffickingSingletonScore *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleTraffickingSingletonScore * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VesicleTraffickingSingletonScore_set_k" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->set_k(arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete VesicleTraffickingSingletonScore_set_k
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VesicleTraffickingSingletonScore_get_k(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleTraffickingSingletonScore *arg1 = (IMP::insulinsecretion::VesicleTraffickingSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VesicleTraffickingSingletonScore_get_k" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleTraffickingSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleTraffickingSingletonScore * >(argp1);
  {
    try {
      result = (double)((IMP::insulinsecretion::VesicleTraffickingSingletonScore const *)arg1)->get_k();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete VesicleTraffickingSingletonScore_get_k
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VesicleTraffickingSingletonScore_do_get_inputs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleTraffickingSingletonScore *arg1 = (IMP::insulinsecretion::VesicleTraffickingSingletonScore *) 0 ;
  IMP::Model *arg2 = (IMP::Model *) 0 ;
  IMP::ParticleIndexes *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  SwigValueWrapper< IMP::Vector< IMP::WeakPointer< IMP::ModelObject > > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "VesicleTraffickingSingletonScore_do_get_inputs", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VesicleTraffickingSingletonScore_do_get_inputs" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleTraffickingSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleTraffickingSingletonScore * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VesicleTraffickingSingletonScore_do_get_inputs" "', argument " "2"" of type '" "IMP::Model *""'"); 
  }
  arg2 = reinterpret_cast< IMP::Model * >(argp2);
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::ParticleIndexes, Convert< IMP::ParticleIndex > >::get_cpp_object(swig_obj[2], "VesicleTraffickingSingletonScore_do_get_inputs", 3, "IMP::ParticleIndexes const &", SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = ((IMP::insulinsecretion::VesicleTraffickingSingletonScore const *)arg1)->do_get_inputs(arg2,(IMP::ParticleIndexes const &)*arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete VesicleTraffickingSingletonScore_do_get_inputs
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::ModelObjectsTemp, Convert< IMP::ModelObject > >::create_python_object(ValueOrObject<IMP::ModelObjectsTemp >::get(result), SWIGTYPE_p_IMP__ModelObject, SWIG_POINTER_OWN);
  }
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_VesicleTraffickingSingletonScore_get_version_info(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleTraffickingSingletonScore *arg1 = (IMP::insulinsecretion::VesicleTraffickingSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ::IMP::VersionInfo result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VesicleTraffickingSingletonScore_get_version_info" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleTraffickingSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleTraffickingSingletonScore * >(argp1);
  {
    try {
      result = ((IMP::insulinsecretion::VesicleTraffickingSingletonScore const *)arg1)->get_version_info();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete VesicleTraffickingSingletonScore_get_version_info
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new ::IMP::VersionInfo(result)), SWIGTYPE_p_IMP__VersionInfo, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_VesicleTraffickingSingletonScore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleTraffickingSingletonScore *arg1 = (IMP::insulinsecretion::VesicleTraffickingSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VesicleTraffickingSingletonScore" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleTraffickingSingletonScore *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleTraffickingSingletonScore * >(argp1);
  {
    try {
      if (arg1) arg1->unref();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete delete_VesicleTraffickingSingletonScore
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VesicleTraffickingSingletonScore___str__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleTraffickingSingletonScore *arg1 = (IMP::insulinsecretion::VesicleTraffickingSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VesicleTraffickingSingletonScore___str__" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleTraffickingSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleTraffickingSingletonScore * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_VesicleTraffickingSingletonScore___str__((IMP::insulinsecretion::VesicleTraffickingSingletonScore const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete VesicleTraffickingSingletonScore___str__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VesicleTraffickingSingletonScore___repr__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleTraffickingSingletonScore *arg1 = (IMP::insulinsecretion::VesicleTraffickingSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VesicleTraffickingSingletonScore___repr__" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleTraffickingSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleTraffickingSingletonScore * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_VesicleTraffickingSingletonScore___repr__((IMP::insulinsecretion::VesicleTraffickingSingletonScore const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete VesicleTraffickingSingletonScore___repr__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *VesicleTraffickingSingletonScore_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *VesicleTraffickingSingletonScore_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_InsulinSecretionOptimizerState__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndexesAdaptor arg2 ;
  IMP::algebra::Sphere3D arg3 ;
  int arg4 ;
  double arg5 ;
  unsigned int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  IMP::insulinsecretion::InsulinSecretionOptimizerState *result = 0 ;
  
  if ((nobjs < 6) || (nobjs > 6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__ParticleIndexesAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "2"" of type '" "IMP::ParticleIndexesAdaptor""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InsulinSecretionOptimizerState" "', argument " "2"" of type '" "IMP::ParticleIndexesAdaptor""'");
    } else {
      IMP::ParticleIndexesAdaptor * temp = reinterpret_cast< IMP::ParticleIndexesAdaptor * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_IMP__algebra__SphereDT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "3"" of type '" "IMP::algebra::Sphere3D""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InsulinSecretionOptimizerState" "', argument " "3"" of type '" "IMP::algebra::Sphere3D""'");
    } else {
      IMP::algebra::Sphere3D * temp = reinterpret_cast< IMP::algebra::Sphere3D * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_double(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  {
    try {
      result = (IMP::insulinsecretion::InsulinSecretionOptimizerState *)new IMP::insulinsecretion::InsulinSecretionOptimizerState(arg1,arg2,arg3,arg4,arg5,arg6);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_InsulinSecretionOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(SWIG_POINTER_NEW & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, SWIG_POINTER_NEW | SWIG_POINTER_OWN);
  }
  if (result) result->ref();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_InsulinSecretionOptimizerState__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndexesAdaptor arg2 ;
  IMP::algebra::Sphere3D arg3 ;
  int arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  IMP::insulinsecretion::InsulinSecretionOptimizerState *result = 0 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__ParticleIndexesAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "2"" of type '" "IMP::ParticleIndexesAdaptor""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InsulinSecretionOptimizerState" "', argument " "2"" of type '" "IMP::ParticleIndexesAdaptor""'");
    } else {
      IMP::ParticleIndexesAdaptor * temp = reinterpret_cast< IMP::ParticleIndexesAdaptor * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_IMP__algebra__SphereDT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "3"" of type '" "IMP::algebra::Sphere3D""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InsulinSecretionOptimizerState" "', argument " "3"" of type '" "IMP::algebra::Sphere3D""'");
    } else {
      IMP::algebra::Sphere3D * temp = reinterpret_cast< IMP::algebra::Sphere3D * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_double(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_InsulinSecretionOptimizerState" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  {
    try {
      result = (IMP::insulinsecretion::InsulinSecretionOptimizerState *)new IMP::insulinsecretion::InsulinSecretionOptimizerState(arg1,arg2,arg3,arg4,arg5);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_InsulinSecretionOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(SWIG_POINTER_NEW & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, SWIG_POINTER_NEW | SWIG_POINTER_OWN);
  }
  if (result) result->ref();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_InsulinSecretionOptimizerState(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[7] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_InsulinSecretionOptimizerState", 0, 6, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 5) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__ParticleIndexesAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_IMP__algebra__SphereDT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[3], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[4], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 6) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__ParticleIndexesAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_IMP__algebra__SphereDT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[3], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[4], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_new_InsulinSecretionOptimizerState__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_new_InsulinSecretionOptimizerState__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_InsulinSecretionOptimizerState'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::InsulinSecretionOptimizerState::InsulinSecretionOptimizerState(IMP::Model *,IMP::ParticleIndexesAdaptor,IMP::algebra::Sphere3D,int,double,unsigned int)\n"
    "    IMP::insulinsecretion::InsulinSecretionOptimizerState::InsulinSecretionOptimizerState(IMP::Model *,IMP::ParticleIndexesAdaptor,IMP::algebra::Sphere3D,int,double)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_InsulinSecretionOptimizerState_set_cut_off(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::InsulinSecretionOptimizerState *arg1 = (IMP::insulinsecretion::InsulinSecretionOptimizerState *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "InsulinSecretionOptimizerState_set_cut_off", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsulinSecretionOptimizerState_set_cut_off" "', argument " "1"" of type '" "IMP::insulinsecretion::InsulinSecretionOptimizerState *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::InsulinSecretionOptimizerState * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InsulinSecretionOptimizerState_set_cut_off" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->set_cut_off(arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete InsulinSecretionOptimizerState_set_cut_off
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InsulinSecretionOptimizerState_get_cut_off(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::InsulinSecretionOptimizerState *arg1 = (IMP::insulinsecretion::InsulinSecretionOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsulinSecretionOptimizerState_get_cut_off" "', argument " "1"" of type '" "IMP::insulinsecretion::InsulinSecretionOptimizerState const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::InsulinSecretionOptimizerState * >(argp1);
  {
    try {
      result = (double)((IMP::insulinsecretion::InsulinSecretionOptimizerState const *)arg1)->get_cut_off();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete InsulinSecretionOptimizerState_get_cut_off
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InsulinSecretionOptimizerState_set_vesicles(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::InsulinSecretionOptimizerState *arg1 = (IMP::insulinsecretion::InsulinSecretionOptimizerState *) 0 ;
  IMP::Particles *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "InsulinSecretionOptimizerState_set_vesicles", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsulinSecretionOptimizerState_set_vesicles" "', argument " "1"" of type '" "IMP::insulinsecretion::InsulinSecretionOptimizerState *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::InsulinSecretionOptimizerState * >(argp1);
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg2, ConvertSequence<IMP::Particles, Convert< IMP::Particle > >::get_cpp_object(swig_obj[1], "InsulinSecretionOptimizerState_set_vesicles", 2, "IMP::Particles const &", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      (arg1)->set_vesicles((IMP::Particles const &)*arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete InsulinSecretionOptimizerState_set_vesicles
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg2);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_InsulinSecretionOptimizerState_get_version_info(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::InsulinSecretionOptimizerState *arg1 = (IMP::insulinsecretion::InsulinSecretionOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ::IMP::VersionInfo result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsulinSecretionOptimizerState_get_version_info" "', argument " "1"" of type '" "IMP::insulinsecretion::InsulinSecretionOptimizerState const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::InsulinSecretionOptimizerState * >(argp1);
  {
    try {
      result = ((IMP::insulinsecretion::InsulinSecretionOptimizerState const *)arg1)->get_version_info();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete InsulinSecretionOptimizerState_get_version_info
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new ::IMP::VersionInfo(result)), SWIGTYPE_p_IMP__VersionInfo, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InsulinSecretionOptimizerState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::InsulinSecretionOptimizerState *arg1 = (IMP::insulinsecretion::InsulinSecretionOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InsulinSecretionOptimizerState" "', argument " "1"" of type '" "IMP::insulinsecretion::InsulinSecretionOptimizerState *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::InsulinSecretionOptimizerState * >(argp1);
  {
    try {
      if (arg1) arg1->unref();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete delete_InsulinSecretionOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InsulinSecretionOptimizerState___str__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::InsulinSecretionOptimizerState *arg1 = (IMP::insulinsecretion::InsulinSecretionOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsulinSecretionOptimizerState___str__" "', argument " "1"" of type '" "IMP::insulinsecretion::InsulinSecretionOptimizerState const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::InsulinSecretionOptimizerState * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_InsulinSecretionOptimizerState___str__((IMP::insulinsecretion::InsulinSecretionOptimizerState const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete InsulinSecretionOptimizerState___str__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InsulinSecretionOptimizerState___repr__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::InsulinSecretionOptimizerState *arg1 = (IMP::insulinsecretion::InsulinSecretionOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsulinSecretionOptimizerState___repr__" "', argument " "1"" of type '" "IMP::insulinsecretion::InsulinSecretionOptimizerState const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::InsulinSecretionOptimizerState * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_InsulinSecretionOptimizerState___repr__((IMP::insulinsecretion::InsulinSecretionOptimizerState const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete InsulinSecretionOptimizerState___repr__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InsulinSecretionOptimizerState_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_IMP__insulinsecretion__InsulinSecretionOptimizerState, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *InsulinSecretionOptimizerState_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_CaChannelOpeningOptimizerState__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndexesAdaptor arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  unsigned int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  IMP::insulinsecretion::CaChannelOpeningOptimizerState *result = 0 ;
  
  if ((nobjs < 6) || (nobjs > 6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__ParticleIndexesAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "2"" of type '" "IMP::ParticleIndexesAdaptor""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "2"" of type '" "IMP::ParticleIndexesAdaptor""'");
    } else {
      IMP::ParticleIndexesAdaptor * temp = reinterpret_cast< IMP::ParticleIndexesAdaptor * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  {
    try {
      result = (IMP::insulinsecretion::CaChannelOpeningOptimizerState *)new IMP::insulinsecretion::CaChannelOpeningOptimizerState(arg1,arg2,arg3,arg4,arg5,arg6);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_CaChannelOpeningOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(SWIG_POINTER_NEW & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, SWIG_POINTER_NEW | SWIG_POINTER_OWN);
  }
  if (result) result->ref();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CaChannelOpeningOptimizerState__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndexesAdaptor arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  IMP::insulinsecretion::CaChannelOpeningOptimizerState *result = 0 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__ParticleIndexesAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "2"" of type '" "IMP::ParticleIndexesAdaptor""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "2"" of type '" "IMP::ParticleIndexesAdaptor""'");
    } else {
      IMP::ParticleIndexesAdaptor * temp = reinterpret_cast< IMP::ParticleIndexesAdaptor * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_CaChannelOpeningOptimizerState" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      result = (IMP::insulinsecretion::CaChannelOpeningOptimizerState *)new IMP::insulinsecretion::CaChannelOpeningOptimizerState(arg1,arg2,arg3,arg4,arg5);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_CaChannelOpeningOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(SWIG_POINTER_NEW & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, SWIG_POINTER_NEW | SWIG_POINTER_OWN);
  }
  if (result) result->ref();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CaChannelOpeningOptimizerState(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[7] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_CaChannelOpeningOptimizerState", 0, 6, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 5) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__ParticleIndexesAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[3], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[4], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 6) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__ParticleIndexesAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[3], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[4], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_new_CaChannelOpeningOptimizerState__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_new_CaChannelOpeningOptimizerState__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_CaChannelOpeningOptimizerState'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::CaChannelOpeningOptimizerState::CaChannelOpeningOptimizerState(IMP::Model *,IMP::ParticleIndexesAdaptor,int,int,int,unsigned int)\n"
    "    IMP::insulinsecretion::CaChannelOpeningOptimizerState::CaChannelOpeningOptimizerState(IMP::Model *,IMP::ParticleIndexesAdaptor,int,int,int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaChannelOpeningOptimizerState_set_cachannel(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelOpeningOptimizerState *arg1 = (IMP::insulinsecretion::CaChannelOpeningOptimizerState *) 0 ;
  IMP::Particles *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "CaChannelOpeningOptimizerState_set_cachannel", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelOpeningOptimizerState_set_cachannel" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelOpeningOptimizerState *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelOpeningOptimizerState * >(argp1);
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg2, ConvertSequence<IMP::Particles, Convert< IMP::Particle > >::get_cpp_object(swig_obj[1], "CaChannelOpeningOptimizerState_set_cachannel", 2, "IMP::Particles const &", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      (arg1)->set_cachannel((IMP::Particles const &)*arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelOpeningOptimizerState_set_cachannel
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg2);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelOpeningOptimizerState_get_version_info(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelOpeningOptimizerState *arg1 = (IMP::insulinsecretion::CaChannelOpeningOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ::IMP::VersionInfo result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelOpeningOptimizerState_get_version_info" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelOpeningOptimizerState const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelOpeningOptimizerState * >(argp1);
  {
    try {
      result = ((IMP::insulinsecretion::CaChannelOpeningOptimizerState const *)arg1)->get_version_info();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelOpeningOptimizerState_get_version_info
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new ::IMP::VersionInfo(result)), SWIGTYPE_p_IMP__VersionInfo, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CaChannelOpeningOptimizerState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelOpeningOptimizerState *arg1 = (IMP::insulinsecretion::CaChannelOpeningOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CaChannelOpeningOptimizerState" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelOpeningOptimizerState *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelOpeningOptimizerState * >(argp1);
  {
    try {
      if (arg1) arg1->unref();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete delete_CaChannelOpeningOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelOpeningOptimizerState___str__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelOpeningOptimizerState *arg1 = (IMP::insulinsecretion::CaChannelOpeningOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelOpeningOptimizerState___str__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelOpeningOptimizerState const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelOpeningOptimizerState * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_CaChannelOpeningOptimizerState___str__((IMP::insulinsecretion::CaChannelOpeningOptimizerState const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelOpeningOptimizerState___str__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelOpeningOptimizerState___repr__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelOpeningOptimizerState *arg1 = (IMP::insulinsecretion::CaChannelOpeningOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelOpeningOptimizerState___repr__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelOpeningOptimizerState const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelOpeningOptimizerState * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_CaChannelOpeningOptimizerState___repr__((IMP::insulinsecretion::CaChannelOpeningOptimizerState const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelOpeningOptimizerState___repr__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CaChannelOpeningOptimizerState_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *CaChannelOpeningOptimizerState_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_VesicleDockingOptimizerState__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::SingletonContainerAdaptor arg1 ;
  IMP::SingletonContainerAdaptor arg2 ;
  double arg3 ;
  double arg4 ;
  int arg5 ;
  unsigned int arg6 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  IMP::insulinsecretion::VesicleDockingOptimizerState *result = 0 ;
  
  if ((nobjs < 6) || (nobjs > 6)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__SingletonContainerAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VesicleDockingOptimizerState" "', argument " "1"" of type '" "IMP::SingletonContainerAdaptor""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VesicleDockingOptimizerState" "', argument " "1"" of type '" "IMP::SingletonContainerAdaptor""'");
    } else {
      IMP::SingletonContainerAdaptor * temp = reinterpret_cast< IMP::SingletonContainerAdaptor * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__SingletonContainerAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_VesicleDockingOptimizerState" "', argument " "2"" of type '" "IMP::SingletonContainerAdaptor""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VesicleDockingOptimizerState" "', argument " "2"" of type '" "IMP::SingletonContainerAdaptor""'");
    } else {
      IMP::SingletonContainerAdaptor * temp = reinterpret_cast< IMP::SingletonContainerAdaptor * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_VesicleDockingOptimizerState" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_VesicleDockingOptimizerState" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_VesicleDockingOptimizerState" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_VesicleDockingOptimizerState" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  {
    try {
      result = (IMP::insulinsecretion::VesicleDockingOptimizerState *)new IMP::insulinsecretion::VesicleDockingOptimizerState(arg1,arg2,arg3,arg4,arg5,arg6);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_VesicleDockingOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(SWIG_POINTER_NEW & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__VesicleDockingOptimizerState, SWIG_POINTER_NEW | SWIG_POINTER_OWN);
  }
  if (result) result->ref();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_VesicleDockingOptimizerState__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::SingletonContainerAdaptor arg1 ;
  IMP::SingletonContainerAdaptor arg2 ;
  double arg3 ;
  double arg4 ;
  int arg5 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  IMP::insulinsecretion::VesicleDockingOptimizerState *result = 0 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__SingletonContainerAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VesicleDockingOptimizerState" "', argument " "1"" of type '" "IMP::SingletonContainerAdaptor""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VesicleDockingOptimizerState" "', argument " "1"" of type '" "IMP::SingletonContainerAdaptor""'");
    } else {
      IMP::SingletonContainerAdaptor * temp = reinterpret_cast< IMP::SingletonContainerAdaptor * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__SingletonContainerAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_VesicleDockingOptimizerState" "', argument " "2"" of type '" "IMP::SingletonContainerAdaptor""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VesicleDockingOptimizerState" "', argument " "2"" of type '" "IMP::SingletonContainerAdaptor""'");
    } else {
      IMP::SingletonContainerAdaptor * temp = reinterpret_cast< IMP::SingletonContainerAdaptor * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_VesicleDockingOptimizerState" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_VesicleDockingOptimizerState" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_VesicleDockingOptimizerState" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      result = (IMP::insulinsecretion::VesicleDockingOptimizerState *)new IMP::insulinsecretion::VesicleDockingOptimizerState(arg1,arg2,arg3,arg4,arg5);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_VesicleDockingOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(SWIG_POINTER_NEW & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__VesicleDockingOptimizerState, SWIG_POINTER_NEW | SWIG_POINTER_OWN);
  }
  if (result) result->ref();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_VesicleDockingOptimizerState(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[7] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_VesicleDockingOptimizerState", 0, 6, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 5) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__SingletonContainerAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__SingletonContainerAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[3], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[4], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 6) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__SingletonContainerAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__SingletonContainerAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[3], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[4], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_new_VesicleDockingOptimizerState__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_new_VesicleDockingOptimizerState__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_VesicleDockingOptimizerState'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::VesicleDockingOptimizerState::VesicleDockingOptimizerState(IMP::SingletonContainerAdaptor,IMP::SingletonContainerAdaptor,double,double,int,unsigned int)\n"
    "    IMP::insulinsecretion::VesicleDockingOptimizerState::VesicleDockingOptimizerState(IMP::SingletonContainerAdaptor,IMP::SingletonContainerAdaptor,double,double,int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_VesicleDockingOptimizerState_get_version_info(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleDockingOptimizerState *arg1 = (IMP::insulinsecretion::VesicleDockingOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ::IMP::VersionInfo result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleDockingOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VesicleDockingOptimizerState_get_version_info" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleDockingOptimizerState const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleDockingOptimizerState * >(argp1);
  {
    try {
      result = ((IMP::insulinsecretion::VesicleDockingOptimizerState const *)arg1)->get_version_info();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete VesicleDockingOptimizerState_get_version_info
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new ::IMP::VersionInfo(result)), SWIGTYPE_p_IMP__VersionInfo, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_VesicleDockingOptimizerState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleDockingOptimizerState *arg1 = (IMP::insulinsecretion::VesicleDockingOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleDockingOptimizerState, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VesicleDockingOptimizerState" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleDockingOptimizerState *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleDockingOptimizerState * >(argp1);
  {
    try {
      if (arg1) arg1->unref();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete delete_VesicleDockingOptimizerState
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VesicleDockingOptimizerState___str__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleDockingOptimizerState *arg1 = (IMP::insulinsecretion::VesicleDockingOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleDockingOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VesicleDockingOptimizerState___str__" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleDockingOptimizerState const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleDockingOptimizerState * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_VesicleDockingOptimizerState___str__((IMP::insulinsecretion::VesicleDockingOptimizerState const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete VesicleDockingOptimizerState___str__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VesicleDockingOptimizerState___repr__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::VesicleDockingOptimizerState *arg1 = (IMP::insulinsecretion::VesicleDockingOptimizerState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__VesicleDockingOptimizerState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VesicleDockingOptimizerState___repr__" "', argument " "1"" of type '" "IMP::insulinsecretion::VesicleDockingOptimizerState const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::VesicleDockingOptimizerState * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_VesicleDockingOptimizerState___repr__((IMP::insulinsecretion::VesicleDockingOptimizerState const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete VesicleDockingOptimizerState___repr__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *VesicleDockingOptimizerState_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_IMP__insulinsecretion__VesicleDockingOptimizerState, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *VesicleDockingOptimizerState_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_RadialDistributionFunctionSingletonScore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::algebra::Sphere3D arg1 ;
  IMP::algebra::Sphere3D arg2 ;
  SwigValueWrapper< IMP::Vector< double > > arg3 ;
  double arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_RadialDistributionFunctionSingletonScore", 4, 4, swig_obj)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__algebra__SphereDT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RadialDistributionFunctionSingletonScore" "', argument " "1"" of type '" "IMP::algebra::Sphere3D""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RadialDistributionFunctionSingletonScore" "', argument " "1"" of type '" "IMP::algebra::Sphere3D""'");
    } else {
      IMP::algebra::Sphere3D * temp = reinterpret_cast< IMP::algebra::Sphere3D * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__algebra__SphereDT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_RadialDistributionFunctionSingletonScore" "', argument " "2"" of type '" "IMP::algebra::Sphere3D""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RadialDistributionFunctionSingletonScore" "', argument " "2"" of type '" "IMP::algebra::Sphere3D""'");
    } else {
      IMP::algebra::Sphere3D * temp = reinterpret_cast< IMP::algebra::Sphere3D * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_cpp_object(swig_obj[2], "new_RadialDistributionFunctionSingletonScore", 3, "IMP::Floats", SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_RadialDistributionFunctionSingletonScore" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      result = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *)new IMP::insulinsecretion::RadialDistributionFunctionSingletonScore(arg1,arg2,arg3,arg4);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_RadialDistributionFunctionSingletonScore
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(SWIG_POINTER_NEW & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, SWIG_POINTER_NEW | SWIG_POINTER_OWN);
  }
  {
    delete_if_pointer(arg3);
  }
  if (result) result->ref();
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore_set_k(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "RadialDistributionFunctionSingletonScore_set_k", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore_set_k" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RadialDistributionFunctionSingletonScore_set_k" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->set_k(arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore_set_k
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore_get_k(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore_get_k" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    try {
      result = (double)((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *)arg1)->get_k();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore_get_k
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore_set_cell_sphere(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  IMP::algebra::Sphere3D arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "RadialDistributionFunctionSingletonScore_set_cell_sphere", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore_set_cell_sphere" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__algebra__SphereDT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RadialDistributionFunctionSingletonScore_set_cell_sphere" "', argument " "2"" of type '" "IMP::algebra::Sphere3D""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RadialDistributionFunctionSingletonScore_set_cell_sphere" "', argument " "2"" of type '" "IMP::algebra::Sphere3D""'");
    } else {
      IMP::algebra::Sphere3D * temp = reinterpret_cast< IMP::algebra::Sphere3D * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->set_cell_sphere(arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore_set_cell_sphere
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore_get_cell_sphere(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::algebra::Sphere3D result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore_get_cell_sphere" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    try {
      result = ((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *)arg1)->get_cell_sphere();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore_get_cell_sphere
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::algebra::Sphere3D(result)), SWIGTYPE_p_IMP__algebra__SphereDT_3_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore_set_nucleus_sphere(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  IMP::algebra::Sphere3D arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "RadialDistributionFunctionSingletonScore_set_nucleus_sphere", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore_set_nucleus_sphere" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__algebra__SphereDT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RadialDistributionFunctionSingletonScore_set_nucleus_sphere" "', argument " "2"" of type '" "IMP::algebra::Sphere3D""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RadialDistributionFunctionSingletonScore_set_nucleus_sphere" "', argument " "2"" of type '" "IMP::algebra::Sphere3D""'");
    } else {
      IMP::algebra::Sphere3D * temp = reinterpret_cast< IMP::algebra::Sphere3D * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->set_nucleus_sphere(arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore_set_nucleus_sphere
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore_get_nucleus_sphere(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::algebra::Sphere3D result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore_get_nucleus_sphere" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    try {
      result = ((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *)arg1)->get_nucleus_sphere();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore_get_nucleus_sphere
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::algebra::Sphere3D(result)), SWIGTYPE_p_IMP__algebra__SphereDT_3_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore_set_poly_param(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  SwigValueWrapper< IMP::Vector< double > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "RadialDistributionFunctionSingletonScore_set_poly_param", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore_set_poly_param" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg2, ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_cpp_object(swig_obj[1], "RadialDistributionFunctionSingletonScore_set_poly_param", 2, "IMP::Floats", SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      (arg1)->set_poly_param(arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore_set_poly_param
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg2);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore_get_poly_param(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< IMP::Vector< double > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore_get_poly_param" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    try {
      result = ((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *)arg1)->get_poly_param();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore_get_poly_param
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::Floats, Convert< IMP::Float > >::create_python_object(ValueOrObject<IMP::Floats >::get(result), SWIGTYPE_p_double, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore_do_get_inputs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  IMP::Model *arg2 = (IMP::Model *) 0 ;
  IMP::ParticleIndexes *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  SwigValueWrapper< IMP::Vector< IMP::WeakPointer< IMP::ModelObject > > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "RadialDistributionFunctionSingletonScore_do_get_inputs", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore_do_get_inputs" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RadialDistributionFunctionSingletonScore_do_get_inputs" "', argument " "2"" of type '" "IMP::Model *""'"); 
  }
  arg2 = reinterpret_cast< IMP::Model * >(argp2);
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::ParticleIndexes, Convert< IMP::ParticleIndex > >::get_cpp_object(swig_obj[2], "RadialDistributionFunctionSingletonScore_do_get_inputs", 3, "IMP::ParticleIndexes const &", SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = ((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *)arg1)->do_get_inputs(arg2,(IMP::ParticleIndexes const &)*arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore_do_get_inputs
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::ModelObjectsTemp, Convert< IMP::ModelObject > >::create_python_object(ValueOrObject<IMP::ModelObjectsTemp >::get(result), SWIGTYPE_p_IMP__ModelObject, SWIG_POINTER_OWN);
  }
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore_get_version_info(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ::IMP::VersionInfo result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore_get_version_info" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    try {
      result = ((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *)arg1)->get_version_info();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore_get_version_info
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new ::IMP::VersionInfo(result)), SWIGTYPE_p_IMP__VersionInfo, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RadialDistributionFunctionSingletonScore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RadialDistributionFunctionSingletonScore" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    try {
      if (arg1) arg1->unref();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete delete_RadialDistributionFunctionSingletonScore
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore___str__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore___str__" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_RadialDistributionFunctionSingletonScore___str__((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore___str__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RadialDistributionFunctionSingletonScore___repr__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *arg1 = (IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RadialDistributionFunctionSingletonScore___repr__" "', argument " "1"" of type '" "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::RadialDistributionFunctionSingletonScore * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_RadialDistributionFunctionSingletonScore___repr__((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete RadialDistributionFunctionSingletonScore___repr__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RadialDistributionFunctionSingletonScore_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *RadialDistributionFunctionSingletonScore_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_is_setup__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "SecretionCounterDecorator_get_is_setup", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP::insulinsecretion::SecretionCounterDecorator::get_is_setup(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_is_setup
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_secretion(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::Int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_secretion" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      result = (IMP::Int)((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1)->get_secretion();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_secretion
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_secretion(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::Int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_set_secretion", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_secretion" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SecretionCounterDecorator_set_secretion" "', argument " "2"" of type '" "IMP::Int""'");
  } 
  arg2 = static_cast< IMP::Int >(val2);
  {
    try {
      (arg1)->set_secretion(arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_secretion
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SecretionCounterDecorator__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (IMP::insulinsecretion::SecretionCounterDecorator *)new IMP::insulinsecretion::SecretionCounterDecorator();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_SecretionCounterDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SecretionCounterDecorator__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ::IMP::Model *arg1 = (::IMP::Model *) 0 ;
  ::IMP::ParticleIndex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SecretionCounterDecorator" "', argument " "1"" of type '" "::IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< ::IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "new_SecretionCounterDecorator", 2, "::IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (IMP::insulinsecretion::SecretionCounterDecorator *)new IMP::insulinsecretion::SecretionCounterDecorator(arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_SecretionCounterDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SecretionCounterDecorator__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator *result = 0 ;
  
  if (SWIG_CheckImplicit(SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator)) SWIG_fail;
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SecretionCounterDecorator" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SecretionCounterDecorator" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  arg1 = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
  {
    try {
      result = (IMP::insulinsecretion::SecretionCounterDecorator *)new IMP::insulinsecretion::SecretionCounterDecorator((IMP::ParticleAdaptor const &)*arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_SecretionCounterDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SecretionCounterDecorator(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_SecretionCounterDecorator", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 0) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "::IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_new_SecretionCounterDecorator__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_new_SecretionCounterDecorator__SWIG_2(self, argc, argv);
    case 3:
      return _wrap_new_SecretionCounterDecorator__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_SecretionCounterDecorator'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::SecretionCounterDecorator()\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::SecretionCounterDecorator(::IMP::Model *,::IMP::ParticleIndex)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::SecretionCounterDecorator(IMP::ParticleAdaptor const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_is_setup__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  arg1 = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
  {
    try {
      result = (bool)IMP::insulinsecretion::SecretionCounterDecorator::get_is_setup((IMP::ParticleAdaptor const &)*arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_is_setup
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_is_setup(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_get_is_setup", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator_get_is_setup__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator_get_is_setup__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SecretionCounterDecorator_get_is_setup'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_is_setup(IMP::Model *,IMP::ParticleIndex)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_is_setup(IMP::ParticleAdaptor const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_show__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::PointerMember< PyOutFileAdapter > tmp2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_show" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    tmp2=new PyOutFileAdapter();
    try {
      arg2 = tmp2->set_python_file(swig_obj[1]);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    
    if (!arg2) {
      SWIG_fail;
    }
  }
  {
    try {
      ((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1)->show(*arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_show
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    try {
      tmp2->pubsync();
    } catch (...) {
      Py_DECREF(resultobj);
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_show__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_show" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      ((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1)->show();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_show
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_show(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_show", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        _v = (argv[1] != 0);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator_show__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator_show__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SecretionCounterDecorator_show'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::show(std::ostream &) const\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::show() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_setup_particle__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "SecretionCounterDecorator_setup_particle", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      result = IMP::insulinsecretion::SecretionCounterDecorator::setup_particle(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::SecretionCounterDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_setup_particle__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor arg1 ;
  IMP::Int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'");
    } else {
      IMP::ParticleAdaptor * temp = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "2"" of type '" "IMP::Int""'");
  } 
  arg2 = static_cast< IMP::Int >(val2);
  {
    try {
      result = IMP::insulinsecretion::SecretionCounterDecorator::setup_particle(SWIG_STD_MOVE(arg1),arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::SecretionCounterDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_setup_particle__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  IMP::insulinsecretion::SecretionCounterDecorator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "SecretionCounterDecorator_setup_particle", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "3"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "3"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'");
    } else {
      IMP::insulinsecretion::SecretionCounterDecorator * temp = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      result = IMP::insulinsecretion::SecretionCounterDecorator::setup_particle(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::SecretionCounterDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_setup_particle__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor arg1 ;
  IMP::insulinsecretion::SecretionCounterDecorator arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'");
    } else {
      IMP::ParticleAdaptor * temp = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_setup_particle" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'");
    } else {
      IMP::insulinsecretion::SecretionCounterDecorator * temp = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP::insulinsecretion::SecretionCounterDecorator::setup_particle(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::SecretionCounterDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_setup_particle(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_setup_particle", 0, 3, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator_setup_particle__SWIG_3(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator_setup_particle__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator_setup_particle__SWIG_3(self, argc, argv);
    case 4:
      return _wrap_SecretionCounterDecorator_setup_particle__SWIG_1(self, argc, argv);
    case 5:
      return _wrap_SecretionCounterDecorator_setup_particle__SWIG_2(self, argc, argv);
    case 6:
      return _wrap_SecretionCounterDecorator_setup_particle__SWIG_0(self, argc, argv);
    case 7:
      return _wrap_SecretionCounterDecorator_setup_particle__SWIG_2(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SecretionCounterDecorator_setup_particle'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::setup_particle(IMP::Model *,IMP::ParticleIndex,IMP::Int)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::setup_particle(IMP::ParticleAdaptor,IMP::Int)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::setup_particle(IMP::Model *,IMP::ParticleIndex,IMP::insulinsecretion::SecretionCounterDecorator)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::setup_particle(IMP::ParticleAdaptor,IMP::insulinsecretion::SecretionCounterDecorator)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_secretion_key(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::IntKey result;
  
  if (!SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_get_secretion_key", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = IMP::insulinsecretion::SecretionCounterDecorator::get_secretion_key();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_secretion_key
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::IntKey(result)), SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  ecode4 = SWIG_AsVal_bool(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2),arg3,arg4);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Float result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Float)IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_set_value" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_0(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::IntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Int)IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::IntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_set_value" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_1(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  SwigValueWrapper< IMP::Vector< double > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_cpp_object(swig_obj[2], "SecretionCounterDecorator_add_attribute", 3, "IMP::Floats", SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< IMP::Vector< double > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::Floats, Convert< IMP::Float > >::create_python_object(ValueOrObject<IMP::Floats >::get(result), SWIGTYPE_p_double, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  SwigValueWrapper< IMP::Vector< double > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_cpp_object(swig_obj[2], "SecretionCounterDecorator_set_value", 3, "IMP::Floats", SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_2(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  SwigValueWrapper< IMP::Vector< int > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_cpp_object(swig_obj[2], "SecretionCounterDecorator_add_attribute", 3, "IMP::Ints", SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< IMP::Vector< int > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::Ints, Convert< IMP::Int > >::create_python_object(ValueOrObject<IMP::Ints >::get(result), SWIGTYPE_p_int, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  SwigValueWrapper< IMP::Vector< int > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_cpp_object(swig_obj[2], "SecretionCounterDecorator_set_value", 3, "IMP::Ints", SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_3(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::StringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::String result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::StringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SecretionCounterDecorator_set_value" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_4(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  IMP::Particle *arg3 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::Particle >::get_cpp_object(swig_obj[2], "SecretionCounterDecorator_add_attribute", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Particle *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Particle *)IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__Particle, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  IMP::Particle *arg3 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::Particle >::get_cpp_object(swig_obj[2], "SecretionCounterDecorator_set_value", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_5(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  IMP::Object *arg3 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Object *""'"); 
  }
  arg3 = reinterpret_cast< IMP::Object * >(argp3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Object *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Object *)IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__Object, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  IMP::Object *arg3 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SecretionCounterDecorator_set_value" "', argument " "3"" of type '" "IMP::Object *""'"); 
  }
  arg3 = reinterpret_cast< IMP::Object * >(argp3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_6(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Float result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Float)IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_set_value" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_7(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Int)IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_set_value" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_8(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::String result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SecretionCounterDecorator_set_value" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_9(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute__SWIG_11(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  IMP::ParticleIndex arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[2],
        "SecretionCounterDecorator_add_attribute", 3, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_attribute__SWIG_11(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_add_attribute", 0, 4, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
    if (argc == 4) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_bool(argv[3], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 23;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_23:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_2(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_3(self, argc, argv);
    case 4:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_4(self, argc, argv);
    case 5:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_5(self, argc, argv);
    case 6:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_6(self, argc, argv);
    case 7:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_7(self, argc, argv);
    case 8:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_8(self, argc, argv);
    case 9:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_9(self, argc, argv);
    case 10:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_10(self, argc, argv);
    case 11:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_11(self, argc, argv);
    case 12:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_1(self, argc, argv);
    case 13:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_2(self, argc, argv);
    case 14:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_3(self, argc, argv);
    case 15:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_4(self, argc, argv);
    case 16:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_5(self, argc, argv);
    case 17:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_6(self, argc, argv);
    case 18:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_7(self, argc, argv);
    case 19:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_8(self, argc, argv);
    case 20:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_9(self, argc, argv);
    case 21:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_10(self, argc, argv);
    case 22:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_11(self, argc, argv);
    case 23:
      return _wrap_SecretionCounterDecorator_add_attribute__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SecretionCounterDecorator_add_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::FloatKey,IMP::Float,bool)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::FloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::IntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::FloatsKey,IMP::Floats)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::IntsKey,IMP::Ints)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::StringKey,IMP::String)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::ParticleIndexKey,IMP::Particle *)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::ObjectKey,IMP::Object *)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::SparseFloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::SparseIntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::SparseStringKey,IMP::String)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::add_attribute(IMP::SparseParticleIndexKey,IMP::ParticleIndex)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::ParticleIndex result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_SecretionCounterDecorator_get_value__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = Convert<IMP::ParticleIndex >::create_python_object(result, SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_get_value", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_SecretionCounterDecorator_get_value__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SecretionCounterDecorator_get_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::IntKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::StringKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::get_value(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  IMP::ParticleIndex arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[2],
        "SecretionCounterDecorator_set_value", 3, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_value__SWIG_10(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_set_value", 0, 3, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_SecretionCounterDecorator_set_value__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SecretionCounterDecorator_set_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::FloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::IntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::FloatsKey,IMP::Floats)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::IntsKey,IMP::Ints)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::StringKey,IMP::String)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::ParticleIndexKey,IMP::Particle *)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::ObjectKey,IMP::Object *)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::SparseFloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::SparseIntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::SparseStringKey,IMP::String)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::set_value(IMP::SparseParticleIndexKey,IMP::ParticleIndex)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_remove_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_remove_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_remove_attribute", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_SecretionCounterDecorator_remove_attribute__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SecretionCounterDecorator_remove_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::IntKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::StringKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::remove_attribute(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_has_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_has_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_has_attribute", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_SecretionCounterDecorator_has_attribute__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SecretionCounterDecorator_has_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::IntKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::StringKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::SecretionCounterDecorator::has_attribute(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_derivative(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_get_derivative", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_derivative" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (double)IMP_insulinsecretion_SecretionCounterDecorator_get_derivative(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_derivative
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_name" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_SecretionCounterDecorator_get_name(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_name
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_clear_caches(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_clear_caches" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_clear_caches(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_clear_caches
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_set_name", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_name" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SecretionCounterDecorator_set_name" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_name(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_name
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_check_level(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::CheckLevel arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_set_check_level", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_check_level" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__CheckLevel,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_check_level" "', argument " "2"" of type '" "IMP::CheckLevel""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_check_level" "', argument " "2"" of type '" "IMP::CheckLevel""'");
    } else {
      IMP::CheckLevel * temp = reinterpret_cast< IMP::CheckLevel * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_check_level(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_check_level
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_add_to_derivative(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  double arg3 ;
  IMP::DerivativeAccumulator arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_add_to_derivative", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_add_to_derivative" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_add_to_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_to_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_add_to_derivative" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4, SWIGTYPE_p_IMP__DerivativeAccumulator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SecretionCounterDecorator_add_to_derivative" "', argument " "4"" of type '" "IMP::DerivativeAccumulator""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_add_to_derivative" "', argument " "4"" of type '" "IMP::DerivativeAccumulator""'");
    } else {
      IMP::DerivativeAccumulator * temp = reinterpret_cast< IMP::DerivativeAccumulator * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_add_to_derivative(arg1,SWIG_STD_MOVE(arg2),arg3,SWIG_STD_MOVE(arg4));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_add_to_derivative
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_set_is_optimized(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_set_is_optimized", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_set_is_optimized" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_set_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_set_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_bool(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SecretionCounterDecorator_set_is_optimized" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator_set_is_optimized(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_set_is_optimized
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_is_optimized(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator_get_is_optimized", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_is_optimized" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator_get_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator_get_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator_get_is_optimized(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_is_optimized
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator_get_check_level(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::CheckLevel result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator_get_check_level" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_SecretionCounterDecorator_get_check_level(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator_get_check_level
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::CheckLevel(result)), SWIGTYPE_p_IMP__CheckLevel, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___eq____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___eq__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator___eq__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator___eq__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'");
    } else {
      IMP::insulinsecretion::SecretionCounterDecorator * temp = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___eq____SWIG_0((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___eq__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___ne____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___ne__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator___ne__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator___ne__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'");
    } else {
      IMP::insulinsecretion::SecretionCounterDecorator * temp = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___ne____SWIG_0((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___ne__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___le____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___le__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator___le__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator___le__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'");
    } else {
      IMP::insulinsecretion::SecretionCounterDecorator * temp = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___le____SWIG_0((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___le__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___lt____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___lt__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator___lt__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator___lt__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'");
    } else {
      IMP::insulinsecretion::SecretionCounterDecorator * temp = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___lt____SWIG_0((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___lt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___ge____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___ge__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator___ge__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator___ge__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'");
    } else {
      IMP::insulinsecretion::SecretionCounterDecorator * temp = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___ge____SWIG_0((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___ge__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___gt____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::insulinsecretion::SecretionCounterDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___gt__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SecretionCounterDecorator___gt__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SecretionCounterDecorator___gt__" "', argument " "2"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator""'");
    } else {
      IMP::insulinsecretion::SecretionCounterDecorator * temp = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___gt____SWIG_0((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___gt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___eq____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___eq__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "SecretionCounterDecorator___eq__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___eq____SWIG_1((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___eq__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___eq__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator___eq__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator___eq____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator___eq____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator___eq____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___ne____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___ne__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "SecretionCounterDecorator___ne__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___ne____SWIG_1((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___ne__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___ne__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator___ne__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator___ne____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator___ne____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator___ne____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___le____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___le__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "SecretionCounterDecorator___le__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___le____SWIG_1((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___le__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___le__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator___le__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator___le____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator___le____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator___le____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___lt____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___lt__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "SecretionCounterDecorator___lt__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___lt____SWIG_1((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___lt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___lt__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator___lt__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator___lt____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator___lt____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator___lt____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___ge____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___ge__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "SecretionCounterDecorator___ge__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___ge____SWIG_1((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___ge__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___ge__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator___ge__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator___ge____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator___ge____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator___ge____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___gt____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___gt__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "SecretionCounterDecorator___gt__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_SecretionCounterDecorator___gt____SWIG_1((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___gt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___gt__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator___gt__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_SecretionCounterDecorator___gt____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_SecretionCounterDecorator___gt____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_SecretionCounterDecorator___gt____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___hash__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___hash__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_SecretionCounterDecorator___hash__((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___hash__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = PyInt_FromLong(static_cast<long>(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___str__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___str__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_SecretionCounterDecorator___str__((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___str__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator___repr__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator___repr__" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_SecretionCounterDecorator___repr__((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator___repr__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator__get_as_binary(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator__get_as_binary" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      result = (PyObject *)IMP_insulinsecretion_SecretionCounterDecorator__get_as_binary((IMP::insulinsecretion::SecretionCounterDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator__get_as_binary
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SecretionCounterDecorator__set_from_binary(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SecretionCounterDecorator__set_from_binary", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SecretionCounterDecorator__set_from_binary" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  arg2 = swig_obj[1];
  {
    try {
      IMP_insulinsecretion_SecretionCounterDecorator__set_from_binary(arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete SecretionCounterDecorator__set_from_binary
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SecretionCounterDecorator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::SecretionCounterDecorator *arg1 = (IMP::insulinsecretion::SecretionCounterDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SecretionCounterDecorator" "', argument " "1"" of type '" "IMP::insulinsecretion::SecretionCounterDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::SecretionCounterDecorator * >(argp1);
  {
    try {
      delete arg1;
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete delete_SecretionCounterDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SecretionCounterDecorator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_IMP__insulinsecretion__SecretionCounterDecorator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SecretionCounterDecorator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_is_setup__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "MaturationStateDecorator_get_is_setup", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP::insulinsecretion::MaturationStateDecorator::get_is_setup(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_is_setup
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_state(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::Int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_state" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      result = (IMP::Int)((IMP::insulinsecretion::MaturationStateDecorator const *)arg1)->get_state();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_state
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_state(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::Int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_set_state", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_state" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MaturationStateDecorator_set_state" "', argument " "2"" of type '" "IMP::Int""'");
  } 
  arg2 = static_cast< IMP::Int >(val2);
  {
    try {
      (arg1)->set_state(arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_state
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MaturationStateDecorator__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (IMP::insulinsecretion::MaturationStateDecorator *)new IMP::insulinsecretion::MaturationStateDecorator();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_MaturationStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MaturationStateDecorator__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ::IMP::Model *arg1 = (::IMP::Model *) 0 ;
  ::IMP::ParticleIndex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::insulinsecretion::MaturationStateDecorator *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MaturationStateDecorator" "', argument " "1"" of type '" "::IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< ::IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "new_MaturationStateDecorator", 2, "::IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (IMP::insulinsecretion::MaturationStateDecorator *)new IMP::insulinsecretion::MaturationStateDecorator(arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_MaturationStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MaturationStateDecorator__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::insulinsecretion::MaturationStateDecorator *result = 0 ;
  
  if (SWIG_CheckImplicit(SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator)) SWIG_fail;
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MaturationStateDecorator" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaturationStateDecorator" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  arg1 = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
  {
    try {
      result = (IMP::insulinsecretion::MaturationStateDecorator *)new IMP::insulinsecretion::MaturationStateDecorator((IMP::ParticleAdaptor const &)*arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_MaturationStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MaturationStateDecorator(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_MaturationStateDecorator", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 0) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "::IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_new_MaturationStateDecorator__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_new_MaturationStateDecorator__SWIG_2(self, argc, argv);
    case 3:
      return _wrap_new_MaturationStateDecorator__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_MaturationStateDecorator'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::MaturationStateDecorator()\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::MaturationStateDecorator(::IMP::Model *,::IMP::ParticleIndex)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::MaturationStateDecorator(IMP::ParticleAdaptor const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_is_setup__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  arg1 = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
  {
    try {
      result = (bool)IMP::insulinsecretion::MaturationStateDecorator::get_is_setup((IMP::ParticleAdaptor const &)*arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_is_setup
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_is_setup(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_get_is_setup", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator_get_is_setup__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator_get_is_setup__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MaturationStateDecorator_get_is_setup'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_is_setup(IMP::Model *,IMP::ParticleIndex)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_is_setup(IMP::ParticleAdaptor const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_show__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::PointerMember< PyOutFileAdapter > tmp2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_show" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    tmp2=new PyOutFileAdapter();
    try {
      arg2 = tmp2->set_python_file(swig_obj[1]);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    
    if (!arg2) {
      SWIG_fail;
    }
  }
  {
    try {
      ((IMP::insulinsecretion::MaturationStateDecorator const *)arg1)->show(*arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_show
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    try {
      tmp2->pubsync();
    } catch (...) {
      Py_DECREF(resultobj);
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_show__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_show" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      ((IMP::insulinsecretion::MaturationStateDecorator const *)arg1)->show();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_show
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_show(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_show", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        _v = (argv[1] != 0);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator_show__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator_show__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MaturationStateDecorator_show'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::show(std::ostream &) const\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::show() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_setup_particle__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  IMP::insulinsecretion::MaturationStateDecorator result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "MaturationStateDecorator_setup_particle", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_setup_particle" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      result = IMP::insulinsecretion::MaturationStateDecorator::setup_particle(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::MaturationStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_setup_particle__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor arg1 ;
  IMP::Int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  IMP::insulinsecretion::MaturationStateDecorator result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'");
    } else {
      IMP::ParticleAdaptor * temp = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MaturationStateDecorator_setup_particle" "', argument " "2"" of type '" "IMP::Int""'");
  } 
  arg2 = static_cast< IMP::Int >(val2);
  {
    try {
      result = IMP::insulinsecretion::MaturationStateDecorator::setup_particle(SWIG_STD_MOVE(arg1),arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::MaturationStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_setup_particle__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  IMP::insulinsecretion::MaturationStateDecorator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  IMP::insulinsecretion::MaturationStateDecorator result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "MaturationStateDecorator_setup_particle", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MaturationStateDecorator_setup_particle" "', argument " "3"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_setup_particle" "', argument " "3"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'");
    } else {
      IMP::insulinsecretion::MaturationStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      result = IMP::insulinsecretion::MaturationStateDecorator::setup_particle(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::MaturationStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_setup_particle__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor arg1 ;
  IMP::insulinsecretion::MaturationStateDecorator arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::insulinsecretion::MaturationStateDecorator result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'");
    } else {
      IMP::ParticleAdaptor * temp = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_setup_particle" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_setup_particle" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'");
    } else {
      IMP::insulinsecretion::MaturationStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP::insulinsecretion::MaturationStateDecorator::setup_particle(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::MaturationStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_setup_particle(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_setup_particle", 0, 3, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator_setup_particle__SWIG_3(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator_setup_particle__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator_setup_particle__SWIG_3(self, argc, argv);
    case 4:
      return _wrap_MaturationStateDecorator_setup_particle__SWIG_1(self, argc, argv);
    case 5:
      return _wrap_MaturationStateDecorator_setup_particle__SWIG_2(self, argc, argv);
    case 6:
      return _wrap_MaturationStateDecorator_setup_particle__SWIG_0(self, argc, argv);
    case 7:
      return _wrap_MaturationStateDecorator_setup_particle__SWIG_2(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MaturationStateDecorator_setup_particle'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::setup_particle(IMP::Model *,IMP::ParticleIndex,IMP::Int)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::setup_particle(IMP::ParticleAdaptor,IMP::Int)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::setup_particle(IMP::Model *,IMP::ParticleIndex,IMP::insulinsecretion::MaturationStateDecorator)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::setup_particle(IMP::ParticleAdaptor,IMP::insulinsecretion::MaturationStateDecorator)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_state_key(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::IntKey result;
  
  if (!SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_get_state_key", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = IMP::insulinsecretion::MaturationStateDecorator::get_state_key();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_state_key
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::IntKey(result)), SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  ecode4 = SWIG_AsVal_bool(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2),arg3,arg4);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Float result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Float)IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_0(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Int)IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_1(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  SwigValueWrapper< IMP::Vector< double > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_cpp_object(swig_obj[2], "MaturationStateDecorator_add_attribute", 3, "IMP::Floats", SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< IMP::Vector< double > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::Floats, Convert< IMP::Float > >::create_python_object(ValueOrObject<IMP::Floats >::get(result), SWIGTYPE_p_double, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  SwigValueWrapper< IMP::Vector< double > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_cpp_object(swig_obj[2], "MaturationStateDecorator_set_value", 3, "IMP::Floats", SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_2(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  SwigValueWrapper< IMP::Vector< int > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_cpp_object(swig_obj[2], "MaturationStateDecorator_add_attribute", 3, "IMP::Ints", SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< IMP::Vector< int > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::Ints, Convert< IMP::Int > >::create_python_object(ValueOrObject<IMP::Ints >::get(result), SWIGTYPE_p_int, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  SwigValueWrapper< IMP::Vector< int > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_cpp_object(swig_obj[2], "MaturationStateDecorator_set_value", 3, "IMP::Ints", SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_3(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::String result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "MaturationStateDecorator_set_value" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_4(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  IMP::Particle *arg3 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::Particle >::get_cpp_object(swig_obj[2], "MaturationStateDecorator_add_attribute", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Particle *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Particle *)IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__Particle, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  IMP::Particle *arg3 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::Particle >::get_cpp_object(swig_obj[2], "MaturationStateDecorator_set_value", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_5(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  IMP::Object *arg3 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Object *""'"); 
  }
  arg3 = reinterpret_cast< IMP::Object * >(argp3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Object *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Object *)IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__Object, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  IMP::Object *arg3 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MaturationStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Object *""'"); 
  }
  arg3 = reinterpret_cast< IMP::Object * >(argp3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_6(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Float result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Float)IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_7(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Int)IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_8(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::String result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "MaturationStateDecorator_set_value" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_9(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute__SWIG_11(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  IMP::ParticleIndex arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[2],
        "MaturationStateDecorator_add_attribute", 3, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_attribute__SWIG_11(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_add_attribute", 0, 4, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
    if (argc == 4) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_bool(argv[3], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 23;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_23:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_2(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_3(self, argc, argv);
    case 4:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_4(self, argc, argv);
    case 5:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_5(self, argc, argv);
    case 6:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_6(self, argc, argv);
    case 7:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_7(self, argc, argv);
    case 8:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_8(self, argc, argv);
    case 9:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_9(self, argc, argv);
    case 10:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_10(self, argc, argv);
    case 11:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_11(self, argc, argv);
    case 12:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_1(self, argc, argv);
    case 13:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_2(self, argc, argv);
    case 14:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_3(self, argc, argv);
    case 15:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_4(self, argc, argv);
    case 16:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_5(self, argc, argv);
    case 17:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_6(self, argc, argv);
    case 18:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_7(self, argc, argv);
    case 19:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_8(self, argc, argv);
    case 20:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_9(self, argc, argv);
    case 21:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_10(self, argc, argv);
    case 22:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_11(self, argc, argv);
    case 23:
      return _wrap_MaturationStateDecorator_add_attribute__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MaturationStateDecorator_add_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::FloatKey,IMP::Float,bool)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::FloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::IntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::FloatsKey,IMP::Floats)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::IntsKey,IMP::Ints)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::StringKey,IMP::String)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::ParticleIndexKey,IMP::Particle *)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::ObjectKey,IMP::Object *)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::SparseFloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::SparseIntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::SparseStringKey,IMP::String)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::add_attribute(IMP::SparseParticleIndexKey,IMP::ParticleIndex)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::ParticleIndex result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_MaturationStateDecorator_get_value__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = Convert<IMP::ParticleIndex >::create_python_object(result, SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_get_value", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator_get_value__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator_get_value__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator_get_value__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_MaturationStateDecorator_get_value__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_MaturationStateDecorator_get_value__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_MaturationStateDecorator_get_value__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_MaturationStateDecorator_get_value__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_MaturationStateDecorator_get_value__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_MaturationStateDecorator_get_value__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_MaturationStateDecorator_get_value__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_MaturationStateDecorator_get_value__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_MaturationStateDecorator_get_value__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_MaturationStateDecorator_get_value__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_MaturationStateDecorator_get_value__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_MaturationStateDecorator_get_value__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_MaturationStateDecorator_get_value__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_MaturationStateDecorator_get_value__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_MaturationStateDecorator_get_value__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_MaturationStateDecorator_get_value__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_MaturationStateDecorator_get_value__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_MaturationStateDecorator_get_value__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_MaturationStateDecorator_get_value__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MaturationStateDecorator_get_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::IntKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::StringKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::get_value(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  IMP::ParticleIndex arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[2],
        "MaturationStateDecorator_set_value", 3, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_value__SWIG_10(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_set_value", 0, 3, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator_set_value__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator_set_value__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator_set_value__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_MaturationStateDecorator_set_value__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_MaturationStateDecorator_set_value__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_MaturationStateDecorator_set_value__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_MaturationStateDecorator_set_value__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_MaturationStateDecorator_set_value__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_MaturationStateDecorator_set_value__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_MaturationStateDecorator_set_value__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_MaturationStateDecorator_set_value__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_MaturationStateDecorator_set_value__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_MaturationStateDecorator_set_value__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_MaturationStateDecorator_set_value__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_MaturationStateDecorator_set_value__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_MaturationStateDecorator_set_value__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_MaturationStateDecorator_set_value__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_MaturationStateDecorator_set_value__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_MaturationStateDecorator_set_value__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_MaturationStateDecorator_set_value__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_MaturationStateDecorator_set_value__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_MaturationStateDecorator_set_value__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MaturationStateDecorator_set_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::FloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::IntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::FloatsKey,IMP::Floats)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::IntsKey,IMP::Ints)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::StringKey,IMP::String)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::ParticleIndexKey,IMP::Particle *)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::ObjectKey,IMP::Object *)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::SparseFloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::SparseIntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::SparseStringKey,IMP::String)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::set_value(IMP::SparseParticleIndexKey,IMP::ParticleIndex)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_remove_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_remove_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_remove_attribute", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_MaturationStateDecorator_remove_attribute__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MaturationStateDecorator_remove_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::IntKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::StringKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::remove_attribute(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_has_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_has_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_has_attribute", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_MaturationStateDecorator_has_attribute__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MaturationStateDecorator_has_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::IntKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::StringKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::MaturationStateDecorator::has_attribute(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_derivative(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_get_derivative", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_derivative" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (double)IMP_insulinsecretion_MaturationStateDecorator_get_derivative(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_derivative
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_name" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_MaturationStateDecorator_get_name(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_name
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_clear_caches(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_clear_caches" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_clear_caches(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_clear_caches
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_set_name", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_name" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "MaturationStateDecorator_set_name" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_name(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_name
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_check_level(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::CheckLevel arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_set_check_level", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_check_level" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__CheckLevel,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_check_level" "', argument " "2"" of type '" "IMP::CheckLevel""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_check_level" "', argument " "2"" of type '" "IMP::CheckLevel""'");
    } else {
      IMP::CheckLevel * temp = reinterpret_cast< IMP::CheckLevel * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_check_level(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_check_level
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_add_to_derivative(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  double arg3 ;
  IMP::DerivativeAccumulator arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_add_to_derivative", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_add_to_derivative" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_add_to_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_to_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_add_to_derivative" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4, SWIGTYPE_p_IMP__DerivativeAccumulator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MaturationStateDecorator_add_to_derivative" "', argument " "4"" of type '" "IMP::DerivativeAccumulator""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_add_to_derivative" "', argument " "4"" of type '" "IMP::DerivativeAccumulator""'");
    } else {
      IMP::DerivativeAccumulator * temp = reinterpret_cast< IMP::DerivativeAccumulator * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_add_to_derivative(arg1,SWIG_STD_MOVE(arg2),arg3,SWIG_STD_MOVE(arg4));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_add_to_derivative
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_set_is_optimized(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_set_is_optimized", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_set_is_optimized" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_set_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_set_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_bool(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MaturationStateDecorator_set_is_optimized" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator_set_is_optimized(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_set_is_optimized
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_is_optimized(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "MaturationStateDecorator_get_is_optimized", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_is_optimized" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator_get_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator_get_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator_get_is_optimized(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_is_optimized
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator_get_check_level(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::CheckLevel result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator_get_check_level" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_MaturationStateDecorator_get_check_level(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator_get_check_level
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::CheckLevel(result)), SWIGTYPE_p_IMP__CheckLevel, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___eq____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::insulinsecretion::MaturationStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___eq__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator___eq__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator___eq__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'");
    } else {
      IMP::insulinsecretion::MaturationStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___eq____SWIG_0((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___eq__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___ne____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::insulinsecretion::MaturationStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___ne__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator___ne__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator___ne__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'");
    } else {
      IMP::insulinsecretion::MaturationStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___ne____SWIG_0((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___ne__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___le____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::insulinsecretion::MaturationStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___le__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator___le__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator___le__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'");
    } else {
      IMP::insulinsecretion::MaturationStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___le____SWIG_0((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___le__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___lt____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::insulinsecretion::MaturationStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___lt__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator___lt__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator___lt__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'");
    } else {
      IMP::insulinsecretion::MaturationStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___lt____SWIG_0((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___lt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___ge____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::insulinsecretion::MaturationStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___ge__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator___ge__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator___ge__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'");
    } else {
      IMP::insulinsecretion::MaturationStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___ge____SWIG_0((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___ge__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___gt____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::insulinsecretion::MaturationStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___gt__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MaturationStateDecorator___gt__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MaturationStateDecorator___gt__" "', argument " "2"" of type '" "IMP::insulinsecretion::MaturationStateDecorator""'");
    } else {
      IMP::insulinsecretion::MaturationStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___gt____SWIG_0((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___gt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___eq____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___eq__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "MaturationStateDecorator___eq__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___eq____SWIG_1((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___eq__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___eq__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator___eq__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator___eq____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator___eq____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator___eq____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___ne____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___ne__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "MaturationStateDecorator___ne__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___ne____SWIG_1((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___ne__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___ne__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator___ne__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator___ne____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator___ne____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator___ne____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___le____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___le__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "MaturationStateDecorator___le__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___le____SWIG_1((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___le__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___le__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator___le__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator___le____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator___le____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator___le____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___lt____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___lt__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "MaturationStateDecorator___lt__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___lt____SWIG_1((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___lt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___lt__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator___lt__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator___lt____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator___lt____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator___lt____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___ge____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___ge__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "MaturationStateDecorator___ge__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___ge____SWIG_1((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___ge__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___ge__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator___ge__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator___ge____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator___ge____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator___ge____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___gt____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___gt__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "MaturationStateDecorator___gt__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_MaturationStateDecorator___gt____SWIG_1((IMP::insulinsecretion::MaturationStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___gt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___gt__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MaturationStateDecorator___gt__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_MaturationStateDecorator___gt____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_MaturationStateDecorator___gt____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_MaturationStateDecorator___gt____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___hash__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___hash__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_MaturationStateDecorator___hash__((IMP::insulinsecretion::MaturationStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___hash__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = PyInt_FromLong(static_cast<long>(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___str__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___str__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_MaturationStateDecorator___str__((IMP::insulinsecretion::MaturationStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___str__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator___repr__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator___repr__" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_MaturationStateDecorator___repr__((IMP::insulinsecretion::MaturationStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator___repr__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator__get_as_binary(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator__get_as_binary" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      result = (PyObject *)IMP_insulinsecretion_MaturationStateDecorator__get_as_binary((IMP::insulinsecretion::MaturationStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator__get_as_binary
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MaturationStateDecorator__set_from_binary(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "MaturationStateDecorator__set_from_binary", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MaturationStateDecorator__set_from_binary" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  arg2 = swig_obj[1];
  {
    try {
      IMP_insulinsecretion_MaturationStateDecorator__set_from_binary(arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete MaturationStateDecorator__set_from_binary
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MaturationStateDecorator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::MaturationStateDecorator *arg1 = (IMP::insulinsecretion::MaturationStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MaturationStateDecorator" "', argument " "1"" of type '" "IMP::insulinsecretion::MaturationStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::MaturationStateDecorator * >(argp1);
  {
    try {
      delete arg1;
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete delete_MaturationStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MaturationStateDecorator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_IMP__insulinsecretion__MaturationStateDecorator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MaturationStateDecorator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_is_setup__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "DockingStateDecorator_get_is_setup", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP::insulinsecretion::DockingStateDecorator::get_is_setup(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_is_setup
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_dstate(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::Int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_dstate" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      result = (IMP::Int)((IMP::insulinsecretion::DockingStateDecorator const *)arg1)->get_dstate();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_dstate
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_dstate(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::Int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DockingStateDecorator_set_dstate", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_dstate" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DockingStateDecorator_set_dstate" "', argument " "2"" of type '" "IMP::Int""'");
  } 
  arg2 = static_cast< IMP::Int >(val2);
  {
    try {
      (arg1)->set_dstate(arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_dstate
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DockingStateDecorator__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (IMP::insulinsecretion::DockingStateDecorator *)new IMP::insulinsecretion::DockingStateDecorator();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_DockingStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DockingStateDecorator__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ::IMP::Model *arg1 = (::IMP::Model *) 0 ;
  ::IMP::ParticleIndex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::insulinsecretion::DockingStateDecorator *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DockingStateDecorator" "', argument " "1"" of type '" "::IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< ::IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "new_DockingStateDecorator", 2, "::IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (IMP::insulinsecretion::DockingStateDecorator *)new IMP::insulinsecretion::DockingStateDecorator(arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_DockingStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DockingStateDecorator__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::insulinsecretion::DockingStateDecorator *result = 0 ;
  
  if (SWIG_CheckImplicit(SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator)) SWIG_fail;
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DockingStateDecorator" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DockingStateDecorator" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  arg1 = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
  {
    try {
      result = (IMP::insulinsecretion::DockingStateDecorator *)new IMP::insulinsecretion::DockingStateDecorator((IMP::ParticleAdaptor const &)*arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_DockingStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DockingStateDecorator(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_DockingStateDecorator", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 0) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "::IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_new_DockingStateDecorator__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_new_DockingStateDecorator__SWIG_2(self, argc, argv);
    case 3:
      return _wrap_new_DockingStateDecorator__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_DockingStateDecorator'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::DockingStateDecorator::DockingStateDecorator()\n"
    "    IMP::insulinsecretion::DockingStateDecorator::DockingStateDecorator(::IMP::Model *,::IMP::ParticleIndex)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::DockingStateDecorator(IMP::ParticleAdaptor const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_is_setup__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  arg1 = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
  {
    try {
      result = (bool)IMP::insulinsecretion::DockingStateDecorator::get_is_setup((IMP::ParticleAdaptor const &)*arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_is_setup
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_is_setup(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator_get_is_setup", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator_get_is_setup__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator_get_is_setup__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DockingStateDecorator_get_is_setup'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_is_setup(IMP::Model *,IMP::ParticleIndex)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_is_setup(IMP::ParticleAdaptor const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_show__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::PointerMember< PyOutFileAdapter > tmp2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_show" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    tmp2=new PyOutFileAdapter();
    try {
      arg2 = tmp2->set_python_file(swig_obj[1]);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    
    if (!arg2) {
      SWIG_fail;
    }
  }
  {
    try {
      ((IMP::insulinsecretion::DockingStateDecorator const *)arg1)->show(*arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_show
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    try {
      tmp2->pubsync();
    } catch (...) {
      Py_DECREF(resultobj);
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_show__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_show" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      ((IMP::insulinsecretion::DockingStateDecorator const *)arg1)->show();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_show
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_show(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator_show", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        _v = (argv[1] != 0);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator_show__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator_show__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DockingStateDecorator_show'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::DockingStateDecorator::show(std::ostream &) const\n"
    "    IMP::insulinsecretion::DockingStateDecorator::show() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_setup_particle__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  IMP::insulinsecretion::DockingStateDecorator result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "DockingStateDecorator_setup_particle", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_setup_particle" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      result = IMP::insulinsecretion::DockingStateDecorator::setup_particle(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::DockingStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_setup_particle__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor arg1 ;
  IMP::Int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  IMP::insulinsecretion::DockingStateDecorator result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'");
    } else {
      IMP::ParticleAdaptor * temp = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DockingStateDecorator_setup_particle" "', argument " "2"" of type '" "IMP::Int""'");
  } 
  arg2 = static_cast< IMP::Int >(val2);
  {
    try {
      result = IMP::insulinsecretion::DockingStateDecorator::setup_particle(SWIG_STD_MOVE(arg1),arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::DockingStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_setup_particle__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  IMP::insulinsecretion::DockingStateDecorator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  IMP::insulinsecretion::DockingStateDecorator result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "DockingStateDecorator_setup_particle", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DockingStateDecorator_setup_particle" "', argument " "3"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_setup_particle" "', argument " "3"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'");
    } else {
      IMP::insulinsecretion::DockingStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      result = IMP::insulinsecretion::DockingStateDecorator::setup_particle(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::DockingStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_setup_particle__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor arg1 ;
  IMP::insulinsecretion::DockingStateDecorator arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::insulinsecretion::DockingStateDecorator result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'");
    } else {
      IMP::ParticleAdaptor * temp = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_setup_particle" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_setup_particle" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'");
    } else {
      IMP::insulinsecretion::DockingStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP::insulinsecretion::DockingStateDecorator::setup_particle(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::DockingStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_setup_particle(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator_setup_particle", 0, 3, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator_setup_particle__SWIG_3(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator_setup_particle__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator_setup_particle__SWIG_3(self, argc, argv);
    case 4:
      return _wrap_DockingStateDecorator_setup_particle__SWIG_1(self, argc, argv);
    case 5:
      return _wrap_DockingStateDecorator_setup_particle__SWIG_2(self, argc, argv);
    case 6:
      return _wrap_DockingStateDecorator_setup_particle__SWIG_0(self, argc, argv);
    case 7:
      return _wrap_DockingStateDecorator_setup_particle__SWIG_2(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DockingStateDecorator_setup_particle'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::DockingStateDecorator::setup_particle(IMP::Model *,IMP::ParticleIndex,IMP::Int)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::setup_particle(IMP::ParticleAdaptor,IMP::Int)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::setup_particle(IMP::Model *,IMP::ParticleIndex,IMP::insulinsecretion::DockingStateDecorator)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::setup_particle(IMP::ParticleAdaptor,IMP::insulinsecretion::DockingStateDecorator)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_dstate_key(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::IntKey result;
  
  if (!SWIG_Python_UnpackTuple(args, "DockingStateDecorator_get_dstate_key", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = IMP::insulinsecretion::DockingStateDecorator::get_dstate_key();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_dstate_key
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::IntKey(result)), SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  ecode4 = SWIG_AsVal_bool(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DockingStateDecorator_add_attribute" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2),arg3,arg4);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Float result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Float)IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_0(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Int)IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_1(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  SwigValueWrapper< IMP::Vector< double > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_cpp_object(swig_obj[2], "DockingStateDecorator_add_attribute", 3, "IMP::Floats", SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< IMP::Vector< double > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::Floats, Convert< IMP::Float > >::create_python_object(ValueOrObject<IMP::Floats >::get(result), SWIGTYPE_p_double, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  SwigValueWrapper< IMP::Vector< double > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_cpp_object(swig_obj[2], "DockingStateDecorator_set_value", 3, "IMP::Floats", SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_2(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  SwigValueWrapper< IMP::Vector< int > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_cpp_object(swig_obj[2], "DockingStateDecorator_add_attribute", 3, "IMP::Ints", SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< IMP::Vector< int > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::Ints, Convert< IMP::Int > >::create_python_object(ValueOrObject<IMP::Ints >::get(result), SWIGTYPE_p_int, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  SwigValueWrapper< IMP::Vector< int > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_cpp_object(swig_obj[2], "DockingStateDecorator_set_value", 3, "IMP::Ints", SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_3(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "DockingStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::String result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "DockingStateDecorator_set_value" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_4(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  IMP::Particle *arg3 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::Particle >::get_cpp_object(swig_obj[2], "DockingStateDecorator_add_attribute", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Particle *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Particle *)IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__Particle, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  IMP::Particle *arg3 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::Particle >::get_cpp_object(swig_obj[2], "DockingStateDecorator_set_value", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_5(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  IMP::Object *arg3 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DockingStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Object *""'"); 
  }
  arg3 = reinterpret_cast< IMP::Object * >(argp3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Object *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Object *)IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__Object, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  IMP::Object *arg3 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DockingStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Object *""'"); 
  }
  arg3 = reinterpret_cast< IMP::Object * >(argp3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_6(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Float result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Float)IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_7(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Int)IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_8(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "DockingStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::String result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "DockingStateDecorator_set_value" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_9(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute__SWIG_11(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  IMP::ParticleIndex arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[2],
        "DockingStateDecorator_add_attribute", 3, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_attribute__SWIG_11(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator_add_attribute", 0, 4, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
    if (argc == 4) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_bool(argv[3], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 23;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_23:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_2(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_3(self, argc, argv);
    case 4:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_4(self, argc, argv);
    case 5:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_5(self, argc, argv);
    case 6:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_6(self, argc, argv);
    case 7:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_7(self, argc, argv);
    case 8:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_8(self, argc, argv);
    case 9:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_9(self, argc, argv);
    case 10:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_10(self, argc, argv);
    case 11:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_11(self, argc, argv);
    case 12:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_1(self, argc, argv);
    case 13:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_2(self, argc, argv);
    case 14:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_3(self, argc, argv);
    case 15:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_4(self, argc, argv);
    case 16:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_5(self, argc, argv);
    case 17:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_6(self, argc, argv);
    case 18:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_7(self, argc, argv);
    case 19:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_8(self, argc, argv);
    case 20:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_9(self, argc, argv);
    case 21:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_10(self, argc, argv);
    case 22:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_11(self, argc, argv);
    case 23:
      return _wrap_DockingStateDecorator_add_attribute__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DockingStateDecorator_add_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::FloatKey,IMP::Float,bool)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::FloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::IntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::FloatsKey,IMP::Floats)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::IntsKey,IMP::Ints)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::StringKey,IMP::String)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::ParticleIndexKey,IMP::Particle *)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::ObjectKey,IMP::Object *)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::SparseFloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::SparseIntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::SparseStringKey,IMP::String)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::add_attribute(IMP::SparseParticleIndexKey,IMP::ParticleIndex)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::ParticleIndex result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_DockingStateDecorator_get_value__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = Convert<IMP::ParticleIndex >::create_python_object(result, SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator_get_value", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator_get_value__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator_get_value__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator_get_value__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_DockingStateDecorator_get_value__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_DockingStateDecorator_get_value__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_DockingStateDecorator_get_value__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_DockingStateDecorator_get_value__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_DockingStateDecorator_get_value__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_DockingStateDecorator_get_value__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_DockingStateDecorator_get_value__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_DockingStateDecorator_get_value__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_DockingStateDecorator_get_value__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_DockingStateDecorator_get_value__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_DockingStateDecorator_get_value__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_DockingStateDecorator_get_value__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_DockingStateDecorator_get_value__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_DockingStateDecorator_get_value__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_DockingStateDecorator_get_value__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_DockingStateDecorator_get_value__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_DockingStateDecorator_get_value__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_DockingStateDecorator_get_value__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_DockingStateDecorator_get_value__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DockingStateDecorator_get_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::IntKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::StringKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::get_value(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  IMP::ParticleIndex arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[2],
        "DockingStateDecorator_set_value", 3, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_value__SWIG_10(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator_set_value", 0, 3, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator_set_value__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator_set_value__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator_set_value__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_DockingStateDecorator_set_value__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_DockingStateDecorator_set_value__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_DockingStateDecorator_set_value__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_DockingStateDecorator_set_value__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_DockingStateDecorator_set_value__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_DockingStateDecorator_set_value__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_DockingStateDecorator_set_value__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_DockingStateDecorator_set_value__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_DockingStateDecorator_set_value__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_DockingStateDecorator_set_value__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_DockingStateDecorator_set_value__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_DockingStateDecorator_set_value__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_DockingStateDecorator_set_value__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_DockingStateDecorator_set_value__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_DockingStateDecorator_set_value__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_DockingStateDecorator_set_value__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_DockingStateDecorator_set_value__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_DockingStateDecorator_set_value__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_DockingStateDecorator_set_value__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DockingStateDecorator_set_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::FloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::IntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::FloatsKey,IMP::Floats)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::IntsKey,IMP::Ints)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::StringKey,IMP::String)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::ParticleIndexKey,IMP::Particle *)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::ObjectKey,IMP::Object *)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::SparseFloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::SparseIntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::SparseStringKey,IMP::String)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::set_value(IMP::SparseParticleIndexKey,IMP::ParticleIndex)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_remove_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_remove_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator_remove_attribute", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_DockingStateDecorator_remove_attribute__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DockingStateDecorator_remove_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::IntKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::StringKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::remove_attribute(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_has_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_has_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator_has_attribute", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_DockingStateDecorator_has_attribute__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DockingStateDecorator_has_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::IntKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::StringKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::DockingStateDecorator::has_attribute(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_derivative(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "DockingStateDecorator_get_derivative", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_derivative" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (double)IMP_insulinsecretion_DockingStateDecorator_get_derivative(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_derivative
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_name" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_DockingStateDecorator_get_name(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_name
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_clear_caches(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_clear_caches" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_clear_caches(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_clear_caches
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DockingStateDecorator_set_name", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_name" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "DockingStateDecorator_set_name" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_name(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_name
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_check_level(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::CheckLevel arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DockingStateDecorator_set_check_level", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_check_level" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__CheckLevel,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_check_level" "', argument " "2"" of type '" "IMP::CheckLevel""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_check_level" "', argument " "2"" of type '" "IMP::CheckLevel""'");
    } else {
      IMP::CheckLevel * temp = reinterpret_cast< IMP::CheckLevel * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_check_level(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_check_level
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_add_to_derivative(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  double arg3 ;
  IMP::DerivativeAccumulator arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DockingStateDecorator_add_to_derivative", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_add_to_derivative" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_add_to_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_to_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_add_to_derivative" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4, SWIGTYPE_p_IMP__DerivativeAccumulator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DockingStateDecorator_add_to_derivative" "', argument " "4"" of type '" "IMP::DerivativeAccumulator""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_add_to_derivative" "', argument " "4"" of type '" "IMP::DerivativeAccumulator""'");
    } else {
      IMP::DerivativeAccumulator * temp = reinterpret_cast< IMP::DerivativeAccumulator * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_add_to_derivative(arg1,SWIG_STD_MOVE(arg2),arg3,SWIG_STD_MOVE(arg4));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_add_to_derivative
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_set_is_optimized(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DockingStateDecorator_set_is_optimized", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_set_is_optimized" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_set_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_set_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_bool(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DockingStateDecorator_set_is_optimized" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator_set_is_optimized(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_set_is_optimized
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_is_optimized(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "DockingStateDecorator_get_is_optimized", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_is_optimized" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator_get_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator_get_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator_get_is_optimized(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_is_optimized
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator_get_check_level(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::CheckLevel result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator_get_check_level" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_DockingStateDecorator_get_check_level(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator_get_check_level
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::CheckLevel(result)), SWIGTYPE_p_IMP__CheckLevel, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___eq____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::insulinsecretion::DockingStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___eq__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator___eq__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator___eq__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'");
    } else {
      IMP::insulinsecretion::DockingStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___eq____SWIG_0((IMP::insulinsecretion::DockingStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___eq__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___ne____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::insulinsecretion::DockingStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___ne__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator___ne__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator___ne__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'");
    } else {
      IMP::insulinsecretion::DockingStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___ne____SWIG_0((IMP::insulinsecretion::DockingStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___ne__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___le____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::insulinsecretion::DockingStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___le__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator___le__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator___le__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'");
    } else {
      IMP::insulinsecretion::DockingStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___le____SWIG_0((IMP::insulinsecretion::DockingStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___le__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___lt____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::insulinsecretion::DockingStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___lt__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator___lt__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator___lt__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'");
    } else {
      IMP::insulinsecretion::DockingStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___lt____SWIG_0((IMP::insulinsecretion::DockingStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___lt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___ge____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::insulinsecretion::DockingStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___ge__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator___ge__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator___ge__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'");
    } else {
      IMP::insulinsecretion::DockingStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___ge____SWIG_0((IMP::insulinsecretion::DockingStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___ge__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___gt____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::insulinsecretion::DockingStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___gt__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DockingStateDecorator___gt__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DockingStateDecorator___gt__" "', argument " "2"" of type '" "IMP::insulinsecretion::DockingStateDecorator""'");
    } else {
      IMP::insulinsecretion::DockingStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___gt____SWIG_0((IMP::insulinsecretion::DockingStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___gt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___eq____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___eq__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "DockingStateDecorator___eq__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___eq____SWIG_1((IMP::insulinsecretion::DockingStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___eq__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___eq__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator___eq__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator___eq____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator___eq____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator___eq____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___ne____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___ne__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "DockingStateDecorator___ne__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___ne____SWIG_1((IMP::insulinsecretion::DockingStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___ne__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___ne__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator___ne__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator___ne____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator___ne____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator___ne____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___le____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___le__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "DockingStateDecorator___le__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___le____SWIG_1((IMP::insulinsecretion::DockingStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___le__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___le__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator___le__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator___le____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator___le____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator___le____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___lt____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___lt__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "DockingStateDecorator___lt__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___lt____SWIG_1((IMP::insulinsecretion::DockingStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___lt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___lt__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator___lt__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator___lt____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator___lt____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator___lt____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___ge____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___ge__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "DockingStateDecorator___ge__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___ge____SWIG_1((IMP::insulinsecretion::DockingStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___ge__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___ge__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator___ge__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator___ge____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator___ge____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator___ge____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___gt____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___gt__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "DockingStateDecorator___gt__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_DockingStateDecorator___gt____SWIG_1((IMP::insulinsecretion::DockingStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___gt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___gt__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DockingStateDecorator___gt__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_DockingStateDecorator___gt____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_DockingStateDecorator___gt____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_DockingStateDecorator___gt____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___hash__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___hash__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_DockingStateDecorator___hash__((IMP::insulinsecretion::DockingStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___hash__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = PyInt_FromLong(static_cast<long>(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___str__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___str__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_DockingStateDecorator___str__((IMP::insulinsecretion::DockingStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___str__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator___repr__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator___repr__" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_DockingStateDecorator___repr__((IMP::insulinsecretion::DockingStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator___repr__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator__get_as_binary(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator__get_as_binary" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      result = (PyObject *)IMP_insulinsecretion_DockingStateDecorator__get_as_binary((IMP::insulinsecretion::DockingStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator__get_as_binary
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DockingStateDecorator__set_from_binary(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DockingStateDecorator__set_from_binary", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DockingStateDecorator__set_from_binary" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  arg2 = swig_obj[1];
  {
    try {
      IMP_insulinsecretion_DockingStateDecorator__set_from_binary(arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete DockingStateDecorator__set_from_binary
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_DockingStateDecorator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::DockingStateDecorator *arg1 = (IMP::insulinsecretion::DockingStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DockingStateDecorator" "', argument " "1"" of type '" "IMP::insulinsecretion::DockingStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::DockingStateDecorator * >(argp1);
  {
    try {
      delete arg1;
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete delete_DockingStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *DockingStateDecorator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_IMP__insulinsecretion__DockingStateDecorator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *DockingStateDecorator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_is_setup__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "CaChannelStateDecorator_get_is_setup", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP::insulinsecretion::CaChannelStateDecorator::get_is_setup(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_is_setup
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_channelstate(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::Int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_channelstate" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      result = (IMP::Int)((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1)->get_channelstate();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_channelstate
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_channelstate(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::Int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_set_channelstate", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_channelstate" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaChannelStateDecorator_set_channelstate" "', argument " "2"" of type '" "IMP::Int""'");
  } 
  arg2 = static_cast< IMP::Int >(val2);
  {
    try {
      (arg1)->set_channelstate(arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_channelstate
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CaChannelStateDecorator__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (IMP::insulinsecretion::CaChannelStateDecorator *)new IMP::insulinsecretion::CaChannelStateDecorator();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_CaChannelStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CaChannelStateDecorator__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ::IMP::Model *arg1 = (::IMP::Model *) 0 ;
  ::IMP::ParticleIndex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CaChannelStateDecorator" "', argument " "1"" of type '" "::IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< ::IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "new_CaChannelStateDecorator", 2, "::IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (IMP::insulinsecretion::CaChannelStateDecorator *)new IMP::insulinsecretion::CaChannelStateDecorator(arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_CaChannelStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CaChannelStateDecorator__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator *result = 0 ;
  
  if (SWIG_CheckImplicit(SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator)) SWIG_fail;
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CaChannelStateDecorator" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CaChannelStateDecorator" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  arg1 = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
  {
    try {
      result = (IMP::insulinsecretion::CaChannelStateDecorator *)new IMP::insulinsecretion::CaChannelStateDecorator((IMP::ParticleAdaptor const &)*arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete new_CaChannelStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CaChannelStateDecorator(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_CaChannelStateDecorator", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 0) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "::IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_new_CaChannelStateDecorator__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_new_CaChannelStateDecorator__SWIG_2(self, argc, argv);
    case 3:
      return _wrap_new_CaChannelStateDecorator__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_CaChannelStateDecorator'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::CaChannelStateDecorator()\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::CaChannelStateDecorator(::IMP::Model *,::IMP::ParticleIndex)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::CaChannelStateDecorator(IMP::ParticleAdaptor const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_is_setup__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_is_setup" "', argument " "1"" of type '" "IMP::ParticleAdaptor const &""'"); 
  }
  arg1 = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
  {
    try {
      result = (bool)IMP::insulinsecretion::CaChannelStateDecorator::get_is_setup((IMP::ParticleAdaptor const &)*arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_is_setup
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_is_setup(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_get_is_setup", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator_get_is_setup__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator_get_is_setup__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'CaChannelStateDecorator_get_is_setup'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_is_setup(IMP::Model *,IMP::ParticleIndex)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_is_setup(IMP::ParticleAdaptor const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_show__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IMP::PointerMember< PyOutFileAdapter > tmp2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_show" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    tmp2=new PyOutFileAdapter();
    try {
      arg2 = tmp2->set_python_file(swig_obj[1]);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    
    if (!arg2) {
      SWIG_fail;
    }
  }
  {
    try {
      ((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1)->show(*arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_show
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    try {
      tmp2->pubsync();
    } catch (...) {
      Py_DECREF(resultobj);
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_show__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_show" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      ((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1)->show();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_show
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_show(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_show", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 1) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        _v = (argv[1] != 0);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator_show__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator_show__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'CaChannelStateDecorator_show'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::show(std::ostream &) const\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::show() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_setup_particle__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "CaChannelStateDecorator_setup_particle", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      result = IMP::insulinsecretion::CaChannelStateDecorator::setup_particle(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::CaChannelStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_setup_particle__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor arg1 ;
  IMP::Int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'");
    } else {
      IMP::ParticleAdaptor * temp = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "2"" of type '" "IMP::Int""'");
  } 
  arg2 = static_cast< IMP::Int >(val2);
  {
    try {
      result = IMP::insulinsecretion::CaChannelStateDecorator::setup_particle(SWIG_STD_MOVE(arg1),arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::CaChannelStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_setup_particle__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::Model *arg1 = (IMP::Model *) 0 ;
  IMP::ParticleIndex arg2 ;
  IMP::insulinsecretion::CaChannelStateDecorator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::Model *""'"); 
  }
  arg1 = reinterpret_cast< IMP::Model * >(argp1);
  {
    try {
      arg2 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[1],
        "CaChannelStateDecorator_setup_particle", 2, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "3"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "3"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'");
    } else {
      IMP::insulinsecretion::CaChannelStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      result = IMP::insulinsecretion::CaChannelStateDecorator::setup_particle(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::CaChannelStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_setup_particle__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::ParticleAdaptor arg1 ;
  IMP::insulinsecretion::CaChannelStateDecorator arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_IMP__ParticleAdaptor,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "1"" of type '" "IMP::ParticleAdaptor""'");
    } else {
      IMP::ParticleAdaptor * temp = reinterpret_cast< IMP::ParticleAdaptor * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_setup_particle" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'");
    } else {
      IMP::insulinsecretion::CaChannelStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP::insulinsecretion::CaChannelStateDecorator::setup_particle(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_setup_particle
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::insulinsecretion::CaChannelStateDecorator(result)), SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_setup_particle(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_setup_particle", 0, 3, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_IMP__ParticleAdaptor, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[1], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__Model, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[1],
              "$symname", 2, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator_setup_particle__SWIG_3(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator_setup_particle__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator_setup_particle__SWIG_3(self, argc, argv);
    case 4:
      return _wrap_CaChannelStateDecorator_setup_particle__SWIG_1(self, argc, argv);
    case 5:
      return _wrap_CaChannelStateDecorator_setup_particle__SWIG_2(self, argc, argv);
    case 6:
      return _wrap_CaChannelStateDecorator_setup_particle__SWIG_0(self, argc, argv);
    case 7:
      return _wrap_CaChannelStateDecorator_setup_particle__SWIG_2(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'CaChannelStateDecorator_setup_particle'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::setup_particle(IMP::Model *,IMP::ParticleIndex,IMP::Int)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::setup_particle(IMP::ParticleAdaptor,IMP::Int)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::setup_particle(IMP::Model *,IMP::ParticleIndex,IMP::insulinsecretion::CaChannelStateDecorator)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::setup_particle(IMP::ParticleAdaptor,IMP::insulinsecretion::CaChannelStateDecorator)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_channelstate_key(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::IntKey result;
  
  if (!SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_get_channelstate_key", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = IMP::insulinsecretion::CaChannelStateDecorator::get_channelstate_key();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_channelstate_key
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::IntKey(result)), SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  ecode4 = SWIG_AsVal_bool(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2),arg3,arg4);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Float result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Float)IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_0(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Int)IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_1(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::IntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_1_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntKey""'");
    } else {
      IMP::IntKey * temp = reinterpret_cast< IMP::IntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_1(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  SwigValueWrapper< IMP::Vector< double > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_cpp_object(swig_obj[2], "CaChannelStateDecorator_add_attribute", 3, "IMP::Floats", SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< IMP::Vector< double > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::Floats, Convert< IMP::Float > >::create_python_object(ValueOrObject<IMP::Floats >::get(result), SWIGTYPE_p_double, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  SwigValueWrapper< IMP::Vector< double > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_cpp_object(swig_obj[2], "CaChannelStateDecorator_set_value", 3, "IMP::Floats", SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_2(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_10_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::FloatsKey""'");
    } else {
      IMP::FloatsKey * temp = reinterpret_cast< IMP::FloatsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_2(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  SwigValueWrapper< IMP::Vector< int > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_cpp_object(swig_obj[2], "CaChannelStateDecorator_add_attribute", 3, "IMP::Ints", SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< IMP::Vector< int > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = ConvertSequence<IMP::Ints, Convert< IMP::Int > >::create_python_object(ValueOrObject<IMP::Ints >::get(result), SWIGTYPE_p_int, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  SwigValueWrapper< IMP::Vector< int > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      // hack to get around swig's value wrapper being randomly used
      assign(arg3, ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_cpp_object(swig_obj[2], "CaChannelStateDecorator_set_value", 3, "IMP::Ints", SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator));
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_3(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  {
    delete_if_pointer(arg3);
  }
  return resultobj;
fail:
  {
    delete_if_pointer(arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::IntsKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_5_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::IntsKey""'");
    } else {
      IMP::IntsKey * temp = reinterpret_cast< IMP::IntsKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_3(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::String result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "CaChannelStateDecorator_set_value" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_4(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::StringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_2_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::StringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::StringKey""'");
    } else {
      IMP::StringKey * temp = reinterpret_cast< IMP::StringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_4(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  IMP::Particle *arg3 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::Particle >::get_cpp_object(swig_obj[2], "CaChannelStateDecorator_add_attribute", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Particle *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Particle *)IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__Particle, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  IMP::Particle *arg3 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::Particle >::get_cpp_object(swig_obj[2], "CaChannelStateDecorator_set_value", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_5(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::ParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_3_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ParticleIndexKey""'");
    } else {
      IMP::ParticleIndexKey * temp = reinterpret_cast< IMP::ParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_5(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  IMP::Object *arg3 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Object *""'"); 
  }
  arg3 = reinterpret_cast< IMP::Object * >(argp3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Object *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Object *)IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    if (!(0 & SWIG_POINTER_NEW)) {
      // out typemaps are also called for constructors, which already use %ref
      // to increase the reference count. So don't do it twice.
      if (result) result->ref();
    }
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMP__Object, 0 | SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  IMP::Object *arg3 = (IMP::Object *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_IMP__Object, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CaChannelStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Object *""'"); 
  }
  arg3 = reinterpret_cast< IMP::Object * >(argp3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_6(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_6(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::ObjectKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_4_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::ObjectKey""'");
    } else {
      IMP::ObjectKey * temp = reinterpret_cast< IMP::ObjectKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_6(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Float result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Float)IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  IMP::Float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Float""'");
  } 
  arg3 = static_cast< IMP::Float >(val3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_7(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_7(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseFloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_14_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseFloatKey""'");
    } else {
      IMP::SparseFloatKey * temp = reinterpret_cast< IMP::SparseFloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_7(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::Int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (IMP::Int)IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  IMP::Int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_set_value" "', argument " "3"" of type '" "IMP::Int""'");
  } 
  arg3 = static_cast< IMP::Int >(val3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_8(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_8(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseIntKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_13_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseIntKey""'");
    } else {
      IMP::SparseIntKey * temp = reinterpret_cast< IMP::SparseIntKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_8(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::String result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  IMP::String arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "CaChannelStateDecorator_set_value" "', argument " "3"" of type '" "IMP::String""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_9(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_9(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseStringKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_12_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseStringKey""'");
    } else {
      IMP::SparseStringKey * temp = reinterpret_cast< IMP::SparseStringKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_9(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute__SWIG_11(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  IMP::ParticleIndex arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[2],
        "CaChannelStateDecorator_add_attribute", 3, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_attribute__SWIG_11(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_add_attribute", 0, 4, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
    if (argc == 4) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_bool(argv[3], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_23;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 23;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_23:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_1(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_2(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_3(self, argc, argv);
    case 4:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_4(self, argc, argv);
    case 5:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_5(self, argc, argv);
    case 6:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_6(self, argc, argv);
    case 7:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_7(self, argc, argv);
    case 8:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_8(self, argc, argv);
    case 9:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_9(self, argc, argv);
    case 10:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_10(self, argc, argv);
    case 11:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_11(self, argc, argv);
    case 12:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_1(self, argc, argv);
    case 13:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_2(self, argc, argv);
    case 14:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_3(self, argc, argv);
    case 15:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_4(self, argc, argv);
    case 16:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_5(self, argc, argv);
    case 17:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_6(self, argc, argv);
    case 18:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_7(self, argc, argv);
    case 19:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_8(self, argc, argv);
    case 20:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_9(self, argc, argv);
    case 21:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_10(self, argc, argv);
    case 22:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_11(self, argc, argv);
    case 23:
      return _wrap_CaChannelStateDecorator_add_attribute__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'CaChannelStateDecorator_add_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::FloatKey,IMP::Float,bool)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::FloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::IntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::FloatsKey,IMP::Floats)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::IntsKey,IMP::Ints)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::StringKey,IMP::String)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::ParticleIndexKey,IMP::Particle *)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::ObjectKey,IMP::Object *)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::SparseFloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::SparseIntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::SparseStringKey,IMP::String)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::add_attribute(IMP::SparseParticleIndexKey,IMP::ParticleIndex)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  IMP::ParticleIndex result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = IMP_insulinsecretion_CaChannelStateDecorator_get_value__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = Convert<IMP::ParticleIndex >::create_python_object(result, SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIG_POINTER_OWN);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_get_value", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_CaChannelStateDecorator_get_value__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'CaChannelStateDecorator_get_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::IntKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::StringKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::get_value(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  IMP::ParticleIndex arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_value" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_value" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      arg3 = Convert<IMP::ParticleIndex >::get_cpp_object(swig_obj[2],
        "CaChannelStateDecorator_set_value", 3, "IMP::ParticleIndex", 
        SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
        SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_value__SWIG_10(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_value
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_set_value", 0, 3, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Floats, Convert< IMP::Float > >::get_is_cpp_object(argv[2], SWIGTYPE_p_double, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          _v= ConvertSequence<IMP::Ints, Convert< IMP::Int > >::get_is_cpp_object(argv[2], SWIGTYPE_p_int, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
        }
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[2], "$symname", 3, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_IMP__Object, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 3) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::ParticleIndex >::get_cpp_object(argv[2],
              "$symname", 3, "IMP::ParticleIndex", 
              SWIGTYPE_p_IMP__IndexT_IMP__ParticleIndexTag_t, SWIGTYPE_p_IMP__Particle,
              SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_CaChannelStateDecorator_set_value__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'CaChannelStateDecorator_set_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::FloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::IntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::FloatsKey,IMP::Floats)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::IntsKey,IMP::Ints)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::StringKey,IMP::String)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::ParticleIndexKey,IMP::Particle *)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::ObjectKey,IMP::Object *)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::SparseFloatKey,IMP::Float)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::SparseIntKey,IMP::Int)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::SparseStringKey,IMP::String)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::set_value(IMP::SparseParticleIndexKey,IMP::ParticleIndex)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_remove_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_remove_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_remove_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_remove_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_remove_attribute", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_CaChannelStateDecorator_remove_attribute__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'CaChannelStateDecorator_remove_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::IntKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::StringKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::remove_attribute(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute__SWIG_10(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::SparseParticleIndexKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_15_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_has_attribute" "', argument " "2"" of type '" "IMP::SparseParticleIndexKey""'");
    } else {
      IMP::SparseParticleIndexKey * temp = reinterpret_cast< IMP::SparseParticleIndexKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_has_attribute__SWIG_10(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_has_attribute
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_has_attribute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_has_attribute", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_4;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 4;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_4:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_5;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 5;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_5:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_6;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 6;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_6:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_7;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 7;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_7:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_8;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 8;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_8:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_9;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 9;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_9:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_10;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 10;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_10:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_11;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 11;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_11:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_0_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_12;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 12;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_12:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_1_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_13;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 13;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_13:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_10_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_14;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 14;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_14:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_5_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_15;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 15;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_15:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_2_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_16;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 16;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_16:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_3_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_17;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 17;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_17:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_4_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_18;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 18;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_18:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_14_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_19;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 19;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_19:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_13_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_20;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 20;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_20:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_12_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_21;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 21;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_21:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__KeyT_15_t, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_22;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 22;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_22:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_0(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_2(self, argc, argv);
    case 4:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_3(self, argc, argv);
    case 5:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_4(self, argc, argv);
    case 6:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_5(self, argc, argv);
    case 7:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_6(self, argc, argv);
    case 8:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_7(self, argc, argv);
    case 9:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_8(self, argc, argv);
    case 10:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_9(self, argc, argv);
    case 11:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_10(self, argc, argv);
    case 12:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_0(self, argc, argv);
    case 13:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_1(self, argc, argv);
    case 14:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_2(self, argc, argv);
    case 15:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_3(self, argc, argv);
    case 16:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_4(self, argc, argv);
    case 17:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_5(self, argc, argv);
    case 18:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_6(self, argc, argv);
    case 19:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_7(self, argc, argv);
    case 20:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_8(self, argc, argv);
    case 21:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_9(self, argc, argv);
    case 22:
      return _wrap_CaChannelStateDecorator_has_attribute__SWIG_10(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'CaChannelStateDecorator_has_attribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::FloatKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::IntKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::FloatsKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::IntsKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::StringKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::ParticleIndexKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::ObjectKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::SparseFloatKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::SparseIntKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::SparseStringKey)\n"
    "    IMP::insulinsecretion::CaChannelStateDecorator::has_attribute(IMP::SparseParticleIndexKey)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_derivative(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_get_derivative", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_derivative" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (double)IMP_insulinsecretion_CaChannelStateDecorator_get_derivative(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_derivative
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_name" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_CaChannelStateDecorator_get_name(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_name
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_clear_caches(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_clear_caches" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_clear_caches(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_clear_caches
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_set_name", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_name" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "CaChannelStateDecorator_set_name" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_name(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_name
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_check_level(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::CheckLevel arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_set_check_level", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_check_level" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__CheckLevel,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_check_level" "', argument " "2"" of type '" "IMP::CheckLevel""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_check_level" "', argument " "2"" of type '" "IMP::CheckLevel""'");
    } else {
      IMP::CheckLevel * temp = reinterpret_cast< IMP::CheckLevel * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_check_level(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_check_level
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_add_to_derivative(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  double arg3 ;
  IMP::DerivativeAccumulator arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_add_to_derivative", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_add_to_derivative" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_add_to_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_to_derivative" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_add_to_derivative" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4, SWIGTYPE_p_IMP__DerivativeAccumulator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CaChannelStateDecorator_add_to_derivative" "', argument " "4"" of type '" "IMP::DerivativeAccumulator""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_add_to_derivative" "', argument " "4"" of type '" "IMP::DerivativeAccumulator""'");
    } else {
      IMP::DerivativeAccumulator * temp = reinterpret_cast< IMP::DerivativeAccumulator * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_add_to_derivative(arg1,SWIG_STD_MOVE(arg2),arg3,SWIG_STD_MOVE(arg4));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_add_to_derivative
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_set_is_optimized(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_set_is_optimized", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_set_is_optimized" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_set_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_set_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_bool(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaChannelStateDecorator_set_is_optimized" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator_set_is_optimized(arg1,SWIG_STD_MOVE(arg2),arg3);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_set_is_optimized
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_is_optimized(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::FloatKey arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator_get_is_optimized", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_is_optimized" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__KeyT_0_t,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator_get_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator_get_is_optimized" "', argument " "2"" of type '" "IMP::FloatKey""'");
    } else {
      IMP::FloatKey * temp = reinterpret_cast< IMP::FloatKey * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator_get_is_optimized(arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_is_optimized
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator_get_check_level(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMP::CheckLevel result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator_get_check_level" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_CaChannelStateDecorator_get_check_level(arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator_get_check_level
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_NewPointerObj((new IMP::CheckLevel(result)), SWIGTYPE_p_IMP__CheckLevel, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___eq____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___eq__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator___eq__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator___eq__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'");
    } else {
      IMP::insulinsecretion::CaChannelStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___eq____SWIG_0((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___eq__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___ne____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___ne__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator___ne__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator___ne__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'");
    } else {
      IMP::insulinsecretion::CaChannelStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___ne____SWIG_0((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___ne__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___le____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___le__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator___le__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator___le__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'");
    } else {
      IMP::insulinsecretion::CaChannelStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___le____SWIG_0((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___le__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___lt____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___lt__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator___lt__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator___lt__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'");
    } else {
      IMP::insulinsecretion::CaChannelStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___lt____SWIG_0((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___lt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___ge____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___ge__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator___ge__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator___ge__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'");
    } else {
      IMP::insulinsecretion::CaChannelStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___ge____SWIG_0((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___ge__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___gt____SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::insulinsecretion::CaChannelStateDecorator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___gt__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaChannelStateDecorator___gt__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaChannelStateDecorator___gt__" "', argument " "2"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator""'");
    } else {
      IMP::insulinsecretion::CaChannelStateDecorator * temp = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___gt____SWIG_0((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,SWIG_STD_MOVE(arg2));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___gt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___eq____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___eq__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "CaChannelStateDecorator___eq__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___eq____SWIG_1((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___eq__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___eq__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator___eq__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator___eq____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator___eq____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator___eq____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___ne____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___ne__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "CaChannelStateDecorator___ne__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___ne____SWIG_1((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___ne__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___ne__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator___ne__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator___ne____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator___ne____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator___ne____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___le____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___le__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "CaChannelStateDecorator___le__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___le____SWIG_1((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___le__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___le__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator___le__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator___le____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator___le____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator___le____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___lt____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___lt__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "CaChannelStateDecorator___lt__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___lt____SWIG_1((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___lt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___lt__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator___lt__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator___lt____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator___lt____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator___lt____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___ge____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___ge__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "CaChannelStateDecorator___ge__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___ge____SWIG_1((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___ge__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___ge__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator___ge__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator___ge____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator___ge____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator___ge____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___gt____SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  IMP::Particle *arg2 = (IMP::Particle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___gt__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      arg2 = Convert<IMP::Particle >::get_cpp_object(swig_obj[1], "CaChannelStateDecorator___gt__", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
    } catch (const IMP::Exception &e) {
      //PyErr_SetString(PyExc_ValueError,"Wrong type in sequence");
      PyErr_SetString(PyExc_TypeError, e.what());
      return NULL;
    }
  }
  {
    try {
      result = (bool)IMP_insulinsecretion_CaChannelStateDecorator___gt____SWIG_1((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___gt__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___gt__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator___gt__", 0, 2, argv))) SWIG_fail;
  --argc;
  {
    unsigned long _index = 0;
    SWIG_TypeRank _rank = 0; 
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 1;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_1:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        {
          try {
            Convert<IMP::Particle >::get_cpp_object(argv[1], "$symname", 2, "IMP::Particle *", SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Particle, SWIGTYPE_p_IMP__Decorator);
            _v=1;
          } catch (...) {
            _v=0;
          }
        }
      }
      if (!_v) goto check_2;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 2;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_2:
    
    if (argc == 2) {
      SWIG_TypeRank _ranki = 0;
      SWIG_TypeRank _rankm = 0;
      SWIG_TypeRank _pi = 1;
      int _v = 0;
      {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      {
        int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_NO_NULL | SWIG_POINTER_IMPLICIT_CONV);
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_3;
      _ranki += _v*_pi;
      _rankm += _pi;
      _pi *= SWIG_MAXCASTRANK;
      if (!_index || (_ranki < _rank)) {
        _rank = _ranki; _index = 3;
        if (_rank == _rankm) goto dispatch;
      }
    }
  check_3:
    
  dispatch:
    switch(_index) {
    case 1:
      return _wrap_CaChannelStateDecorator___gt____SWIG_0(self, argc, argv);
    case 2:
      return _wrap_CaChannelStateDecorator___gt____SWIG_1(self, argc, argv);
    case 3:
      return _wrap_CaChannelStateDecorator___gt____SWIG_0(self, argc, argv);
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___hash__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___hash__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_CaChannelStateDecorator___hash__((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___hash__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  {
    resultobj = PyInt_FromLong(static_cast<long>(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___str__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___str__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_CaChannelStateDecorator___str__((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___str__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator___repr__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator___repr__" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      result = IMP_insulinsecretion_CaChannelStateDecorator___repr__((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator___repr__
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator__get_as_binary(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator__get_as_binary" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator const *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      result = (PyObject *)IMP_insulinsecretion_CaChannelStateDecorator__get_as_binary((IMP::insulinsecretion::CaChannelStateDecorator const *)arg1);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator__get_as_binary
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaChannelStateDecorator__set_from_binary(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "CaChannelStateDecorator__set_from_binary", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaChannelStateDecorator__set_from_binary" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  arg2 = swig_obj[1];
  {
    try {
      IMP_insulinsecretion_CaChannelStateDecorator__set_from_binary(arg1,arg2);
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete CaChannelStateDecorator__set_from_binary
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CaChannelStateDecorator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMP::insulinsecretion::CaChannelStateDecorator *arg1 = (IMP::insulinsecretion::CaChannelStateDecorator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CaChannelStateDecorator" "', argument " "1"" of type '" "IMP::insulinsecretion::CaChannelStateDecorator *""'"); 
  }
  arg1 = reinterpret_cast< IMP::insulinsecretion::CaChannelStateDecorator * >(argp1);
  {
    try {
      delete arg1;
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete delete_CaChannelStateDecorator
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CaChannelStateDecorator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_IMP__insulinsecretion__CaChannelStateDecorator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *CaChannelStateDecorator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_get_module_version(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "get_module_version", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = IMP::insulinsecretion::get_module_version();
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete get_module_version
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_get_example_path(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "get_example_path" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = IMP::insulinsecretion::get_example_path(SWIG_STD_MOVE(arg1));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete get_example_path
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_get_data_path(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "get_data_path" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = IMP::insulinsecretion::get_data_path(SWIG_STD_MOVE(arg1));
    } catch (...) {
      // If Python error indicator is set (e.g. from a failed director method),
      // it will be reraised at the end of the method
      if (!PyErr_Occurred()) {
        handle_imp_exception();
      }
      SWIG_fail;
    }
    // If we're doing cleanup as a result of a previous Python exception
    // (e.g. StopIteration), don't return a value (otherwise we'll get a
    // SystemError "returned a result with an error set").
    // SWIG doesn't appear to allow us to do this only for delete_* wrappers,
    // and the C preprocessor isn't up to the job, so #ifdelete is mapped to
    // #if 0 or #if 1 by tools/build/make_swig_wrapper.py
#ifdelete get_data_path
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
#endif
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


static PyMethodDef SwigMethods[] = {
	 { "delete_IMP_INSULINSECRETION_SwigPyIterator", _wrap_delete_IMP_INSULINSECRETION_SwigPyIterator, METH_O, "delete_IMP_INSULINSECRETION_SwigPyIterator(IMP_INSULINSECRETION_SwigPyIterator self)"},
	 { "IMP_INSULINSECRETION_SwigPyIterator_value", _wrap_IMP_INSULINSECRETION_SwigPyIterator_value, METH_O, "IMP_INSULINSECRETION_SwigPyIterator_value(IMP_INSULINSECRETION_SwigPyIterator self) -> PyObject *"},
	 { "IMP_INSULINSECRETION_SwigPyIterator_incr", _wrap_IMP_INSULINSECRETION_SwigPyIterator_incr, METH_VARARGS, "IMP_INSULINSECRETION_SwigPyIterator_incr(IMP_INSULINSECRETION_SwigPyIterator self, size_t n=1) -> IMP_INSULINSECRETION_SwigPyIterator"},
	 { "IMP_INSULINSECRETION_SwigPyIterator_decr", _wrap_IMP_INSULINSECRETION_SwigPyIterator_decr, METH_VARARGS, "IMP_INSULINSECRETION_SwigPyIterator_decr(IMP_INSULINSECRETION_SwigPyIterator self, size_t n=1) -> IMP_INSULINSECRETION_SwigPyIterator"},
	 { "IMP_INSULINSECRETION_SwigPyIterator_distance", _wrap_IMP_INSULINSECRETION_SwigPyIterator_distance, METH_VARARGS, "IMP_INSULINSECRETION_SwigPyIterator_distance(IMP_INSULINSECRETION_SwigPyIterator self, IMP_INSULINSECRETION_SwigPyIterator x) -> ptrdiff_t"},
	 { "IMP_INSULINSECRETION_SwigPyIterator_equal", _wrap_IMP_INSULINSECRETION_SwigPyIterator_equal, METH_VARARGS, "IMP_INSULINSECRETION_SwigPyIterator_equal(IMP_INSULINSECRETION_SwigPyIterator self, IMP_INSULINSECRETION_SwigPyIterator x) -> bool"},
	 { "IMP_INSULINSECRETION_SwigPyIterator_copy", _wrap_IMP_INSULINSECRETION_SwigPyIterator_copy, METH_O, "IMP_INSULINSECRETION_SwigPyIterator_copy(IMP_INSULINSECRETION_SwigPyIterator self) -> IMP_INSULINSECRETION_SwigPyIterator"},
	 { "IMP_INSULINSECRETION_SwigPyIterator_next", _wrap_IMP_INSULINSECRETION_SwigPyIterator_next, METH_O, "IMP_INSULINSECRETION_SwigPyIterator_next(IMP_INSULINSECRETION_SwigPyIterator self) -> PyObject *"},
	 { "IMP_INSULINSECRETION_SwigPyIterator___next__", _wrap_IMP_INSULINSECRETION_SwigPyIterator___next__, METH_O, "IMP_INSULINSECRETION_SwigPyIterator___next__(IMP_INSULINSECRETION_SwigPyIterator self) -> PyObject *"},
	 { "IMP_INSULINSECRETION_SwigPyIterator_previous", _wrap_IMP_INSULINSECRETION_SwigPyIterator_previous, METH_O, "IMP_INSULINSECRETION_SwigPyIterator_previous(IMP_INSULINSECRETION_SwigPyIterator self) -> PyObject *"},
	 { "IMP_INSULINSECRETION_SwigPyIterator_advance", _wrap_IMP_INSULINSECRETION_SwigPyIterator_advance, METH_VARARGS, "IMP_INSULINSECRETION_SwigPyIterator_advance(IMP_INSULINSECRETION_SwigPyIterator self, ptrdiff_t n) -> IMP_INSULINSECRETION_SwigPyIterator"},
	 { "IMP_INSULINSECRETION_SwigPyIterator___eq__", _wrap_IMP_INSULINSECRETION_SwigPyIterator___eq__, METH_VARARGS, "IMP_INSULINSECRETION_SwigPyIterator___eq__(IMP_INSULINSECRETION_SwigPyIterator self, IMP_INSULINSECRETION_SwigPyIterator x) -> bool"},
	 { "IMP_INSULINSECRETION_SwigPyIterator___ne__", _wrap_IMP_INSULINSECRETION_SwigPyIterator___ne__, METH_VARARGS, "IMP_INSULINSECRETION_SwigPyIterator___ne__(IMP_INSULINSECRETION_SwigPyIterator self, IMP_INSULINSECRETION_SwigPyIterator x) -> bool"},
	 { "IMP_INSULINSECRETION_SwigPyIterator___iadd__", _wrap_IMP_INSULINSECRETION_SwigPyIterator___iadd__, METH_VARARGS, "IMP_INSULINSECRETION_SwigPyIterator___iadd__(IMP_INSULINSECRETION_SwigPyIterator self, ptrdiff_t n) -> IMP_INSULINSECRETION_SwigPyIterator"},
	 { "IMP_INSULINSECRETION_SwigPyIterator___isub__", _wrap_IMP_INSULINSECRETION_SwigPyIterator___isub__, METH_VARARGS, "IMP_INSULINSECRETION_SwigPyIterator___isub__(IMP_INSULINSECRETION_SwigPyIterator self, ptrdiff_t n) -> IMP_INSULINSECRETION_SwigPyIterator"},
	 { "IMP_INSULINSECRETION_SwigPyIterator___add__", _wrap_IMP_INSULINSECRETION_SwigPyIterator___add__, METH_VARARGS, "IMP_INSULINSECRETION_SwigPyIterator___add__(IMP_INSULINSECRETION_SwigPyIterator self, ptrdiff_t n) -> IMP_INSULINSECRETION_SwigPyIterator"},
	 { "IMP_INSULINSECRETION_SwigPyIterator___sub__", _wrap_IMP_INSULINSECRETION_SwigPyIterator___sub__, METH_VARARGS, "\n"
		"IMP_INSULINSECRETION_SwigPyIterator___sub__(IMP_INSULINSECRETION_SwigPyIterator self, ptrdiff_t n) -> IMP_INSULINSECRETION_SwigPyIterator\n"
		"IMP_INSULINSECRETION_SwigPyIterator___sub__(IMP_INSULINSECRETION_SwigPyIterator self, IMP_INSULINSECRETION_SwigPyIterator x) -> ptrdiff_t\n"
		""},
	 { "IMP_INSULINSECRETION_SwigPyIterator_swigregister", IMP_INSULINSECRETION_SwigPyIterator_swigregister, METH_O, NULL},
	 { "_ostream_write", _wrap__ostream_write, METH_VARARGS, "_ostream_write(_ostream self, char const * osa_buf)"},
	 { "_ostream_swigregister", _ostream_swigregister, METH_O, NULL},
	 { "_object_cast_to_VesicleTraffickingSingletonScore", _wrap__object_cast_to_VesicleTraffickingSingletonScore, METH_O, "_object_cast_to_VesicleTraffickingSingletonScore(Object o) -> VesicleTraffickingSingletonScore"},
	 { "_object_cast_to_InsulinSecretionOptimizerState", _wrap__object_cast_to_InsulinSecretionOptimizerState, METH_O, "_object_cast_to_InsulinSecretionOptimizerState(Object o) -> InsulinSecretionOptimizerState"},
	 { "_object_cast_to_CaChannelOpeningOptimizerState", _wrap__object_cast_to_CaChannelOpeningOptimizerState, METH_O, "_object_cast_to_CaChannelOpeningOptimizerState(Object o) -> CaChannelOpeningOptimizerState"},
	 { "_object_cast_to_VesicleDockingOptimizerState", _wrap__object_cast_to_VesicleDockingOptimizerState, METH_O, "_object_cast_to_VesicleDockingOptimizerState(Object o) -> VesicleDockingOptimizerState"},
	 { "_object_cast_to_RadialDistributionFunctionSingletonScore", _wrap__object_cast_to_RadialDistributionFunctionSingletonScore, METH_O, "_object_cast_to_RadialDistributionFunctionSingletonScore(Object o) -> RadialDistributionFunctionSingletonScore"},
	 { "new_VesicleTraffickingSingletonScore", _wrap_new_VesicleTraffickingSingletonScore, METH_VARARGS, "new_VesicleTraffickingSingletonScore(Vector3D center, double k) -> VesicleTraffickingSingletonScore"},
	 { "VesicleTraffickingSingletonScore_set_k", _wrap_VesicleTraffickingSingletonScore_set_k, METH_VARARGS, "VesicleTraffickingSingletonScore_set_k(VesicleTraffickingSingletonScore self, double k)"},
	 { "VesicleTraffickingSingletonScore_get_k", _wrap_VesicleTraffickingSingletonScore_get_k, METH_O, "VesicleTraffickingSingletonScore_get_k(VesicleTraffickingSingletonScore self) -> double"},
	 { "VesicleTraffickingSingletonScore_do_get_inputs", _wrap_VesicleTraffickingSingletonScore_do_get_inputs, METH_VARARGS, "VesicleTraffickingSingletonScore_do_get_inputs(VesicleTraffickingSingletonScore self, Model m, IMP::ParticleIndexes const & pis) -> IMP::ModelObjectsTemp"},
	 { "VesicleTraffickingSingletonScore_get_version_info", _wrap_VesicleTraffickingSingletonScore_get_version_info, METH_O, "VesicleTraffickingSingletonScore_get_version_info(VesicleTraffickingSingletonScore self) -> VersionInfo"},
	 { "delete_VesicleTraffickingSingletonScore", _wrap_delete_VesicleTraffickingSingletonScore, METH_O, "delete_VesicleTraffickingSingletonScore(VesicleTraffickingSingletonScore self)"},
	 { "VesicleTraffickingSingletonScore___str__", _wrap_VesicleTraffickingSingletonScore___str__, METH_O, "VesicleTraffickingSingletonScore___str__(VesicleTraffickingSingletonScore self) -> std::string"},
	 { "VesicleTraffickingSingletonScore___repr__", _wrap_VesicleTraffickingSingletonScore___repr__, METH_O, "VesicleTraffickingSingletonScore___repr__(VesicleTraffickingSingletonScore self) -> std::string"},
	 { "VesicleTraffickingSingletonScore_swigregister", VesicleTraffickingSingletonScore_swigregister, METH_O, NULL},
	 { "VesicleTraffickingSingletonScore_swiginit", VesicleTraffickingSingletonScore_swiginit, METH_VARARGS, NULL},
	 { "new_InsulinSecretionOptimizerState", _wrap_new_InsulinSecretionOptimizerState, METH_VARARGS, "InsulinSecretionOptimizerState(Model m, _ParticleIndexesAdaptor vesicles, Sphere3D nucleus_sphere, int ready_state, double cut_off, unsigned int periodicity=1)"},
	 { "InsulinSecretionOptimizerState_set_cut_off", _wrap_InsulinSecretionOptimizerState_set_cut_off, METH_VARARGS, "InsulinSecretionOptimizerState_set_cut_off(InsulinSecretionOptimizerState self, double cut_off)"},
	 { "InsulinSecretionOptimizerState_get_cut_off", _wrap_InsulinSecretionOptimizerState_get_cut_off, METH_O, "InsulinSecretionOptimizerState_get_cut_off(InsulinSecretionOptimizerState self) -> double"},
	 { "InsulinSecretionOptimizerState_set_vesicles", _wrap_InsulinSecretionOptimizerState_set_vesicles, METH_VARARGS, "InsulinSecretionOptimizerState_set_vesicles(InsulinSecretionOptimizerState self, IMP::Particles const & vesicles)"},
	 { "InsulinSecretionOptimizerState_get_version_info", _wrap_InsulinSecretionOptimizerState_get_version_info, METH_O, "InsulinSecretionOptimizerState_get_version_info(InsulinSecretionOptimizerState self) -> VersionInfo"},
	 { "delete_InsulinSecretionOptimizerState", _wrap_delete_InsulinSecretionOptimizerState, METH_O, "delete_InsulinSecretionOptimizerState(InsulinSecretionOptimizerState self)"},
	 { "InsulinSecretionOptimizerState___str__", _wrap_InsulinSecretionOptimizerState___str__, METH_O, "InsulinSecretionOptimizerState___str__(InsulinSecretionOptimizerState self) -> std::string"},
	 { "InsulinSecretionOptimizerState___repr__", _wrap_InsulinSecretionOptimizerState___repr__, METH_O, "InsulinSecretionOptimizerState___repr__(InsulinSecretionOptimizerState self) -> std::string"},
	 { "InsulinSecretionOptimizerState_swigregister", InsulinSecretionOptimizerState_swigregister, METH_O, NULL},
	 { "InsulinSecretionOptimizerState_swiginit", InsulinSecretionOptimizerState_swiginit, METH_VARARGS, NULL},
	 { "new_CaChannelOpeningOptimizerState", _wrap_new_CaChannelOpeningOptimizerState, METH_VARARGS, "CaChannelOpeningOptimizerState(Model m, _ParticleIndexesAdaptor cachannel, int oscillation, int troughn, int peakn, unsigned int periodicity=1)"},
	 { "CaChannelOpeningOptimizerState_set_cachannel", _wrap_CaChannelOpeningOptimizerState_set_cachannel, METH_VARARGS, "CaChannelOpeningOptimizerState_set_cachannel(CaChannelOpeningOptimizerState self, IMP::Particles const & cachannel)"},
	 { "CaChannelOpeningOptimizerState_get_version_info", _wrap_CaChannelOpeningOptimizerState_get_version_info, METH_O, "CaChannelOpeningOptimizerState_get_version_info(CaChannelOpeningOptimizerState self) -> VersionInfo"},
	 { "delete_CaChannelOpeningOptimizerState", _wrap_delete_CaChannelOpeningOptimizerState, METH_O, "delete_CaChannelOpeningOptimizerState(CaChannelOpeningOptimizerState self)"},
	 { "CaChannelOpeningOptimizerState___str__", _wrap_CaChannelOpeningOptimizerState___str__, METH_O, "CaChannelOpeningOptimizerState___str__(CaChannelOpeningOptimizerState self) -> std::string"},
	 { "CaChannelOpeningOptimizerState___repr__", _wrap_CaChannelOpeningOptimizerState___repr__, METH_O, "CaChannelOpeningOptimizerState___repr__(CaChannelOpeningOptimizerState self) -> std::string"},
	 { "CaChannelOpeningOptimizerState_swigregister", CaChannelOpeningOptimizerState_swigregister, METH_O, NULL},
	 { "CaChannelOpeningOptimizerState_swiginit", CaChannelOpeningOptimizerState_swiginit, METH_VARARGS, NULL},
	 { "new_VesicleDockingOptimizerState", _wrap_new_VesicleDockingOptimizerState, METH_VARARGS, "VesicleDockingOptimizerState(_SingletonContainerAdaptor vesicles_container, _SingletonContainerAdaptor cachannel_container, double contact_range, double slack, int ready_state, unsigned int periodicity=1)"},
	 { "VesicleDockingOptimizerState_get_version_info", _wrap_VesicleDockingOptimizerState_get_version_info, METH_O, "VesicleDockingOptimizerState_get_version_info(VesicleDockingOptimizerState self) -> VersionInfo"},
	 { "delete_VesicleDockingOptimizerState", _wrap_delete_VesicleDockingOptimizerState, METH_O, "delete_VesicleDockingOptimizerState(VesicleDockingOptimizerState self)"},
	 { "VesicleDockingOptimizerState___str__", _wrap_VesicleDockingOptimizerState___str__, METH_O, "VesicleDockingOptimizerState___str__(VesicleDockingOptimizerState self) -> std::string"},
	 { "VesicleDockingOptimizerState___repr__", _wrap_VesicleDockingOptimizerState___repr__, METH_O, "VesicleDockingOptimizerState___repr__(VesicleDockingOptimizerState self) -> std::string"},
	 { "VesicleDockingOptimizerState_swigregister", VesicleDockingOptimizerState_swigregister, METH_O, NULL},
	 { "VesicleDockingOptimizerState_swiginit", VesicleDockingOptimizerState_swiginit, METH_VARARGS, NULL},
	 { "new_RadialDistributionFunctionSingletonScore", _wrap_new_RadialDistributionFunctionSingletonScore, METH_VARARGS, "new_RadialDistributionFunctionSingletonScore(Sphere3D cell_sphere, Sphere3D nucleus_sphere, IMP::Floats poly_param, double k) -> RadialDistributionFunctionSingletonScore"},
	 { "RadialDistributionFunctionSingletonScore_set_k", _wrap_RadialDistributionFunctionSingletonScore_set_k, METH_VARARGS, "RadialDistributionFunctionSingletonScore_set_k(RadialDistributionFunctionSingletonScore self, double k)"},
	 { "RadialDistributionFunctionSingletonScore_get_k", _wrap_RadialDistributionFunctionSingletonScore_get_k, METH_O, "RadialDistributionFunctionSingletonScore_get_k(RadialDistributionFunctionSingletonScore self) -> double"},
	 { "RadialDistributionFunctionSingletonScore_set_cell_sphere", _wrap_RadialDistributionFunctionSingletonScore_set_cell_sphere, METH_VARARGS, "RadialDistributionFunctionSingletonScore_set_cell_sphere(RadialDistributionFunctionSingletonScore self, Sphere3D cell_sphere)"},
	 { "RadialDistributionFunctionSingletonScore_get_cell_sphere", _wrap_RadialDistributionFunctionSingletonScore_get_cell_sphere, METH_O, "RadialDistributionFunctionSingletonScore_get_cell_sphere(RadialDistributionFunctionSingletonScore self) -> Sphere3D"},
	 { "RadialDistributionFunctionSingletonScore_set_nucleus_sphere", _wrap_RadialDistributionFunctionSingletonScore_set_nucleus_sphere, METH_VARARGS, "RadialDistributionFunctionSingletonScore_set_nucleus_sphere(RadialDistributionFunctionSingletonScore self, Sphere3D nucleus_sphere)"},
	 { "RadialDistributionFunctionSingletonScore_get_nucleus_sphere", _wrap_RadialDistributionFunctionSingletonScore_get_nucleus_sphere, METH_O, "RadialDistributionFunctionSingletonScore_get_nucleus_sphere(RadialDistributionFunctionSingletonScore self) -> Sphere3D"},
	 { "RadialDistributionFunctionSingletonScore_set_poly_param", _wrap_RadialDistributionFunctionSingletonScore_set_poly_param, METH_VARARGS, "RadialDistributionFunctionSingletonScore_set_poly_param(RadialDistributionFunctionSingletonScore self, IMP::Floats poly_param)"},
	 { "RadialDistributionFunctionSingletonScore_get_poly_param", _wrap_RadialDistributionFunctionSingletonScore_get_poly_param, METH_O, "RadialDistributionFunctionSingletonScore_get_poly_param(RadialDistributionFunctionSingletonScore self) -> IMP::Floats"},
	 { "RadialDistributionFunctionSingletonScore_do_get_inputs", _wrap_RadialDistributionFunctionSingletonScore_do_get_inputs, METH_VARARGS, "RadialDistributionFunctionSingletonScore_do_get_inputs(RadialDistributionFunctionSingletonScore self, Model m, IMP::ParticleIndexes const & pis) -> IMP::ModelObjectsTemp"},
	 { "RadialDistributionFunctionSingletonScore_get_version_info", _wrap_RadialDistributionFunctionSingletonScore_get_version_info, METH_O, "RadialDistributionFunctionSingletonScore_get_version_info(RadialDistributionFunctionSingletonScore self) -> VersionInfo"},
	 { "delete_RadialDistributionFunctionSingletonScore", _wrap_delete_RadialDistributionFunctionSingletonScore, METH_O, "delete_RadialDistributionFunctionSingletonScore(RadialDistributionFunctionSingletonScore self)"},
	 { "RadialDistributionFunctionSingletonScore___str__", _wrap_RadialDistributionFunctionSingletonScore___str__, METH_O, "RadialDistributionFunctionSingletonScore___str__(RadialDistributionFunctionSingletonScore self) -> std::string"},
	 { "RadialDistributionFunctionSingletonScore___repr__", _wrap_RadialDistributionFunctionSingletonScore___repr__, METH_O, "RadialDistributionFunctionSingletonScore___repr__(RadialDistributionFunctionSingletonScore self) -> std::string"},
	 { "RadialDistributionFunctionSingletonScore_swigregister", RadialDistributionFunctionSingletonScore_swigregister, METH_O, NULL},
	 { "RadialDistributionFunctionSingletonScore_swiginit", RadialDistributionFunctionSingletonScore_swiginit, METH_VARARGS, NULL},
	 { "SecretionCounterDecorator_get_secretion", _wrap_SecretionCounterDecorator_get_secretion, METH_O, "SecretionCounterDecorator_get_secretion(SecretionCounterDecorator self) -> IMP::Int"},
	 { "SecretionCounterDecorator_set_secretion", _wrap_SecretionCounterDecorator_set_secretion, METH_VARARGS, "SecretionCounterDecorator_set_secretion(SecretionCounterDecorator self, IMP::Int d)"},
	 { "new_SecretionCounterDecorator", _wrap_new_SecretionCounterDecorator, METH_VARARGS, "\n"
		"SecretionCounterDecorator()\n"
		"SecretionCounterDecorator(Model m, ParticleIndex id)\n"
		"new_SecretionCounterDecorator(_ParticleAdaptor d) -> SecretionCounterDecorator\n"
		""},
	 { "SecretionCounterDecorator_get_is_setup", _wrap_SecretionCounterDecorator_get_is_setup, METH_VARARGS, "\n"
		"SecretionCounterDecorator_get_is_setup(Model m, ParticleIndex pi) -> bool\n"
		"SecretionCounterDecorator_get_is_setup(_ParticleAdaptor p) -> bool\n"
		""},
	 { "SecretionCounterDecorator_show", _wrap_SecretionCounterDecorator_show, METH_VARARGS, "SecretionCounterDecorator_show(SecretionCounterDecorator self, _ostream out=std::cout)"},
	 { "SecretionCounterDecorator_setup_particle", _wrap_SecretionCounterDecorator_setup_particle, METH_VARARGS, "\n"
		"SecretionCounterDecorator_setup_particle(Model m, ParticleIndex pi, IMP::Int secretion) -> SecretionCounterDecorator\n"
		"SecretionCounterDecorator_setup_particle(_ParticleAdaptor pa, IMP::Int secretion) -> SecretionCounterDecorator\n"
		"SecretionCounterDecorator_setup_particle(Model m, ParticleIndex pi, SecretionCounterDecorator other) -> SecretionCounterDecorator\n"
		"SecretionCounterDecorator_setup_particle(_ParticleAdaptor pa, SecretionCounterDecorator other) -> SecretionCounterDecorator\n"
		""},
	 { "SecretionCounterDecorator_get_secretion_key", _wrap_SecretionCounterDecorator_get_secretion_key, METH_NOARGS, "SecretionCounterDecorator_get_secretion_key() -> IntKey"},
	 { "SecretionCounterDecorator_add_attribute", _wrap_SecretionCounterDecorator_add_attribute, METH_VARARGS, "\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, FloatKey k, IMP::Float v, bool opt)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, FloatKey a0, IMP::Float a1)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, IntKey a0, IMP::Int a1)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, FloatsKey a0, IMP::Floats a1)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, IntsKey a0, IMP::Ints a1)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, StringKey a0, IMP::String a1)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, ParticleIndexKey a0, Particle a1)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, ObjectKey a0, Object a1)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, SparseFloatKey a0, IMP::Float a1)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, SparseIntKey a0, IMP::Int a1)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, SparseStringKey a0, IMP::String a1)\n"
		"SecretionCounterDecorator_add_attribute(SecretionCounterDecorator self, SparseParticleIndexKey a0, ParticleIndex a1)\n"
		""},
	 { "SecretionCounterDecorator_get_value", _wrap_SecretionCounterDecorator_get_value, METH_VARARGS, "\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, FloatKey a0) -> IMP::Float\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, IntKey a0) -> IMP::Int\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, FloatsKey a0) -> IMP::Floats\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, IntsKey a0) -> IMP::Ints\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, StringKey a0) -> IMP::String\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, ParticleIndexKey a0) -> Particle\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, ObjectKey a0) -> Object\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, SparseFloatKey a0) -> IMP::Float\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, SparseIntKey a0) -> IMP::Int\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, SparseStringKey a0) -> IMP::String\n"
		"SecretionCounterDecorator_get_value(SecretionCounterDecorator self, SparseParticleIndexKey a0) -> ParticleIndex\n"
		""},
	 { "SecretionCounterDecorator_set_value", _wrap_SecretionCounterDecorator_set_value, METH_VARARGS, "\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, FloatKey a0, IMP::Float a1)\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, IntKey a0, IMP::Int a1)\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, FloatsKey a0, IMP::Floats a1)\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, IntsKey a0, IMP::Ints a1)\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, StringKey a0, IMP::String a1)\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, ParticleIndexKey a0, Particle a1)\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, ObjectKey a0, Object a1)\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, SparseFloatKey a0, IMP::Float a1)\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, SparseIntKey a0, IMP::Int a1)\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, SparseStringKey a0, IMP::String a1)\n"
		"SecretionCounterDecorator_set_value(SecretionCounterDecorator self, SparseParticleIndexKey a0, ParticleIndex a1)\n"
		""},
	 { "SecretionCounterDecorator_remove_attribute", _wrap_SecretionCounterDecorator_remove_attribute, METH_VARARGS, "\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, FloatKey a0)\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, IntKey a0)\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, FloatsKey a0)\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, IntsKey a0)\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, StringKey a0)\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, ParticleIndexKey a0)\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, ObjectKey a0)\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, SparseFloatKey a0)\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, SparseIntKey a0)\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, SparseStringKey a0)\n"
		"SecretionCounterDecorator_remove_attribute(SecretionCounterDecorator self, SparseParticleIndexKey a0)\n"
		""},
	 { "SecretionCounterDecorator_has_attribute", _wrap_SecretionCounterDecorator_has_attribute, METH_VARARGS, "\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, FloatKey a0) -> bool\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, IntKey a0) -> bool\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, FloatsKey a0) -> bool\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, IntsKey a0) -> bool\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, StringKey a0) -> bool\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, ParticleIndexKey a0) -> bool\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, ObjectKey a0) -> bool\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, SparseFloatKey a0) -> bool\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, SparseIntKey a0) -> bool\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, SparseStringKey a0) -> bool\n"
		"SecretionCounterDecorator_has_attribute(SecretionCounterDecorator self, SparseParticleIndexKey a0) -> bool\n"
		""},
	 { "SecretionCounterDecorator_get_derivative", _wrap_SecretionCounterDecorator_get_derivative, METH_VARARGS, "SecretionCounterDecorator_get_derivative(SecretionCounterDecorator self, FloatKey a0) -> double"},
	 { "SecretionCounterDecorator_get_name", _wrap_SecretionCounterDecorator_get_name, METH_O, "SecretionCounterDecorator_get_name(SecretionCounterDecorator self) -> std::string"},
	 { "SecretionCounterDecorator_clear_caches", _wrap_SecretionCounterDecorator_clear_caches, METH_O, "SecretionCounterDecorator_clear_caches(SecretionCounterDecorator self)"},
	 { "SecretionCounterDecorator_set_name", _wrap_SecretionCounterDecorator_set_name, METH_VARARGS, "SecretionCounterDecorator_set_name(SecretionCounterDecorator self, std::string a0)"},
	 { "SecretionCounterDecorator_set_check_level", _wrap_SecretionCounterDecorator_set_check_level, METH_VARARGS, "SecretionCounterDecorator_set_check_level(SecretionCounterDecorator self, IMP::CheckLevel a0)"},
	 { "SecretionCounterDecorator_add_to_derivative", _wrap_SecretionCounterDecorator_add_to_derivative, METH_VARARGS, "SecretionCounterDecorator_add_to_derivative(SecretionCounterDecorator self, FloatKey a0, double a1, DerivativeAccumulator a2)"},
	 { "SecretionCounterDecorator_set_is_optimized", _wrap_SecretionCounterDecorator_set_is_optimized, METH_VARARGS, "SecretionCounterDecorator_set_is_optimized(SecretionCounterDecorator self, FloatKey a0, bool a1)"},
	 { "SecretionCounterDecorator_get_is_optimized", _wrap_SecretionCounterDecorator_get_is_optimized, METH_VARARGS, "SecretionCounterDecorator_get_is_optimized(SecretionCounterDecorator self, FloatKey a0) -> bool"},
	 { "SecretionCounterDecorator_get_check_level", _wrap_SecretionCounterDecorator_get_check_level, METH_O, "SecretionCounterDecorator_get_check_level(SecretionCounterDecorator self) -> IMP::CheckLevel"},
	 { "SecretionCounterDecorator___eq__", _wrap_SecretionCounterDecorator___eq__, METH_VARARGS, "\n"
		"SecretionCounterDecorator___eq__(SecretionCounterDecorator self, SecretionCounterDecorator o) -> bool\n"
		"SecretionCounterDecorator___eq__(SecretionCounterDecorator self, Particle d) -> bool\n"
		""},
	 { "SecretionCounterDecorator___ne__", _wrap_SecretionCounterDecorator___ne__, METH_VARARGS, "\n"
		"SecretionCounterDecorator___ne__(SecretionCounterDecorator self, SecretionCounterDecorator o) -> bool\n"
		"SecretionCounterDecorator___ne__(SecretionCounterDecorator self, Particle d) -> bool\n"
		""},
	 { "SecretionCounterDecorator___le__", _wrap_SecretionCounterDecorator___le__, METH_VARARGS, "\n"
		"SecretionCounterDecorator___le__(SecretionCounterDecorator self, SecretionCounterDecorator o) -> bool\n"
		"SecretionCounterDecorator___le__(SecretionCounterDecorator self, Particle d) -> bool\n"
		""},
	 { "SecretionCounterDecorator___lt__", _wrap_SecretionCounterDecorator___lt__, METH_VARARGS, "\n"
		"SecretionCounterDecorator___lt__(SecretionCounterDecorator self, SecretionCounterDecorator o) -> bool\n"
		"SecretionCounterDecorator___lt__(SecretionCounterDecorator self, Particle d) -> bool\n"
		""},
	 { "SecretionCounterDecorator___ge__", _wrap_SecretionCounterDecorator___ge__, METH_VARARGS, "\n"
		"SecretionCounterDecorator___ge__(SecretionCounterDecorator self, SecretionCounterDecorator o) -> bool\n"
		"SecretionCounterDecorator___ge__(SecretionCounterDecorator self, Particle d) -> bool\n"
		""},
	 { "SecretionCounterDecorator___gt__", _wrap_SecretionCounterDecorator___gt__, METH_VARARGS, "\n"
		"SecretionCounterDecorator___gt__(SecretionCounterDecorator self, SecretionCounterDecorator o) -> bool\n"
		"SecretionCounterDecorator___gt__(SecretionCounterDecorator self, Particle d) -> bool\n"
		""},
	 { "SecretionCounterDecorator___hash__", _wrap_SecretionCounterDecorator___hash__, METH_O, "SecretionCounterDecorator___hash__(SecretionCounterDecorator self) -> std::size_t"},
	 { "SecretionCounterDecorator___str__", _wrap_SecretionCounterDecorator___str__, METH_O, "SecretionCounterDecorator___str__(SecretionCounterDecorator self) -> std::string"},
	 { "SecretionCounterDecorator___repr__", _wrap_SecretionCounterDecorator___repr__, METH_O, "SecretionCounterDecorator___repr__(SecretionCounterDecorator self) -> std::string"},
	 { "SecretionCounterDecorator__get_as_binary", _wrap_SecretionCounterDecorator__get_as_binary, METH_O, "SecretionCounterDecorator__get_as_binary(SecretionCounterDecorator self) -> PyObject *"},
	 { "SecretionCounterDecorator__set_from_binary", _wrap_SecretionCounterDecorator__set_from_binary, METH_VARARGS, "SecretionCounterDecorator__set_from_binary(SecretionCounterDecorator self, PyObject * p)"},
	 { "delete_SecretionCounterDecorator", _wrap_delete_SecretionCounterDecorator, METH_O, "delete_SecretionCounterDecorator(SecretionCounterDecorator self)"},
	 { "SecretionCounterDecorator_swigregister", SecretionCounterDecorator_swigregister, METH_O, NULL},
	 { "SecretionCounterDecorator_swiginit", SecretionCounterDecorator_swiginit, METH_VARARGS, NULL},
	 { "MaturationStateDecorator_get_state", _wrap_MaturationStateDecorator_get_state, METH_O, "MaturationStateDecorator_get_state(MaturationStateDecorator self) -> IMP::Int"},
	 { "MaturationStateDecorator_set_state", _wrap_MaturationStateDecorator_set_state, METH_VARARGS, "MaturationStateDecorator_set_state(MaturationStateDecorator self, IMP::Int d)"},
	 { "new_MaturationStateDecorator", _wrap_new_MaturationStateDecorator, METH_VARARGS, "\n"
		"MaturationStateDecorator()\n"
		"MaturationStateDecorator(Model m, ParticleIndex id)\n"
		"new_MaturationStateDecorator(_ParticleAdaptor d) -> MaturationStateDecorator\n"
		""},
	 { "MaturationStateDecorator_get_is_setup", _wrap_MaturationStateDecorator_get_is_setup, METH_VARARGS, "\n"
		"MaturationStateDecorator_get_is_setup(Model m, ParticleIndex pi) -> bool\n"
		"MaturationStateDecorator_get_is_setup(_ParticleAdaptor p) -> bool\n"
		""},
	 { "MaturationStateDecorator_show", _wrap_MaturationStateDecorator_show, METH_VARARGS, "MaturationStateDecorator_show(MaturationStateDecorator self, _ostream out=std::cout)"},
	 { "MaturationStateDecorator_setup_particle", _wrap_MaturationStateDecorator_setup_particle, METH_VARARGS, "\n"
		"MaturationStateDecorator_setup_particle(Model m, ParticleIndex pi, IMP::Int state) -> MaturationStateDecorator\n"
		"MaturationStateDecorator_setup_particle(_ParticleAdaptor pa, IMP::Int state) -> MaturationStateDecorator\n"
		"MaturationStateDecorator_setup_particle(Model m, ParticleIndex pi, MaturationStateDecorator other) -> MaturationStateDecorator\n"
		"MaturationStateDecorator_setup_particle(_ParticleAdaptor pa, MaturationStateDecorator other) -> MaturationStateDecorator\n"
		""},
	 { "MaturationStateDecorator_get_state_key", _wrap_MaturationStateDecorator_get_state_key, METH_NOARGS, "MaturationStateDecorator_get_state_key() -> IntKey"},
	 { "MaturationStateDecorator_add_attribute", _wrap_MaturationStateDecorator_add_attribute, METH_VARARGS, "\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, FloatKey k, IMP::Float v, bool opt)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, FloatKey a0, IMP::Float a1)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, IntKey a0, IMP::Int a1)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, FloatsKey a0, IMP::Floats a1)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, IntsKey a0, IMP::Ints a1)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, StringKey a0, IMP::String a1)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, ParticleIndexKey a0, Particle a1)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, ObjectKey a0, Object a1)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, SparseFloatKey a0, IMP::Float a1)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, SparseIntKey a0, IMP::Int a1)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, SparseStringKey a0, IMP::String a1)\n"
		"MaturationStateDecorator_add_attribute(MaturationStateDecorator self, SparseParticleIndexKey a0, ParticleIndex a1)\n"
		""},
	 { "MaturationStateDecorator_get_value", _wrap_MaturationStateDecorator_get_value, METH_VARARGS, "\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, FloatKey a0) -> IMP::Float\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, IntKey a0) -> IMP::Int\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, FloatsKey a0) -> IMP::Floats\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, IntsKey a0) -> IMP::Ints\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, StringKey a0) -> IMP::String\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, ParticleIndexKey a0) -> Particle\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, ObjectKey a0) -> Object\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, SparseFloatKey a0) -> IMP::Float\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, SparseIntKey a0) -> IMP::Int\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, SparseStringKey a0) -> IMP::String\n"
		"MaturationStateDecorator_get_value(MaturationStateDecorator self, SparseParticleIndexKey a0) -> ParticleIndex\n"
		""},
	 { "MaturationStateDecorator_set_value", _wrap_MaturationStateDecorator_set_value, METH_VARARGS, "\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, FloatKey a0, IMP::Float a1)\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, IntKey a0, IMP::Int a1)\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, FloatsKey a0, IMP::Floats a1)\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, IntsKey a0, IMP::Ints a1)\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, StringKey a0, IMP::String a1)\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, ParticleIndexKey a0, Particle a1)\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, ObjectKey a0, Object a1)\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, SparseFloatKey a0, IMP::Float a1)\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, SparseIntKey a0, IMP::Int a1)\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, SparseStringKey a0, IMP::String a1)\n"
		"MaturationStateDecorator_set_value(MaturationStateDecorator self, SparseParticleIndexKey a0, ParticleIndex a1)\n"
		""},
	 { "MaturationStateDecorator_remove_attribute", _wrap_MaturationStateDecorator_remove_attribute, METH_VARARGS, "\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, FloatKey a0)\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, IntKey a0)\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, FloatsKey a0)\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, IntsKey a0)\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, StringKey a0)\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, ParticleIndexKey a0)\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, ObjectKey a0)\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, SparseFloatKey a0)\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, SparseIntKey a0)\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, SparseStringKey a0)\n"
		"MaturationStateDecorator_remove_attribute(MaturationStateDecorator self, SparseParticleIndexKey a0)\n"
		""},
	 { "MaturationStateDecorator_has_attribute", _wrap_MaturationStateDecorator_has_attribute, METH_VARARGS, "\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, FloatKey a0) -> bool\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, IntKey a0) -> bool\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, FloatsKey a0) -> bool\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, IntsKey a0) -> bool\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, StringKey a0) -> bool\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, ParticleIndexKey a0) -> bool\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, ObjectKey a0) -> bool\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, SparseFloatKey a0) -> bool\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, SparseIntKey a0) -> bool\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, SparseStringKey a0) -> bool\n"
		"MaturationStateDecorator_has_attribute(MaturationStateDecorator self, SparseParticleIndexKey a0) -> bool\n"
		""},
	 { "MaturationStateDecorator_get_derivative", _wrap_MaturationStateDecorator_get_derivative, METH_VARARGS, "MaturationStateDecorator_get_derivative(MaturationStateDecorator self, FloatKey a0) -> double"},
	 { "MaturationStateDecorator_get_name", _wrap_MaturationStateDecorator_get_name, METH_O, "MaturationStateDecorator_get_name(MaturationStateDecorator self) -> std::string"},
	 { "MaturationStateDecorator_clear_caches", _wrap_MaturationStateDecorator_clear_caches, METH_O, "MaturationStateDecorator_clear_caches(MaturationStateDecorator self)"},
	 { "MaturationStateDecorator_set_name", _wrap_MaturationStateDecorator_set_name, METH_VARARGS, "MaturationStateDecorator_set_name(MaturationStateDecorator self, std::string a0)"},
	 { "MaturationStateDecorator_set_check_level", _wrap_MaturationStateDecorator_set_check_level, METH_VARARGS, "MaturationStateDecorator_set_check_level(MaturationStateDecorator self, IMP::CheckLevel a0)"},
	 { "MaturationStateDecorator_add_to_derivative", _wrap_MaturationStateDecorator_add_to_derivative, METH_VARARGS, "MaturationStateDecorator_add_to_derivative(MaturationStateDecorator self, FloatKey a0, double a1, DerivativeAccumulator a2)"},
	 { "MaturationStateDecorator_set_is_optimized", _wrap_MaturationStateDecorator_set_is_optimized, METH_VARARGS, "MaturationStateDecorator_set_is_optimized(MaturationStateDecorator self, FloatKey a0, bool a1)"},
	 { "MaturationStateDecorator_get_is_optimized", _wrap_MaturationStateDecorator_get_is_optimized, METH_VARARGS, "MaturationStateDecorator_get_is_optimized(MaturationStateDecorator self, FloatKey a0) -> bool"},
	 { "MaturationStateDecorator_get_check_level", _wrap_MaturationStateDecorator_get_check_level, METH_O, "MaturationStateDecorator_get_check_level(MaturationStateDecorator self) -> IMP::CheckLevel"},
	 { "MaturationStateDecorator___eq__", _wrap_MaturationStateDecorator___eq__, METH_VARARGS, "\n"
		"MaturationStateDecorator___eq__(MaturationStateDecorator self, MaturationStateDecorator o) -> bool\n"
		"MaturationStateDecorator___eq__(MaturationStateDecorator self, Particle d) -> bool\n"
		""},
	 { "MaturationStateDecorator___ne__", _wrap_MaturationStateDecorator___ne__, METH_VARARGS, "\n"
		"MaturationStateDecorator___ne__(MaturationStateDecorator self, MaturationStateDecorator o) -> bool\n"
		"MaturationStateDecorator___ne__(MaturationStateDecorator self, Particle d) -> bool\n"
		""},
	 { "MaturationStateDecorator___le__", _wrap_MaturationStateDecorator___le__, METH_VARARGS, "\n"
		"MaturationStateDecorator___le__(MaturationStateDecorator self, MaturationStateDecorator o) -> bool\n"
		"MaturationStateDecorator___le__(MaturationStateDecorator self, Particle d) -> bool\n"
		""},
	 { "MaturationStateDecorator___lt__", _wrap_MaturationStateDecorator___lt__, METH_VARARGS, "\n"
		"MaturationStateDecorator___lt__(MaturationStateDecorator self, MaturationStateDecorator o) -> bool\n"
		"MaturationStateDecorator___lt__(MaturationStateDecorator self, Particle d) -> bool\n"
		""},
	 { "MaturationStateDecorator___ge__", _wrap_MaturationStateDecorator___ge__, METH_VARARGS, "\n"
		"MaturationStateDecorator___ge__(MaturationStateDecorator self, MaturationStateDecorator o) -> bool\n"
		"MaturationStateDecorator___ge__(MaturationStateDecorator self, Particle d) -> bool\n"
		""},
	 { "MaturationStateDecorator___gt__", _wrap_MaturationStateDecorator___gt__, METH_VARARGS, "\n"
		"MaturationStateDecorator___gt__(MaturationStateDecorator self, MaturationStateDecorator o) -> bool\n"
		"MaturationStateDecorator___gt__(MaturationStateDecorator self, Particle d) -> bool\n"
		""},
	 { "MaturationStateDecorator___hash__", _wrap_MaturationStateDecorator___hash__, METH_O, "MaturationStateDecorator___hash__(MaturationStateDecorator self) -> std::size_t"},
	 { "MaturationStateDecorator___str__", _wrap_MaturationStateDecorator___str__, METH_O, "MaturationStateDecorator___str__(MaturationStateDecorator self) -> std::string"},
	 { "MaturationStateDecorator___repr__", _wrap_MaturationStateDecorator___repr__, METH_O, "MaturationStateDecorator___repr__(MaturationStateDecorator self) -> std::string"},
	 { "MaturationStateDecorator__get_as_binary", _wrap_MaturationStateDecorator__get_as_binary, METH_O, "MaturationStateDecorator__get_as_binary(MaturationStateDecorator self) -> PyObject *"},
	 { "MaturationStateDecorator__set_from_binary", _wrap_MaturationStateDecorator__set_from_binary, METH_VARARGS, "MaturationStateDecorator__set_from_binary(MaturationStateDecorator self, PyObject * p)"},
	 { "delete_MaturationStateDecorator", _wrap_delete_MaturationStateDecorator, METH_O, "delete_MaturationStateDecorator(MaturationStateDecorator self)"},
	 { "MaturationStateDecorator_swigregister", MaturationStateDecorator_swigregister, METH_O, NULL},
	 { "MaturationStateDecorator_swiginit", MaturationStateDecorator_swiginit, METH_VARARGS, NULL},
	 { "DockingStateDecorator_get_dstate", _wrap_DockingStateDecorator_get_dstate, METH_O, "DockingStateDecorator_get_dstate(DockingStateDecorator self) -> IMP::Int"},
	 { "DockingStateDecorator_set_dstate", _wrap_DockingStateDecorator_set_dstate, METH_VARARGS, "DockingStateDecorator_set_dstate(DockingStateDecorator self, IMP::Int d)"},
	 { "new_DockingStateDecorator", _wrap_new_DockingStateDecorator, METH_VARARGS, "\n"
		"DockingStateDecorator()\n"
		"DockingStateDecorator(Model m, ParticleIndex id)\n"
		"new_DockingStateDecorator(_ParticleAdaptor d) -> DockingStateDecorator\n"
		""},
	 { "DockingStateDecorator_get_is_setup", _wrap_DockingStateDecorator_get_is_setup, METH_VARARGS, "\n"
		"DockingStateDecorator_get_is_setup(Model m, ParticleIndex pi) -> bool\n"
		"DockingStateDecorator_get_is_setup(_ParticleAdaptor p) -> bool\n"
		""},
	 { "DockingStateDecorator_show", _wrap_DockingStateDecorator_show, METH_VARARGS, "DockingStateDecorator_show(DockingStateDecorator self, _ostream out=std::cout)"},
	 { "DockingStateDecorator_setup_particle", _wrap_DockingStateDecorator_setup_particle, METH_VARARGS, "\n"
		"DockingStateDecorator_setup_particle(Model m, ParticleIndex pi, IMP::Int dstate) -> DockingStateDecorator\n"
		"DockingStateDecorator_setup_particle(_ParticleAdaptor pa, IMP::Int dstate) -> DockingStateDecorator\n"
		"DockingStateDecorator_setup_particle(Model m, ParticleIndex pi, DockingStateDecorator other) -> DockingStateDecorator\n"
		"DockingStateDecorator_setup_particle(_ParticleAdaptor pa, DockingStateDecorator other) -> DockingStateDecorator\n"
		""},
	 { "DockingStateDecorator_get_dstate_key", _wrap_DockingStateDecorator_get_dstate_key, METH_NOARGS, "DockingStateDecorator_get_dstate_key() -> IntKey"},
	 { "DockingStateDecorator_add_attribute", _wrap_DockingStateDecorator_add_attribute, METH_VARARGS, "\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, FloatKey k, IMP::Float v, bool opt)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, FloatKey a0, IMP::Float a1)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, IntKey a0, IMP::Int a1)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, FloatsKey a0, IMP::Floats a1)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, IntsKey a0, IMP::Ints a1)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, StringKey a0, IMP::String a1)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, ParticleIndexKey a0, Particle a1)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, ObjectKey a0, Object a1)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, SparseFloatKey a0, IMP::Float a1)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, SparseIntKey a0, IMP::Int a1)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, SparseStringKey a0, IMP::String a1)\n"
		"DockingStateDecorator_add_attribute(DockingStateDecorator self, SparseParticleIndexKey a0, ParticleIndex a1)\n"
		""},
	 { "DockingStateDecorator_get_value", _wrap_DockingStateDecorator_get_value, METH_VARARGS, "\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, FloatKey a0) -> IMP::Float\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, IntKey a0) -> IMP::Int\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, FloatsKey a0) -> IMP::Floats\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, IntsKey a0) -> IMP::Ints\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, StringKey a0) -> IMP::String\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, ParticleIndexKey a0) -> Particle\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, ObjectKey a0) -> Object\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, SparseFloatKey a0) -> IMP::Float\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, SparseIntKey a0) -> IMP::Int\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, SparseStringKey a0) -> IMP::String\n"
		"DockingStateDecorator_get_value(DockingStateDecorator self, SparseParticleIndexKey a0) -> ParticleIndex\n"
		""},
	 { "DockingStateDecorator_set_value", _wrap_DockingStateDecorator_set_value, METH_VARARGS, "\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, FloatKey a0, IMP::Float a1)\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, IntKey a0, IMP::Int a1)\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, FloatsKey a0, IMP::Floats a1)\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, IntsKey a0, IMP::Ints a1)\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, StringKey a0, IMP::String a1)\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, ParticleIndexKey a0, Particle a1)\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, ObjectKey a0, Object a1)\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, SparseFloatKey a0, IMP::Float a1)\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, SparseIntKey a0, IMP::Int a1)\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, SparseStringKey a0, IMP::String a1)\n"
		"DockingStateDecorator_set_value(DockingStateDecorator self, SparseParticleIndexKey a0, ParticleIndex a1)\n"
		""},
	 { "DockingStateDecorator_remove_attribute", _wrap_DockingStateDecorator_remove_attribute, METH_VARARGS, "\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, FloatKey a0)\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, IntKey a0)\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, FloatsKey a0)\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, IntsKey a0)\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, StringKey a0)\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, ParticleIndexKey a0)\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, ObjectKey a0)\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, SparseFloatKey a0)\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, SparseIntKey a0)\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, SparseStringKey a0)\n"
		"DockingStateDecorator_remove_attribute(DockingStateDecorator self, SparseParticleIndexKey a0)\n"
		""},
	 { "DockingStateDecorator_has_attribute", _wrap_DockingStateDecorator_has_attribute, METH_VARARGS, "\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, FloatKey a0) -> bool\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, IntKey a0) -> bool\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, FloatsKey a0) -> bool\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, IntsKey a0) -> bool\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, StringKey a0) -> bool\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, ParticleIndexKey a0) -> bool\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, ObjectKey a0) -> bool\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, SparseFloatKey a0) -> bool\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, SparseIntKey a0) -> bool\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, SparseStringKey a0) -> bool\n"
		"DockingStateDecorator_has_attribute(DockingStateDecorator self, SparseParticleIndexKey a0) -> bool\n"
		""},
	 { "DockingStateDecorator_get_derivative", _wrap_DockingStateDecorator_get_derivative, METH_VARARGS, "DockingStateDecorator_get_derivative(DockingStateDecorator self, FloatKey a0) -> double"},
	 { "DockingStateDecorator_get_name", _wrap_DockingStateDecorator_get_name, METH_O, "DockingStateDecorator_get_name(DockingStateDecorator self) -> std::string"},
	 { "DockingStateDecorator_clear_caches", _wrap_DockingStateDecorator_clear_caches, METH_O, "DockingStateDecorator_clear_caches(DockingStateDecorator self)"},
	 { "DockingStateDecorator_set_name", _wrap_DockingStateDecorator_set_name, METH_VARARGS, "DockingStateDecorator_set_name(DockingStateDecorator self, std::string a0)"},
	 { "DockingStateDecorator_set_check_level", _wrap_DockingStateDecorator_set_check_level, METH_VARARGS, "DockingStateDecorator_set_check_level(DockingStateDecorator self, IMP::CheckLevel a0)"},
	 { "DockingStateDecorator_add_to_derivative", _wrap_DockingStateDecorator_add_to_derivative, METH_VARARGS, "DockingStateDecorator_add_to_derivative(DockingStateDecorator self, FloatKey a0, double a1, DerivativeAccumulator a2)"},
	 { "DockingStateDecorator_set_is_optimized", _wrap_DockingStateDecorator_set_is_optimized, METH_VARARGS, "DockingStateDecorator_set_is_optimized(DockingStateDecorator self, FloatKey a0, bool a1)"},
	 { "DockingStateDecorator_get_is_optimized", _wrap_DockingStateDecorator_get_is_optimized, METH_VARARGS, "DockingStateDecorator_get_is_optimized(DockingStateDecorator self, FloatKey a0) -> bool"},
	 { "DockingStateDecorator_get_check_level", _wrap_DockingStateDecorator_get_check_level, METH_O, "DockingStateDecorator_get_check_level(DockingStateDecorator self) -> IMP::CheckLevel"},
	 { "DockingStateDecorator___eq__", _wrap_DockingStateDecorator___eq__, METH_VARARGS, "\n"
		"DockingStateDecorator___eq__(DockingStateDecorator self, DockingStateDecorator o) -> bool\n"
		"DockingStateDecorator___eq__(DockingStateDecorator self, Particle d) -> bool\n"
		""},
	 { "DockingStateDecorator___ne__", _wrap_DockingStateDecorator___ne__, METH_VARARGS, "\n"
		"DockingStateDecorator___ne__(DockingStateDecorator self, DockingStateDecorator o) -> bool\n"
		"DockingStateDecorator___ne__(DockingStateDecorator self, Particle d) -> bool\n"
		""},
	 { "DockingStateDecorator___le__", _wrap_DockingStateDecorator___le__, METH_VARARGS, "\n"
		"DockingStateDecorator___le__(DockingStateDecorator self, DockingStateDecorator o) -> bool\n"
		"DockingStateDecorator___le__(DockingStateDecorator self, Particle d) -> bool\n"
		""},
	 { "DockingStateDecorator___lt__", _wrap_DockingStateDecorator___lt__, METH_VARARGS, "\n"
		"DockingStateDecorator___lt__(DockingStateDecorator self, DockingStateDecorator o) -> bool\n"
		"DockingStateDecorator___lt__(DockingStateDecorator self, Particle d) -> bool\n"
		""},
	 { "DockingStateDecorator___ge__", _wrap_DockingStateDecorator___ge__, METH_VARARGS, "\n"
		"DockingStateDecorator___ge__(DockingStateDecorator self, DockingStateDecorator o) -> bool\n"
		"DockingStateDecorator___ge__(DockingStateDecorator self, Particle d) -> bool\n"
		""},
	 { "DockingStateDecorator___gt__", _wrap_DockingStateDecorator___gt__, METH_VARARGS, "\n"
		"DockingStateDecorator___gt__(DockingStateDecorator self, DockingStateDecorator o) -> bool\n"
		"DockingStateDecorator___gt__(DockingStateDecorator self, Particle d) -> bool\n"
		""},
	 { "DockingStateDecorator___hash__", _wrap_DockingStateDecorator___hash__, METH_O, "DockingStateDecorator___hash__(DockingStateDecorator self) -> std::size_t"},
	 { "DockingStateDecorator___str__", _wrap_DockingStateDecorator___str__, METH_O, "DockingStateDecorator___str__(DockingStateDecorator self) -> std::string"},
	 { "DockingStateDecorator___repr__", _wrap_DockingStateDecorator___repr__, METH_O, "DockingStateDecorator___repr__(DockingStateDecorator self) -> std::string"},
	 { "DockingStateDecorator__get_as_binary", _wrap_DockingStateDecorator__get_as_binary, METH_O, "DockingStateDecorator__get_as_binary(DockingStateDecorator self) -> PyObject *"},
	 { "DockingStateDecorator__set_from_binary", _wrap_DockingStateDecorator__set_from_binary, METH_VARARGS, "DockingStateDecorator__set_from_binary(DockingStateDecorator self, PyObject * p)"},
	 { "delete_DockingStateDecorator", _wrap_delete_DockingStateDecorator, METH_O, "delete_DockingStateDecorator(DockingStateDecorator self)"},
	 { "DockingStateDecorator_swigregister", DockingStateDecorator_swigregister, METH_O, NULL},
	 { "DockingStateDecorator_swiginit", DockingStateDecorator_swiginit, METH_VARARGS, NULL},
	 { "CaChannelStateDecorator_get_channelstate", _wrap_CaChannelStateDecorator_get_channelstate, METH_O, "CaChannelStateDecorator_get_channelstate(CaChannelStateDecorator self) -> IMP::Int"},
	 { "CaChannelStateDecorator_set_channelstate", _wrap_CaChannelStateDecorator_set_channelstate, METH_VARARGS, "CaChannelStateDecorator_set_channelstate(CaChannelStateDecorator self, IMP::Int d)"},
	 { "new_CaChannelStateDecorator", _wrap_new_CaChannelStateDecorator, METH_VARARGS, "\n"
		"CaChannelStateDecorator()\n"
		"CaChannelStateDecorator(Model m, ParticleIndex id)\n"
		"new_CaChannelStateDecorator(_ParticleAdaptor d) -> CaChannelStateDecorator\n"
		""},
	 { "CaChannelStateDecorator_get_is_setup", _wrap_CaChannelStateDecorator_get_is_setup, METH_VARARGS, "\n"
		"CaChannelStateDecorator_get_is_setup(Model m, ParticleIndex pi) -> bool\n"
		"CaChannelStateDecorator_get_is_setup(_ParticleAdaptor p) -> bool\n"
		""},
	 { "CaChannelStateDecorator_show", _wrap_CaChannelStateDecorator_show, METH_VARARGS, "CaChannelStateDecorator_show(CaChannelStateDecorator self, _ostream out=std::cout)"},
	 { "CaChannelStateDecorator_setup_particle", _wrap_CaChannelStateDecorator_setup_particle, METH_VARARGS, "\n"
		"CaChannelStateDecorator_setup_particle(Model m, ParticleIndex pi, IMP::Int channelstate) -> CaChannelStateDecorator\n"
		"CaChannelStateDecorator_setup_particle(_ParticleAdaptor pa, IMP::Int channelstate) -> CaChannelStateDecorator\n"
		"CaChannelStateDecorator_setup_particle(Model m, ParticleIndex pi, CaChannelStateDecorator other) -> CaChannelStateDecorator\n"
		"CaChannelStateDecorator_setup_particle(_ParticleAdaptor pa, CaChannelStateDecorator other) -> CaChannelStateDecorator\n"
		""},
	 { "CaChannelStateDecorator_get_channelstate_key", _wrap_CaChannelStateDecorator_get_channelstate_key, METH_NOARGS, "CaChannelStateDecorator_get_channelstate_key() -> IntKey"},
	 { "CaChannelStateDecorator_add_attribute", _wrap_CaChannelStateDecorator_add_attribute, METH_VARARGS, "\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, FloatKey k, IMP::Float v, bool opt)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, FloatKey a0, IMP::Float a1)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, IntKey a0, IMP::Int a1)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, FloatsKey a0, IMP::Floats a1)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, IntsKey a0, IMP::Ints a1)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, StringKey a0, IMP::String a1)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, ParticleIndexKey a0, Particle a1)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, ObjectKey a0, Object a1)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, SparseFloatKey a0, IMP::Float a1)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, SparseIntKey a0, IMP::Int a1)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, SparseStringKey a0, IMP::String a1)\n"
		"CaChannelStateDecorator_add_attribute(CaChannelStateDecorator self, SparseParticleIndexKey a0, ParticleIndex a1)\n"
		""},
	 { "CaChannelStateDecorator_get_value", _wrap_CaChannelStateDecorator_get_value, METH_VARARGS, "\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, FloatKey a0) -> IMP::Float\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, IntKey a0) -> IMP::Int\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, FloatsKey a0) -> IMP::Floats\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, IntsKey a0) -> IMP::Ints\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, StringKey a0) -> IMP::String\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, ParticleIndexKey a0) -> Particle\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, ObjectKey a0) -> Object\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, SparseFloatKey a0) -> IMP::Float\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, SparseIntKey a0) -> IMP::Int\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, SparseStringKey a0) -> IMP::String\n"
		"CaChannelStateDecorator_get_value(CaChannelStateDecorator self, SparseParticleIndexKey a0) -> ParticleIndex\n"
		""},
	 { "CaChannelStateDecorator_set_value", _wrap_CaChannelStateDecorator_set_value, METH_VARARGS, "\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, FloatKey a0, IMP::Float a1)\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, IntKey a0, IMP::Int a1)\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, FloatsKey a0, IMP::Floats a1)\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, IntsKey a0, IMP::Ints a1)\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, StringKey a0, IMP::String a1)\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, ParticleIndexKey a0, Particle a1)\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, ObjectKey a0, Object a1)\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, SparseFloatKey a0, IMP::Float a1)\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, SparseIntKey a0, IMP::Int a1)\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, SparseStringKey a0, IMP::String a1)\n"
		"CaChannelStateDecorator_set_value(CaChannelStateDecorator self, SparseParticleIndexKey a0, ParticleIndex a1)\n"
		""},
	 { "CaChannelStateDecorator_remove_attribute", _wrap_CaChannelStateDecorator_remove_attribute, METH_VARARGS, "\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, FloatKey a0)\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, IntKey a0)\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, FloatsKey a0)\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, IntsKey a0)\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, StringKey a0)\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, ParticleIndexKey a0)\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, ObjectKey a0)\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, SparseFloatKey a0)\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, SparseIntKey a0)\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, SparseStringKey a0)\n"
		"CaChannelStateDecorator_remove_attribute(CaChannelStateDecorator self, SparseParticleIndexKey a0)\n"
		""},
	 { "CaChannelStateDecorator_has_attribute", _wrap_CaChannelStateDecorator_has_attribute, METH_VARARGS, "\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, FloatKey a0) -> bool\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, IntKey a0) -> bool\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, FloatsKey a0) -> bool\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, IntsKey a0) -> bool\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, StringKey a0) -> bool\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, ParticleIndexKey a0) -> bool\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, ObjectKey a0) -> bool\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, SparseFloatKey a0) -> bool\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, SparseIntKey a0) -> bool\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, SparseStringKey a0) -> bool\n"
		"CaChannelStateDecorator_has_attribute(CaChannelStateDecorator self, SparseParticleIndexKey a0) -> bool\n"
		""},
	 { "CaChannelStateDecorator_get_derivative", _wrap_CaChannelStateDecorator_get_derivative, METH_VARARGS, "CaChannelStateDecorator_get_derivative(CaChannelStateDecorator self, FloatKey a0) -> double"},
	 { "CaChannelStateDecorator_get_name", _wrap_CaChannelStateDecorator_get_name, METH_O, "CaChannelStateDecorator_get_name(CaChannelStateDecorator self) -> std::string"},
	 { "CaChannelStateDecorator_clear_caches", _wrap_CaChannelStateDecorator_clear_caches, METH_O, "CaChannelStateDecorator_clear_caches(CaChannelStateDecorator self)"},
	 { "CaChannelStateDecorator_set_name", _wrap_CaChannelStateDecorator_set_name, METH_VARARGS, "CaChannelStateDecorator_set_name(CaChannelStateDecorator self, std::string a0)"},
	 { "CaChannelStateDecorator_set_check_level", _wrap_CaChannelStateDecorator_set_check_level, METH_VARARGS, "CaChannelStateDecorator_set_check_level(CaChannelStateDecorator self, IMP::CheckLevel a0)"},
	 { "CaChannelStateDecorator_add_to_derivative", _wrap_CaChannelStateDecorator_add_to_derivative, METH_VARARGS, "CaChannelStateDecorator_add_to_derivative(CaChannelStateDecorator self, FloatKey a0, double a1, DerivativeAccumulator a2)"},
	 { "CaChannelStateDecorator_set_is_optimized", _wrap_CaChannelStateDecorator_set_is_optimized, METH_VARARGS, "CaChannelStateDecorator_set_is_optimized(CaChannelStateDecorator self, FloatKey a0, bool a1)"},
	 { "CaChannelStateDecorator_get_is_optimized", _wrap_CaChannelStateDecorator_get_is_optimized, METH_VARARGS, "CaChannelStateDecorator_get_is_optimized(CaChannelStateDecorator self, FloatKey a0) -> bool"},
	 { "CaChannelStateDecorator_get_check_level", _wrap_CaChannelStateDecorator_get_check_level, METH_O, "CaChannelStateDecorator_get_check_level(CaChannelStateDecorator self) -> IMP::CheckLevel"},
	 { "CaChannelStateDecorator___eq__", _wrap_CaChannelStateDecorator___eq__, METH_VARARGS, "\n"
		"CaChannelStateDecorator___eq__(CaChannelStateDecorator self, CaChannelStateDecorator o) -> bool\n"
		"CaChannelStateDecorator___eq__(CaChannelStateDecorator self, Particle d) -> bool\n"
		""},
	 { "CaChannelStateDecorator___ne__", _wrap_CaChannelStateDecorator___ne__, METH_VARARGS, "\n"
		"CaChannelStateDecorator___ne__(CaChannelStateDecorator self, CaChannelStateDecorator o) -> bool\n"
		"CaChannelStateDecorator___ne__(CaChannelStateDecorator self, Particle d) -> bool\n"
		""},
	 { "CaChannelStateDecorator___le__", _wrap_CaChannelStateDecorator___le__, METH_VARARGS, "\n"
		"CaChannelStateDecorator___le__(CaChannelStateDecorator self, CaChannelStateDecorator o) -> bool\n"
		"CaChannelStateDecorator___le__(CaChannelStateDecorator self, Particle d) -> bool\n"
		""},
	 { "CaChannelStateDecorator___lt__", _wrap_CaChannelStateDecorator___lt__, METH_VARARGS, "\n"
		"CaChannelStateDecorator___lt__(CaChannelStateDecorator self, CaChannelStateDecorator o) -> bool\n"
		"CaChannelStateDecorator___lt__(CaChannelStateDecorator self, Particle d) -> bool\n"
		""},
	 { "CaChannelStateDecorator___ge__", _wrap_CaChannelStateDecorator___ge__, METH_VARARGS, "\n"
		"CaChannelStateDecorator___ge__(CaChannelStateDecorator self, CaChannelStateDecorator o) -> bool\n"
		"CaChannelStateDecorator___ge__(CaChannelStateDecorator self, Particle d) -> bool\n"
		""},
	 { "CaChannelStateDecorator___gt__", _wrap_CaChannelStateDecorator___gt__, METH_VARARGS, "\n"
		"CaChannelStateDecorator___gt__(CaChannelStateDecorator self, CaChannelStateDecorator o) -> bool\n"
		"CaChannelStateDecorator___gt__(CaChannelStateDecorator self, Particle d) -> bool\n"
		""},
	 { "CaChannelStateDecorator___hash__", _wrap_CaChannelStateDecorator___hash__, METH_O, "CaChannelStateDecorator___hash__(CaChannelStateDecorator self) -> std::size_t"},
	 { "CaChannelStateDecorator___str__", _wrap_CaChannelStateDecorator___str__, METH_O, "CaChannelStateDecorator___str__(CaChannelStateDecorator self) -> std::string"},
	 { "CaChannelStateDecorator___repr__", _wrap_CaChannelStateDecorator___repr__, METH_O, "CaChannelStateDecorator___repr__(CaChannelStateDecorator self) -> std::string"},
	 { "CaChannelStateDecorator__get_as_binary", _wrap_CaChannelStateDecorator__get_as_binary, METH_O, "CaChannelStateDecorator__get_as_binary(CaChannelStateDecorator self) -> PyObject *"},
	 { "CaChannelStateDecorator__set_from_binary", _wrap_CaChannelStateDecorator__set_from_binary, METH_VARARGS, "CaChannelStateDecorator__set_from_binary(CaChannelStateDecorator self, PyObject * p)"},
	 { "delete_CaChannelStateDecorator", _wrap_delete_CaChannelStateDecorator, METH_O, "delete_CaChannelStateDecorator(CaChannelStateDecorator self)"},
	 { "CaChannelStateDecorator_swigregister", CaChannelStateDecorator_swigregister, METH_O, NULL},
	 { "CaChannelStateDecorator_swiginit", CaChannelStateDecorator_swiginit, METH_VARARGS, NULL},
	 { "get_module_version", _wrap_get_module_version, METH_NOARGS, "get_module_version() -> std::string const"},
	 { "get_example_path", _wrap_get_example_path, METH_O, "get_example_path(std::string fname) -> std::string"},
	 { "get_data_path", _wrap_get_data_path, METH_O, "get_data_path(std::string fname) -> std::string"},
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_IMP__core__ConjugateGradientsTo_p_IMP__AttributeOptimizer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::AttributeOptimizer *)  ((IMP::core::ConjugateGradients *) x));
}
static void *_p_IMP__core__SteepestDescentTo_p_IMP__AttributeOptimizer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::AttributeOptimizer *)  ((IMP::core::SteepestDescent *) x));
}
static void *_p_IMP__container__PairsConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::container::PairsConstraint *) x));
}
static void *_p_IMP__container__QuadsConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::container::QuadsConstraint *) x));
}
static void *_p_IMP__container__SingletonsConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::container::SingletonsConstraint *) x));
}
static void *_p_IMP__container__TripletsConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::container::TripletsConstraint *) x));
}
static void *_p_IMP__core__LateralSurfaceConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::core::LateralSurfaceConstraint *) x));
}
static void *_p_IMP__core__PairConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::core::PairConstraint *) x));
}
static void *_p_IMP__core__QuadConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::core::QuadConstraint *) x));
}
static void *_p_IMP__core__SingletonConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::core::SingletonConstraint *) x));
}
static void *_p_IMP__core__SurfaceGeometryConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::core::SurfaceGeometryConstraint *) x));
}
static void *_p_IMP__core__SurfaceSymmetryConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::core::SurfaceSymmetryConstraint *) x));
}
static void *_p_IMP__core__TripletConstraintTo_p_IMP__Constraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Constraint *)  ((IMP::core::TripletConstraint *) x));
}
static void *_p_IMP__PairContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *)  ((IMP::PairContainer *) x));
}
static void *_p_IMP__QuadContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *)  ((IMP::QuadContainer *) x));
}
static void *_p_IMP__SingletonContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *)  ((IMP::SingletonContainer *) x));
}
static void *_p_IMP__TripletContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *)  ((IMP::TripletContainer *) x));
}
static void *_p_IMP__container__AllBipartitePairContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::PairContainer *) ((IMP::container::AllBipartitePairContainer *) x));
}
static void *_p_IMP__container__AllPairContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::PairContainer *) ((IMP::container::AllPairContainer *) x));
}
static void *_p_IMP__container__CloseBipartitePairContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::PairContainer *) ((IMP::container::CloseBipartitePairContainer *) x));
}
static void *_p_IMP__container__ClosePairContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::PairContainer *) ((IMP::container::ClosePairContainer *) x));
}
static void *_p_IMP__container__ConnectingPairContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::PairContainer *) ((IMP::container::ConnectingPairContainer *) x));
}
static void *_p_IMP__container__ConsecutivePairContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::PairContainer *) ((IMP::container::ConsecutivePairContainer *) x));
}
static void *_p_IMP__container__DynamicListPairContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::PairContainer *) ((IMP::container::DynamicListPairContainer *) x));
}
static void *_p_IMP__container__DynamicListQuadContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::QuadContainer *) ((IMP::container::DynamicListQuadContainer *) x));
}
static void *_p_IMP__container__DynamicListSingletonContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::SingletonContainer *) ((IMP::container::DynamicListSingletonContainer *) x));
}
static void *_p_IMP__container__DynamicListTripletContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::TripletContainer *) ((IMP::container::DynamicListTripletContainer *) x));
}
static void *_p_IMP__container__ExclusiveConsecutivePairContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::PairContainer *) ((IMP::container::ExclusiveConsecutivePairContainer *) x));
}
static void *_p_IMP__container__ListPairContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::PairContainer *) ((IMP::container::ListPairContainer *) x));
}
static void *_p_IMP__container__ListQuadContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::QuadContainer *) ((IMP::container::ListQuadContainer *) x));
}
static void *_p_IMP__container__ListSingletonContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::SingletonContainer *) ((IMP::container::ListSingletonContainer *) x));
}
static void *_p_IMP__container__ListTripletContainerTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::TripletContainer *) ((IMP::container::ListTripletContainer *) x));
}
static void *_p_IMP__container__PairContainerSetTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::PairContainer *) ((IMP::container::PairContainerSet *) x));
}
static void *_p_IMP__container__QuadContainerSetTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::QuadContainer *) ((IMP::container::QuadContainerSet *) x));
}
static void *_p_IMP__container__SingletonContainerSetTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::SingletonContainer *) ((IMP::container::SingletonContainerSet *) x));
}
static void *_p_IMP__container__TripletContainerSetTo_p_IMP__Container(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Container *) (IMP::TripletContainer *) ((IMP::container::TripletContainerSet *) x));
}
static void *_p_IMP__core__CentroidTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::XYZ *) ((IMP::core::Centroid *) x));
}
static void *_p_IMP__core__ClusterProvenanceTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::Provenance *) ((IMP::core::ClusterProvenance *) x));
}
static void *_p_IMP__core__CombineProvenanceTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::Provenance *) ((IMP::core::CombineProvenance *) x));
}
static void *_p_IMP__core__CoverTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::XYZ *)(IMP::core::XYZR *) ((IMP::core::Cover *) x));
}
static void *_p_IMP__core__DirectionTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::core::Direction *) x));
}
static void *_p_IMP__core__DirectionAngleTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::core::DirectionAngle *) x));
}
static void *_p_IMP__core__FilterProvenanceTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::Provenance *) ((IMP::core::FilterProvenance *) x));
}
static void *_p_IMP__core__GaussianTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::XYZ *)(IMP::core::RigidBody *) ((IMP::core::Gaussian *) x));
}
static void *_p_IMP__core__HierarchyTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::core::Hierarchy *) x));
}
static void *_p_IMP__core__NonRigidMemberTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::XYZ *)(IMP::core::RigidBodyMember *) ((IMP::core::NonRigidMember *) x));
}
static void *_p_IMP__core__ProvenanceTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::core::Provenance *) x));
}
static void *_p_IMP__core__ProvenancedTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::core::Provenanced *) x));
}
static void *_p_IMP__core__ReferenceTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::core::Reference *) x));
}
static void *_p_IMP__core__RigidBodyTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::XYZ *) ((IMP::core::RigidBody *) x));
}
static void *_p_IMP__core__RigidBodyMemberTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::XYZ *) ((IMP::core::RigidBodyMember *) x));
}
static void *_p_IMP__core__RigidMemberTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::XYZ *)(IMP::core::RigidBodyMember *) ((IMP::core::RigidMember *) x));
}
static void *_p_IMP__core__SampleProvenanceTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::Provenance *) ((IMP::core::SampleProvenance *) x));
}
static void *_p_IMP__core__ScriptProvenanceTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::Provenance *) ((IMP::core::ScriptProvenance *) x));
}
static void *_p_IMP__core__SoftwareProvenanceTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::Provenance *) ((IMP::core::SoftwareProvenance *) x));
}
static void *_p_IMP__core__StructureProvenanceTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::Provenance *) ((IMP::core::StructureProvenance *) x));
}
static void *_p_IMP__core__SurfaceTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::XYZ *) ((IMP::core::Surface *) x));
}
static void *_p_IMP__core__TypedTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::core::Typed *) x));
}
static void *_p_IMP__core__XYZTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::core::XYZ *) x));
}
static void *_p_IMP__core__XYZRTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::core::XYZ *) ((IMP::core::XYZR *) x));
}
static void *_p_IMP__display__ColoredTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::display::Colored *) x));
}
static void *_p_IMP__insulinsecretion__CaChannelStateDecoratorTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::insulinsecretion::CaChannelStateDecorator *) x));
}
static void *_p_IMP__insulinsecretion__DockingStateDecoratorTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::insulinsecretion::DockingStateDecorator *) x));
}
static void *_p_IMP__insulinsecretion__MaturationStateDecoratorTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::insulinsecretion::MaturationStateDecorator *) x));
}
static void *_p_IMP__insulinsecretion__SecretionCounterDecoratorTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::insulinsecretion::SecretionCounterDecorator *) x));
}
static void *_p_IMP__internal___TrivialDecoratorTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::internal::_TrivialDecorator *) x));
}
static void *_p_IMP__internal___TrivialDerivedDecoratorTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *) (IMP::internal::_TrivialDecorator *) ((IMP::internal::_TrivialDerivedDecorator *) x));
}
static void *_p_IMP__internal___TrivialTraitsDecoratorTo_p_IMP__Decorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Decorator *)  ((IMP::internal::_TrivialTraitsDecorator *) x));
}
static void *_p_IMP__AttributeOptimizerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Optimizer *) ((IMP::AttributeOptimizer *) x));
}
static void *_p_IMP__ConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::Constraint *) x));
}
static void *_p_IMP__ContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *)  ((IMP::Container *) x));
}
static void *_p_IMP__OptimizerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *)  ((IMP::Optimizer *) x));
}
static void *_p_IMP__OptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *)  ((IMP::OptimizerState *) x));
}
static void *_p_IMP__PairContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *) ((IMP::PairContainer *) x));
}
static void *_p_IMP__ParticleTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *)  ((IMP::Particle *) x));
}
static void *_p_IMP__QuadContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *) ((IMP::QuadContainer *) x));
}
static void *_p_IMP__RestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *)  ((IMP::Restraint *) x));
}
static void *_p_IMP__RestraintSetTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::RestraintSet *) x));
}
static void *_p_IMP__SaveToConfigurationSetOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::SaveToConfigurationSetOptimizerState *) x));
}
static void *_p_IMP__ScoreStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *)  ((IMP::ScoreState *) x));
}
static void *_p_IMP__ScoringFunctionTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *)  ((IMP::ScoringFunction *) x));
}
static void *_p_IMP__SingletonContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *) ((IMP::SingletonContainer *) x));
}
static void *_p_IMP__TripletContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *) ((IMP::TripletContainer *) x));
}
static void *_p_IMP__container__AllBipartitePairContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::PairContainer *) ((IMP::container::AllBipartitePairContainer *) x));
}
static void *_p_IMP__container__AllPairContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::PairContainer *) ((IMP::container::AllPairContainer *) x));
}
static void *_p_IMP__container__CloseBipartitePairContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::PairContainer *) ((IMP::container::CloseBipartitePairContainer *) x));
}
static void *_p_IMP__container__ClosePairContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::PairContainer *) ((IMP::container::ClosePairContainer *) x));
}
static void *_p_IMP__container__ConnectingPairContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::PairContainer *) ((IMP::container::ConnectingPairContainer *) x));
}
static void *_p_IMP__container__ConsecutivePairContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::PairContainer *) ((IMP::container::ConsecutivePairContainer *) x));
}
static void *_p_IMP__container__DistributePairsScoreStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::container::DistributePairsScoreState *) x));
}
static void *_p_IMP__container__DistributeQuadsScoreStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::container::DistributeQuadsScoreState *) x));
}
static void *_p_IMP__container__DistributeSingletonsScoreStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::container::DistributeSingletonsScoreState *) x));
}
static void *_p_IMP__container__DistributeTripletsScoreStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::container::DistributeTripletsScoreState *) x));
}
static void *_p_IMP__container__DynamicListPairContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::PairContainer *) ((IMP::container::DynamicListPairContainer *) x));
}
static void *_p_IMP__container__DynamicListQuadContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::QuadContainer *) ((IMP::container::DynamicListQuadContainer *) x));
}
static void *_p_IMP__container__DynamicListSingletonContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::SingletonContainer *) ((IMP::container::DynamicListSingletonContainer *) x));
}
static void *_p_IMP__container__DynamicListTripletContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::TripletContainer *) ((IMP::container::DynamicListTripletContainer *) x));
}
static void *_p_IMP__container__EventPairsOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::container::EventPairsOptimizerState *) x));
}
static void *_p_IMP__container__EventQuadsOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::container::EventQuadsOptimizerState *) x));
}
static void *_p_IMP__container__EventSingletonsOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::container::EventSingletonsOptimizerState *) x));
}
static void *_p_IMP__container__EventTripletsOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::container::EventTripletsOptimizerState *) x));
}
static void *_p_IMP__container__ExclusiveConsecutivePairContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::PairContainer *) ((IMP::container::ExclusiveConsecutivePairContainer *) x));
}
static void *_p_IMP__container__ListPairContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::PairContainer *) ((IMP::container::ListPairContainer *) x));
}
static void *_p_IMP__container__ListQuadContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::QuadContainer *) ((IMP::container::ListQuadContainer *) x));
}
static void *_p_IMP__container__ListSingletonContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::SingletonContainer *) ((IMP::container::ListSingletonContainer *) x));
}
static void *_p_IMP__container__ListTripletContainerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::TripletContainer *) ((IMP::container::ListTripletContainer *) x));
}
static void *_p_IMP__container__MinimumPairRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::MinimumPairRestraint *) x));
}
static void *_p_IMP__container__MinimumQuadRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::MinimumQuadRestraint *) x));
}
static void *_p_IMP__container__MinimumSingletonRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::MinimumSingletonRestraint *) x));
}
static void *_p_IMP__container__MinimumTripletRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::MinimumTripletRestraint *) x));
}
static void *_p_IMP__container__PairContainerSetTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::PairContainer *) ((IMP::container::PairContainerSet *) x));
}
static void *_p_IMP__container__PairContainerStatisticsTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::container::PairContainerStatistics *) x));
}
static void *_p_IMP__container__PairsConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::PairsConstraint *) x));
}
static void *_p_IMP__container__PairsOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::container::PairsOptimizerState *) x));
}
static void *_p_IMP__container__PairsRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::PairsRestraint *) x));
}
static void *_p_IMP__container__PredicatePairsRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::PredicatePairsRestraint *) x));
}
static void *_p_IMP__container__PredicateQuadsRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::PredicateQuadsRestraint *) x));
}
static void *_p_IMP__container__PredicateSingletonsRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::PredicateSingletonsRestraint *) x));
}
static void *_p_IMP__container__PredicateTripletsRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::PredicateTripletsRestraint *) x));
}
static void *_p_IMP__container__QuadContainerSetTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::QuadContainer *) ((IMP::container::QuadContainerSet *) x));
}
static void *_p_IMP__container__QuadContainerStatisticsTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::container::QuadContainerStatistics *) x));
}
static void *_p_IMP__container__QuadsConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::QuadsConstraint *) x));
}
static void *_p_IMP__container__QuadsOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::container::QuadsOptimizerState *) x));
}
static void *_p_IMP__container__QuadsRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::QuadsRestraint *) x));
}
static void *_p_IMP__container__SingletonContainerSetTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::SingletonContainer *) ((IMP::container::SingletonContainerSet *) x));
}
static void *_p_IMP__container__SingletonContainerStatisticsTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::container::SingletonContainerStatistics *) x));
}
static void *_p_IMP__container__SingletonsConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::SingletonsConstraint *) x));
}
static void *_p_IMP__container__SingletonsOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::container::SingletonsOptimizerState *) x));
}
static void *_p_IMP__container__SingletonsRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::SingletonsRestraint *) x));
}
static void *_p_IMP__container__TripletContainerSetTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Container *)(IMP::TripletContainer *) ((IMP::container::TripletContainerSet *) x));
}
static void *_p_IMP__container__TripletContainerStatisticsTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::container::TripletContainerStatistics *) x));
}
static void *_p_IMP__container__TripletsConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::TripletsConstraint *) x));
}
static void *_p_IMP__container__TripletsOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::container::TripletsOptimizerState *) x));
}
static void *_p_IMP__container__TripletsRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::container::TripletsRestraint *) x));
}
static void *_p_IMP__core__AngleRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *)(IMP::core::TripletRestraint *) ((IMP::core::AngleRestraint *) x));
}
static void *_p_IMP__core__BallMoverTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::core::MonteCarloMover *) ((IMP::core::BallMover *) x));
}
static void *_p_IMP__core__ChecksScoreStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::core::ChecksScoreState *) x));
}
static void *_p_IMP__core__ConjugateGradientsTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Optimizer *)(IMP::AttributeOptimizer *) ((IMP::core::ConjugateGradients *) x));
}
static void *_p_IMP__core__ConnectivityRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::ConnectivityRestraint *) x));
}
static void *_p_IMP__core__ConstantRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::ConstantRestraint *) x));
}
static void *_p_IMP__core__DiameterRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::DiameterRestraint *) x));
}
static void *_p_IMP__core__DihedralRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::DihedralRestraint *) x));
}
static void *_p_IMP__core__DirectionMoverTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::core::MonteCarloMover *) ((IMP::core::DirectionMover *) x));
}
static void *_p_IMP__core__DistanceRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::DistanceRestraint *) x));
}
static void *_p_IMP__core__ExcludedVolumeRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::ExcludedVolumeRestraint *) x));
}
static void *_p_IMP__core__LateralSurfaceConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::LateralSurfaceConstraint *) x));
}
static void *_p_IMP__core__LogNormalMoverTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::core::MonteCarloMover *) ((IMP::core::LogNormalMover *) x));
}
static void *_p_IMP__core__MSConnectivityRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::MSConnectivityRestraint *) x));
}
static void *_p_IMP__core__MinimumRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::MinimumRestraint *) x));
}
static void *_p_IMP__core__MonteCarloTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Optimizer *) ((IMP::core::MonteCarlo *) x));
}
static void *_p_IMP__core__MonteCarloMoverTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *)  ((IMP::core::MonteCarloMover *) x));
}
static void *_p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Optimizer *)(IMP::core::MonteCarlo *)(IMP::core::MonteCarloWithLocalOptimization *) ((IMP::core::MonteCarloWithBasinHopping *) x));
}
static void *_p_IMP__core__MonteCarloWithLocalOptimizationTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Optimizer *)(IMP::core::MonteCarlo *) ((IMP::core::MonteCarloWithLocalOptimization *) x));
}
static void *_p_IMP__core__MoveStatisticsScoreStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::core::MoveStatisticsScoreState *) x));
}
static void *_p_IMP__core__MultipleBinormalRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::MultipleBinormalRestraint *) x));
}
static void *_p_IMP__core__NeighborsTableTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *) ((IMP::core::NeighborsTable *) x));
}
static void *_p_IMP__core__NormalMoverTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::core::MonteCarloMover *) ((IMP::core::NormalMover *) x));
}
static void *_p_IMP__core__PairConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::PairConstraint *) x));
}
static void *_p_IMP__core__PairRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::PairRestraint *) x));
}
static void *_p_IMP__core__QuadConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::QuadConstraint *) x));
}
static void *_p_IMP__core__QuadRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::QuadRestraint *) x));
}
static void *_p_IMP__core__RestraintsScoringFunctionTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoringFunction *) ((IMP::core::RestraintsScoringFunction *) x));
}
static void *_p_IMP__core__RigidBodyMoverTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::core::MonteCarloMover *) ((IMP::core::RigidBodyMover *) x));
}
static void *_p_IMP__core__RigidBodyTunnelerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::core::MonteCarloMover *) ((IMP::core::RigidBodyTunneler *) x));
}
static void *_p_IMP__core__RigidBodyUmbrellaTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::RigidBodyUmbrella *) x));
}
static void *_p_IMP__core__SerialMoverTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::core::MonteCarloMover *) ((IMP::core::SerialMover *) x));
}
static void *_p_IMP__core__SingletonConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::SingletonConstraint *) x));
}
static void *_p_IMP__core__SingletonRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::SingletonRestraint *) x));
}
static void *_p_IMP__core__SteepestDescentTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Optimizer *)(IMP::AttributeOptimizer *) ((IMP::core::SteepestDescent *) x));
}
static void *_p_IMP__core__SubsetMoverTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::core::MonteCarloMover *) ((IMP::core::SubsetMover *) x));
}
static void *_p_IMP__core__SurfaceGeometryConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::SurfaceGeometryConstraint *) x));
}
static void *_p_IMP__core__SurfaceMoverTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::core::MonteCarloMover *) ((IMP::core::SurfaceMover *) x));
}
static void *_p_IMP__core__SurfaceSymmetryConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::SurfaceSymmetryConstraint *) x));
}
static void *_p_IMP__core__TransformationSymmetryMoverTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::core::MonteCarloMover *) ((IMP::core::TransformationSymmetryMover *) x));
}
static void *_p_IMP__core__TripletConstraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::TripletConstraint *) x));
}
static void *_p_IMP__core__TripletRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::TripletRestraint *) x));
}
static void *_p_IMP__core__VolumeRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::core::VolumeRestraint *) x));
}
static void *_p_IMP__core__WriteRestraintScoresOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::core::WriteRestraintScoresOptimizerState *) x));
}
static void *_p_IMP__display__WriteOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::display::WriteOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__CaChannelOpeningOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::insulinsecretion::CaChannelOpeningOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__InsulinSecretionOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::insulinsecretion::InsulinSecretionOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__VesicleDockingOptimizerStateTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::OptimizerState *) ((IMP::insulinsecretion::VesicleDockingOptimizerState *) x));
}
static void *_p_IMP__internal___ConstOptimizerTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Optimizer *) ((IMP::internal::_ConstOptimizer *) x));
}
static void *_p_IMP__internal___ConstRestraintTo_p_IMP__ModelObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ModelObject *) (IMP::Restraint *) ((IMP::internal::_ConstRestraint *) x));
}
static void *_p_IMP__AttributeOptimizerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Optimizer *) ((IMP::AttributeOptimizer *) x));
}
static void *_p_IMP__ConfigurationTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::Configuration *) x));
}
static void *_p_IMP__ConfigurationSetTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::ConfigurationSet *) x));
}
static void *_p_IMP__ConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::Constraint *) x));
}
static void *_p_IMP__ContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *) ((IMP::Container *) x));
}
static void *_p_IMP__CreateLogContextTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::RAII *) ((IMP::CreateLogContext *) x));
}
static void *_p_IMP__ModelTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::Model *) x));
}
static void *_p_IMP__ModelObjectTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::ModelObject *) x));
}
static void *_p_IMP__ObjectTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *)  ((IMP::Object *) x));
}
static void *_p_IMP__OptimizerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *) ((IMP::Optimizer *) x));
}
static void *_p_IMP__OptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *) ((IMP::OptimizerState *) x));
}
static void *_p_IMP__PairContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *) ((IMP::PairContainer *) x));
}
static void *_p_IMP__PairModifierTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::PairModifier *) x));
}
static void *_p_IMP__PairPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::PairPredicate *) x));
}
static void *_p_IMP__PairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::PairScore *) x));
}
static void *_p_IMP__ParticleTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *) ((IMP::Particle *) x));
}
static void *_p_IMP__QuadContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *) ((IMP::QuadContainer *) x));
}
static void *_p_IMP__QuadModifierTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::QuadModifier *) x));
}
static void *_p_IMP__QuadPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::QuadPredicate *) x));
}
static void *_p_IMP__QuadScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::QuadScore *) x));
}
static void *_p_IMP__RAIITo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *)  ((IMP::RAII *) x));
}
static void *_p_IMP__RefinerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::Refiner *) x));
}
static void *_p_IMP__RestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *) ((IMP::Restraint *) x));
}
static void *_p_IMP__RestraintInfoTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::RestraintInfo *) x));
}
static void *_p_IMP__RestraintSetTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::RestraintSet *) x));
}
static void *_p_IMP__SamplerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::Sampler *) x));
}
static void *_p_IMP__SaveToConfigurationSetOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::SaveToConfigurationSetOptimizerState *) x));
}
static void *_p_IMP__ScopedSetAttributeT_IMP__KeyT_0_t_double_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::RAII *) ((IMP::ScopedSetAttribute< IMP::Key< 0 >,double > *) x));
}
static void *_p_IMP__ScoreStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *) ((IMP::ScoreState *) x));
}
static void *_p_IMP__ScoringFunctionTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *) ((IMP::ScoringFunction *) x));
}
static void *_p_IMP__SetCheckStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::RAII *) ((IMP::SetCheckState *) x));
}
static void *_p_IMP__SetLogStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::RAII *) ((IMP::SetLogState *) x));
}
static void *_p_IMP__SetLogTargetTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::RAII *) ((IMP::SetLogTarget *) x));
}
static void *_p_IMP__SetNumberOfThreadsTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::RAII *) ((IMP::SetNumberOfThreads *) x));
}
static void *_p_IMP__SingletonContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *) ((IMP::SingletonContainer *) x));
}
static void *_p_IMP__SingletonModifierTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::SingletonModifier *) x));
}
static void *_p_IMP__SingletonPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::SingletonPredicate *) x));
}
static void *_p_IMP__SingletonScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::SingletonScore *) x));
}
static void *_p_IMP__TripletContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *) ((IMP::TripletContainer *) x));
}
static void *_p_IMP__TripletModifierTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::TripletModifier *) x));
}
static void *_p_IMP__TripletPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::TripletPredicate *) x));
}
static void *_p_IMP__TripletScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::TripletScore *) x));
}
static void *_p_IMP__UnaryFunctionTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::UnaryFunction *) x));
}
static void *_p_IMP__UndecoratorTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::Undecorator *) x));
}
static void *_p_IMP__algebra__DynamicNearestNeighbor3DTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::algebra::DynamicNearestNeighbor3D *) x));
}
static void *_p_IMP__algebra__EuclideanVectorKDMetricTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::algebra::VectorKDMetric *) ((IMP::algebra::EuclideanVectorKDMetric *) x));
}
static void *_p_IMP__algebra__MaxVectorKDMetricTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::algebra::VectorKDMetric *) ((IMP::algebra::MaxVectorKDMetric *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT__1_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::algebra::NearestNeighborD< -1 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_1_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::algebra::NearestNeighborD< 1 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_2_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::algebra::NearestNeighborD< 2 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_3_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::algebra::NearestNeighborD< 3 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_4_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::algebra::NearestNeighborD< 4 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_5_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::algebra::NearestNeighborD< 5 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_6_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::algebra::NearestNeighborD< 6 > *) x));
}
static void *_p_IMP__algebra__VectorKDMetricTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::algebra::VectorKDMetric *) x));
}
static void *_p_IMP__container__AllBipartitePairContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::AllBipartitePairContainer *) x));
}
static void *_p_IMP__container__AllPairContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::AllPairContainer *) x));
}
static void *_p_IMP__container__CloseBipartitePairContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::CloseBipartitePairContainer *) x));
}
static void *_p_IMP__container__ClosePairContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::ClosePairContainer *) x));
}
static void *_p_IMP__container__ConnectingPairContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::ConnectingPairContainer *) x));
}
static void *_p_IMP__container__ConsecutivePairContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::ConsecutivePairContainer *) x));
}
static void *_p_IMP__container__ConsecutivePairFilterTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairPredicate *) ((IMP::container::ConsecutivePairFilter *) x));
}
static void *_p_IMP__container__DistributePairsScoreStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::DistributePairsScoreState *) x));
}
static void *_p_IMP__container__DistributeQuadsScoreStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::DistributeQuadsScoreState *) x));
}
static void *_p_IMP__container__DistributeSingletonsScoreStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::DistributeSingletonsScoreState *) x));
}
static void *_p_IMP__container__DistributeTripletsScoreStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::DistributeTripletsScoreState *) x));
}
static void *_p_IMP__container__DynamicListPairContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::DynamicListPairContainer *) x));
}
static void *_p_IMP__container__DynamicListQuadContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::QuadContainer *) ((IMP::container::DynamicListQuadContainer *) x));
}
static void *_p_IMP__container__DynamicListSingletonContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::SingletonContainer *) ((IMP::container::DynamicListSingletonContainer *) x));
}
static void *_p_IMP__container__DynamicListTripletContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::TripletContainer *) ((IMP::container::DynamicListTripletContainer *) x));
}
static void *_p_IMP__container__EventPairsOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::EventPairsOptimizerState *) x));
}
static void *_p_IMP__container__EventQuadsOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::EventQuadsOptimizerState *) x));
}
static void *_p_IMP__container__EventSingletonsOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::EventSingletonsOptimizerState *) x));
}
static void *_p_IMP__container__EventTripletsOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::EventTripletsOptimizerState *) x));
}
static void *_p_IMP__container__ExclusiveConsecutivePairContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::ExclusiveConsecutivePairContainer *) x));
}
static void *_p_IMP__container__ExclusiveConsecutivePairFilterTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairPredicate *) ((IMP::container::ExclusiveConsecutivePairFilter *) x));
}
static void *_p_IMP__container__InContainerPairFilterTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairPredicate *) ((IMP::container::InContainerPairFilter *) x));
}
static void *_p_IMP__container__InContainerQuadFilterTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::QuadPredicate *) ((IMP::container::InContainerQuadFilter *) x));
}
static void *_p_IMP__container__InContainerSingletonFilterTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonPredicate *) ((IMP::container::InContainerSingletonFilter *) x));
}
static void *_p_IMP__container__InContainerTripletFilterTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::TripletPredicate *) ((IMP::container::InContainerTripletFilter *) x));
}
static void *_p_IMP__container__ListPairContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::ListPairContainer *) x));
}
static void *_p_IMP__container__ListQuadContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::QuadContainer *) ((IMP::container::ListQuadContainer *) x));
}
static void *_p_IMP__container__ListSingletonContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::SingletonContainer *) ((IMP::container::ListSingletonContainer *) x));
}
static void *_p_IMP__container__ListTripletContainerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::TripletContainer *) ((IMP::container::ListTripletContainer *) x));
}
static void *_p_IMP__container__MinimumPairRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::MinimumPairRestraint *) x));
}
static void *_p_IMP__container__MinimumPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::container::MinimumPairScore *) x));
}
static void *_p_IMP__container__MinimumQuadRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::MinimumQuadRestraint *) x));
}
static void *_p_IMP__container__MinimumQuadScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::QuadScore *) ((IMP::container::MinimumQuadScore *) x));
}
static void *_p_IMP__container__MinimumSingletonRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::MinimumSingletonRestraint *) x));
}
static void *_p_IMP__container__MinimumSingletonScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonScore *) ((IMP::container::MinimumSingletonScore *) x));
}
static void *_p_IMP__container__MinimumTripletRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::MinimumTripletRestraint *) x));
}
static void *_p_IMP__container__MinimumTripletScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::TripletScore *) ((IMP::container::MinimumTripletScore *) x));
}
static void *_p_IMP__container__PairContainerSetTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::PairContainerSet *) x));
}
static void *_p_IMP__container__PairContainerStatisticsTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::PairContainerStatistics *) x));
}
static void *_p_IMP__container__PairsConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::PairsConstraint *) x));
}
static void *_p_IMP__container__PairsOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::PairsOptimizerState *) x));
}
static void *_p_IMP__container__PairsRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::PairsRestraint *) x));
}
static void *_p_IMP__container__PredicatePairsRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::PredicatePairsRestraint *) x));
}
static void *_p_IMP__container__PredicateQuadsRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::PredicateQuadsRestraint *) x));
}
static void *_p_IMP__container__PredicateSingletonsRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::PredicateSingletonsRestraint *) x));
}
static void *_p_IMP__container__PredicateTripletsRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::PredicateTripletsRestraint *) x));
}
static void *_p_IMP__container__QuadContainerSetTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::QuadContainer *) ((IMP::container::QuadContainerSet *) x));
}
static void *_p_IMP__container__QuadContainerStatisticsTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::QuadContainerStatistics *) x));
}
static void *_p_IMP__container__QuadsConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::QuadsConstraint *) x));
}
static void *_p_IMP__container__QuadsOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::QuadsOptimizerState *) x));
}
static void *_p_IMP__container__QuadsRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::QuadsRestraint *) x));
}
static void *_p_IMP__container__SingletonContainerSetTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::SingletonContainer *) ((IMP::container::SingletonContainerSet *) x));
}
static void *_p_IMP__container__SingletonContainerStatisticsTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::SingletonContainerStatistics *) x));
}
static void *_p_IMP__container__SingletonsConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::SingletonsConstraint *) x));
}
static void *_p_IMP__container__SingletonsOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::SingletonsOptimizerState *) x));
}
static void *_p_IMP__container__SingletonsRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::SingletonsRestraint *) x));
}
static void *_p_IMP__container__TripletContainerSetTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Container *)(IMP::TripletContainer *) ((IMP::container::TripletContainerSet *) x));
}
static void *_p_IMP__container__TripletContainerStatisticsTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::TripletContainerStatistics *) x));
}
static void *_p_IMP__container__TripletsConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::TripletsConstraint *) x));
}
static void *_p_IMP__container__TripletsOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::TripletsOptimizerState *) x));
}
static void *_p_IMP__container__TripletsRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::TripletsRestraint *) x));
}
static void *_p_IMP__core__AllSamePairPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairPredicate *) ((IMP::core::AllSamePairPredicate *) x));
}
static void *_p_IMP__core__AllSameQuadPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::QuadPredicate *) ((IMP::core::AllSameQuadPredicate *) x));
}
static void *_p_IMP__core__AllSameSingletonPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonPredicate *) ((IMP::core::AllSameSingletonPredicate *) x));
}
static void *_p_IMP__core__AllSameTripletPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::TripletPredicate *) ((IMP::core::AllSameTripletPredicate *) x));
}
static void *_p_IMP__core__AngleRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *)(IMP::core::TripletRestraint *) ((IMP::core::AngleRestraint *) x));
}
static void *_p_IMP__core__AngleTripletScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::TripletScore *) ((IMP::core::AngleTripletScore *) x));
}
static void *_p_IMP__core__AttributeSingletonPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonPredicate *) ((IMP::core::AttributeSingletonPredicate *) x));
}
static void *_p_IMP__core__BallMoverTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::BallMover *) x));
}
static void *_p_IMP__core__BoxSweepClosePairsFinderTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::core::ClosePairsFinder *) ((IMP::core::BoxSweepClosePairsFinder *) x));
}
static void *_p_IMP__core__CentroidOfRefinedTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonModifier *) ((IMP::core::CentroidOfRefined *) x));
}
static void *_p_IMP__core__ChecksScoreStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::core::ChecksScoreState *) x));
}
static void *_p_IMP__core__ChildrenRefinerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::Refiner *) ((IMP::core::ChildrenRefiner *) x));
}
static void *_p_IMP__core__ClosePairsFinderTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::core::ClosePairsFinder *) x));
}
static void *_p_IMP__core__ClosePairsPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::ClosePairsPairScore *) x));
}
static void *_p_IMP__core__ClosedCubicSplineTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::ClosedCubicSpline *) x));
}
static void *_p_IMP__core__CoinFlipPairPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairPredicate *) ((IMP::core::CoinFlipPairPredicate *) x));
}
static void *_p_IMP__core__CoinFlipQuadPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::QuadPredicate *) ((IMP::core::CoinFlipQuadPredicate *) x));
}
static void *_p_IMP__core__CoinFlipSingletonPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonPredicate *) ((IMP::core::CoinFlipSingletonPredicate *) x));
}
static void *_p_IMP__core__CoinFlipTripletPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::TripletPredicate *) ((IMP::core::CoinFlipTripletPredicate *) x));
}
static void *_p_IMP__core__ConjugateGradientsTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Optimizer *)(IMP::AttributeOptimizer *) ((IMP::core::ConjugateGradients *) x));
}
static void *_p_IMP__core__ConnectivityRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::ConnectivityRestraint *) x));
}
static void *_p_IMP__core__ConstantPairPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairPredicate *) ((IMP::core::ConstantPairPredicate *) x));
}
static void *_p_IMP__core__ConstantQuadPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::QuadPredicate *) ((IMP::core::ConstantQuadPredicate *) x));
}
static void *_p_IMP__core__ConstantRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::ConstantRestraint *) x));
}
static void *_p_IMP__core__ConstantSingletonPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonPredicate *) ((IMP::core::ConstantSingletonPredicate *) x));
}
static void *_p_IMP__core__ConstantTripletPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::TripletPredicate *) ((IMP::core::ConstantTripletPredicate *) x));
}
static void *_p_IMP__core__CosineTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::Cosine *) x));
}
static void *_p_IMP__core__CoverRefinedTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonModifier *) ((IMP::core::CoverRefined *) x));
}
static void *_p_IMP__core__DerivativesFromRefinedTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonModifier *) ((IMP::core::DerivativesFromRefined *) x));
}
static void *_p_IMP__core__DerivativesToRefinedTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonModifier *) ((IMP::core::DerivativesToRefined *) x));
}
static void *_p_IMP__core__DiameterRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::DiameterRestraint *) x));
}
static void *_p_IMP__core__DihedralRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::DihedralRestraint *) x));
}
static void *_p_IMP__core__DirectionMoverTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::DirectionMover *) x));
}
static void *_p_IMP__core__DistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::DistancePairScore *) x));
}
static void *_p_IMP__core__DistanceRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::DistanceRestraint *) x));
}
static void *_p_IMP__core__EdgePairGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::PairGeometry *) ((IMP::core::EdgePairGeometry *) x));
}
static void *_p_IMP__core__EdgePairsGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::PairsGeometry *) ((IMP::core::EdgePairsGeometry *) x));
}
static void *_p_IMP__core__ExcludedVolumeRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::ExcludedVolumeRestraint *) x));
}
static void *_p_IMP__core__FixedRefinerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::Refiner *) ((IMP::core::FixedRefiner *) x));
}
static void *_p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonScore *) ((IMP::core::GenericAttributeSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonScore *) ((IMP::core::GenericBoundingBox3DSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonScore *) ((IMP::core::GenericBoundingSphere3DSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonScore *) ((IMP::core::GenericDistanceToSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GridClosePairsFinderTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::core::ClosePairsFinder *) ((IMP::core::GridClosePairsFinder *) x));
}
static void *_p_IMP__core__HarmonicTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::Harmonic *) x));
}
static void *_p_IMP__core__HarmonicDistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::HarmonicDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicLowerBoundTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *)(IMP::core::Harmonic *) ((IMP::core::HarmonicLowerBound *) x));
}
static void *_p_IMP__core__HarmonicSphereDistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::HarmonicSphereDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceDepthPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::HarmonicSurfaceDepthPairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceDistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::HarmonicSurfaceDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceHeightPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::HarmonicSurfaceHeightPairScore *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *)(IMP::core::Harmonic *) ((IMP::core::HarmonicUpperBound *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundSphereDiameterPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::HarmonicUpperBoundSphereDiameterPairScore *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundSphereDistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::HarmonicUpperBoundSphereDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicWellTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::HarmonicWell *) x));
}
static void *_p_IMP__core__InBoundingBox3DSingletonPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonPredicate *) ((IMP::core::InBoundingBox3DSingletonPredicate *) x));
}
static void *_p_IMP__core__IsCollisionPairPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairPredicate *) ((IMP::core::IsCollisionPairPredicate *) x));
}
static void *_p_IMP__core__KClosePairsPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::KClosePairsPairScore *) x));
}
static void *_p_IMP__core__LateralSurfaceConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::LateralSurfaceConstraint *) x));
}
static void *_p_IMP__core__LeavesRefinerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::Refiner *) ((IMP::core::LeavesRefiner *) x));
}
static void *_p_IMP__core__LinearTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::Linear *) x));
}
static void *_p_IMP__core__LogNormalMoverTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::LogNormalMover *) x));
}
static void *_p_IMP__core__MCCGSamplerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::Sampler *) ((IMP::core::MCCGSampler *) x));
}
static void *_p_IMP__core__MSConnectivityRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::MSConnectivityRestraint *) x));
}
static void *_p_IMP__core__MinimumRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::MinimumRestraint *) x));
}
static void *_p_IMP__core__MonteCarloTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Optimizer *) ((IMP::core::MonteCarlo *) x));
}
static void *_p_IMP__core__MonteCarloMoverTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *) ((IMP::core::MonteCarloMover *) x));
}
static void *_p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Optimizer *)(IMP::core::MonteCarlo *)(IMP::core::MonteCarloWithLocalOptimization *) ((IMP::core::MonteCarloWithBasinHopping *) x));
}
static void *_p_IMP__core__MonteCarloWithLocalOptimizationTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Optimizer *)(IMP::core::MonteCarlo *) ((IMP::core::MonteCarloWithLocalOptimization *) x));
}
static void *_p_IMP__core__MoveStatisticsScoreStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::core::MoveStatisticsScoreState *) x));
}
static void *_p_IMP__core__MultipleBinormalRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::MultipleBinormalRestraint *) x));
}
static void *_p_IMP__core__NearestNeighborsClosePairsFinderTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::core::ClosePairsFinder *) ((IMP::core::NearestNeighborsClosePairsFinder *) x));
}
static void *_p_IMP__core__NeighborsTableTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *) ((IMP::core::NeighborsTable *) x));
}
static void *_p_IMP__core__NormalMoverTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::NormalMover *) x));
}
static void *_p_IMP__core__NormalizedSphereDistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::NormalizedSphereDistancePairScore *) x));
}
static void *_p_IMP__core__OpenCubicSplineTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *)(IMP::score_functor::ScoreUnaryFunction< IMP::score_functor::OpenCubicSpline > *) ((IMP::core::OpenCubicSpline *) x));
}
static void *_p_IMP__core__OrderedTypePairPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairPredicate *) ((IMP::core::OrderedTypePairPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeQuadPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::QuadPredicate *) ((IMP::core::OrderedTypeQuadPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeSingletonPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonPredicate *) ((IMP::core::OrderedTypeSingletonPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeTripletPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::TripletPredicate *) ((IMP::core::OrderedTypeTripletPredicate *) x));
}
static void *_p_IMP__core__PairConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::PairConstraint *) x));
}
static void *_p_IMP__core__PairRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::PairRestraint *) x));
}
static void *_p_IMP__core__QuadConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::QuadConstraint *) x));
}
static void *_p_IMP__core__QuadRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::QuadRestraint *) x));
}
static void *_p_IMP__core__QuadraticClosePairsFinderTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::core::ClosePairsFinder *) ((IMP::core::QuadraticClosePairsFinder *) x));
}
static void *_p_IMP__core__RefinedPairsPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::RefinedPairsPairScore *) x));
}
static void *_p_IMP__core__RestraintsScoringFunctionTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoringFunction *) ((IMP::core::RestraintsScoringFunction *) x));
}
static void *_p_IMP__core__RigidBodyAnglePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::RigidBodyAnglePairScore *) x));
}
static void *_p_IMP__core__RigidBodyDerivativeGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SingletonGeometry *) ((IMP::core::RigidBodyDerivativeGeometry *) x));
}
static void *_p_IMP__core__RigidBodyDerivativesGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SingletonsGeometry *) ((IMP::core::RigidBodyDerivativesGeometry *) x));
}
static void *_p_IMP__core__RigidBodyDistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *)(IMP::core::KClosePairsPairScore *) ((IMP::core::RigidBodyDistancePairScore *) x));
}
static void *_p_IMP__core__RigidBodyFrameGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SingletonGeometry *) ((IMP::core::RigidBodyFrameGeometry *) x));
}
static void *_p_IMP__core__RigidBodyFramesGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SingletonsGeometry *) ((IMP::core::RigidBodyFramesGeometry *) x));
}
static void *_p_IMP__core__RigidBodyHierarchyGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SingletonGeometry *) ((IMP::core::RigidBodyHierarchyGeometry *) x));
}
static void *_p_IMP__core__RigidBodyMoverTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::RigidBodyMover *) x));
}
static void *_p_IMP__core__RigidBodyTorqueTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SegmentGeometry *) ((IMP::core::RigidBodyTorque *) x));
}
static void *_p_IMP__core__RigidBodyTunnelerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::RigidBodyTunneler *) x));
}
static void *_p_IMP__core__RigidBodyUmbrellaTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::RigidBodyUmbrella *) x));
}
static void *_p_IMP__core__RigidClosePairsFinderTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::core::ClosePairsFinder *) ((IMP::core::RigidClosePairsFinder *) x));
}
static void *_p_IMP__core__RigidMembersRefinerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::Refiner *) ((IMP::core::RigidMembersRefiner *) x));
}
static void *_p_IMP__core__SerialMoverTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::SerialMover *) x));
}
static void *_p_IMP__core__SingletonConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::SingletonConstraint *) x));
}
static void *_p_IMP__core__SingletonRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::SingletonRestraint *) x));
}
static void *_p_IMP__core__SoftSpherePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::SoftSpherePairScore *) x));
}
static void *_p_IMP__core__SoftSubSurfacePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::SoftSubSurfacePairScore *) x));
}
static void *_p_IMP__core__SoftSuperSurfacePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::SoftSuperSurfacePairScore *) x));
}
static void *_p_IMP__core__SphereDistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::SphereDistancePairScore *) x));
}
static void *_p_IMP__core__SphereDistanceToSingletonScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonScore *) ((IMP::core::SphereDistanceToSingletonScore *) x));
}
static void *_p_IMP__core__SteepestDescentTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Optimizer *)(IMP::AttributeOptimizer *) ((IMP::core::SteepestDescent *) x));
}
static void *_p_IMP__core__SubsetMoverTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::SubsetMover *) x));
}
static void *_p_IMP__core__SurfaceDepthPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::SurfaceDepthPairScore *) x));
}
static void *_p_IMP__core__SurfaceDistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::SurfaceDistancePairScore *) x));
}
static void *_p_IMP__core__SurfaceGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::core::SurfaceGeometry *) x));
}
static void *_p_IMP__core__SurfaceGeometryConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::SurfaceGeometryConstraint *) x));
}
static void *_p_IMP__core__SurfaceHeightPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::SurfaceHeightPairScore *) x));
}
static void *_p_IMP__core__SurfaceMoverTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::SurfaceMover *) x));
}
static void *_p_IMP__core__SurfaceSymmetryConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::SurfaceSymmetryConstraint *) x));
}
static void *_p_IMP__core__SurfaceTetheredChainTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::SurfaceTetheredChain *) x));
}
static void *_p_IMP__core__TableRefinerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::Refiner *) ((IMP::core::TableRefiner *) x));
}
static void *_p_IMP__core__TransformTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonModifier *) ((IMP::core::Transform *) x));
}
static void *_p_IMP__core__TransformationAndReflectionSymmetryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonModifier *) ((IMP::core::TransformationAndReflectionSymmetry *) x));
}
static void *_p_IMP__core__TransformationSymmetryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonModifier *) ((IMP::core::TransformationSymmetry *) x));
}
static void *_p_IMP__core__TransformationSymmetryMoverTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::TransformationSymmetryMover *) x));
}
static void *_p_IMP__core__TransformedDistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::TransformedDistancePairScore *) x));
}
static void *_p_IMP__core__TripletConstraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::TripletConstraint *) x));
}
static void *_p_IMP__core__TripletRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::TripletRestraint *) x));
}
static void *_p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::TruncatedHarmonic< IMP::core::BOTH > *) x));
}
static void *_p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::TruncatedHarmonic< IMP::core::LOWER > *) x));
}
static void *_p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::TruncatedHarmonic< IMP::core::UPPER > *) x));
}
static void *_p_IMP__core__TypedPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::TypedPairScore *) x));
}
static void *_p_IMP__core__UnorderedTypePairPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairPredicate *) ((IMP::core::UnorderedTypePairPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeQuadPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::QuadPredicate *) ((IMP::core::UnorderedTypeQuadPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeSingletonPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonPredicate *) ((IMP::core::UnorderedTypeSingletonPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeTripletPredicateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::TripletPredicate *) ((IMP::core::UnorderedTypeTripletPredicate *) x));
}
static void *_p_IMP__core__VolumeRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::VolumeRestraint *) x));
}
static void *_p_IMP__core__WeightedSphereDistancePairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::core::WeightedSphereDistancePairScore *) x));
}
static void *_p_IMP__core__WeightedSumTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::WeightedSum *) x));
}
static void *_p_IMP__core__WeightedSumOfExponentialTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::core::WeightedSumOfExponential *) x));
}
static void *_p_IMP__core__WriteRestraintScoresOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::core::WriteRestraintScoresOptimizerState *) x));
}
static void *_p_IMP__core__XYZDerivativeGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SingletonGeometry *) ((IMP::core::XYZDerivativeGeometry *) x));
}
static void *_p_IMP__core__XYZDerivativesGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SingletonsGeometry *) ((IMP::core::XYZDerivativesGeometry *) x));
}
static void *_p_IMP__core__XYZRGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SingletonGeometry *) ((IMP::core::XYZRGeometry *) x));
}
static void *_p_IMP__core__XYZRsGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SingletonsGeometry *) ((IMP::core::XYZRsGeometry *) x));
}
static void *_p_IMP__display__BoundingBoxGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::BoundingBoxGeometry *) x));
}
static void *_p_IMP__display__CylinderGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::CylinderGeometry *) x));
}
static void *_p_IMP__display__EllipsoidGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::EllipsoidGeometry *) x));
}
static void *_p_IMP__display__FilterGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::FilterGeometry *) x));
}
static void *_p_IMP__display__GeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::display::Geometry *) x));
}
static void *_p_IMP__display__GeometrySetTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::GeometrySet *) x));
}
static void *_p_IMP__display__IsosurfaceGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SurfaceMeshGeometry *) ((IMP::display::IsosurfaceGeometry *) x));
}
static void *_p_IMP__display__LabelGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::LabelGeometry *) x));
}
static void *_p_IMP__display__PairGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::PairGeometry *) x));
}
static void *_p_IMP__display__PairsGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::PairsGeometry *) x));
}
static void *_p_IMP__display__PlaneGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::PlaneGeometry *) x));
}
static void *_p_IMP__display__PointGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::PointGeometry *) x));
}
static void *_p_IMP__display__PolygonGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::PolygonGeometry *) x));
}
static void *_p_IMP__display__PymolWriterTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Writer *)(IMP::display::TextWriter *) ((IMP::display::PymolWriter *) x));
}
static void *_p_IMP__display__ReferenceFrameGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::ReferenceFrameGeometry *) x));
}
static void *_p_IMP__display__RestraintGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::RestraintGeometry *) x));
}
static void *_p_IMP__display__RestraintSetGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::RestraintSetGeometry *) x));
}
static void *_p_IMP__display__SegmentGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::SegmentGeometry *) x));
}
static void *_p_IMP__display__SingletonGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::SingletonGeometry *) x));
}
static void *_p_IMP__display__SingletonsGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::SingletonsGeometry *) x));
}
static void *_p_IMP__display__SkinSurfaceGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *)(IMP::display::SurfaceMeshGeometry *) ((IMP::display::SkinSurfaceGeometry *) x));
}
static void *_p_IMP__display__SphereGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::SphereGeometry *) x));
}
static void *_p_IMP__display__SurfaceMeshGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::SurfaceMeshGeometry *) x));
}
static void *_p_IMP__display__TextWriterTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Writer *) ((IMP::display::TextWriter *) x));
}
static void *_p_IMP__display__TriangleGeometryTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::display::Geometry *) ((IMP::display::TriangleGeometry *) x));
}
static void *_p_IMP__display__WriteOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::display::WriteOptimizerState *) x));
}
static void *_p_IMP__display__WriterTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::display::Writer *) x));
}
static void *_p_IMP__insulinsecretion__CaChannelOpeningOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::insulinsecretion::CaChannelOpeningOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__InsulinSecretionOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::insulinsecretion::InsulinSecretionOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonScore *) ((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) x));
}
static void *_p_IMP__insulinsecretion__VesicleDockingOptimizerStateTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::insulinsecretion::VesicleDockingOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__VesicleTraffickingSingletonScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonScore *) ((IMP::insulinsecretion::VesicleTraffickingSingletonScore *) x));
}
static void *_p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::internal::BoostDigraph< IMP::DependencyGraph,IMP::ModelObject *,IMP::ShowDependencyGraphVertex > *) x));
}
static void *_p_IMP__internal___ConstOptimizerTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Optimizer *) ((IMP::internal::_ConstOptimizer *) x));
}
static void *_p_IMP__internal___ConstPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::internal::_ConstPairScore *) x));
}
static void *_p_IMP__internal___ConstRestraintTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::ModelObject *)(IMP::Restraint *) ((IMP::internal::_ConstRestraint *) x));
}
static void *_p_IMP__internal___ConstSingletonScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::SingletonScore *) ((IMP::internal::_ConstSingletonScore *) x));
}
static void *_p_IMP__internal___LogPairScoreTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::PairScore *) ((IMP::internal::_LogPairScore *) x));
}
static void *_p_IMP__internal___TestObjectTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *) ((IMP::internal::_TestObject *) x));
}
static void *_p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_tTo_p_IMP__NonCopyable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::NonCopyable *) (IMP::Object *)(IMP::UnaryFunction *) ((IMP::score_functor::ScoreUnaryFunction< IMP::score_functor::OpenCubicSpline,2 > *) x));
}
static void *_p_IMP__AttributeOptimizerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Optimizer *) ((IMP::AttributeOptimizer *) x));
}
static void *_p_IMP__ConfigurationTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::Configuration *) x));
}
static void *_p_IMP__ConfigurationSetTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::ConfigurationSet *) x));
}
static void *_p_IMP__ConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::Constraint *) x));
}
static void *_p_IMP__ContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *) ((IMP::Container *) x));
}
static void *_p_IMP__ModelTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::Model *) x));
}
static void *_p_IMP__ModelObjectTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::ModelObject *) x));
}
static void *_p_IMP__OptimizerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *) ((IMP::Optimizer *) x));
}
static void *_p_IMP__OptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *) ((IMP::OptimizerState *) x));
}
static void *_p_IMP__PairContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *) ((IMP::PairContainer *) x));
}
static void *_p_IMP__PairModifierTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::PairModifier *) x));
}
static void *_p_IMP__PairPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::PairPredicate *) x));
}
static void *_p_IMP__PairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::PairScore *) x));
}
static void *_p_IMP__ParticleTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *) ((IMP::Particle *) x));
}
static void *_p_IMP__QuadContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *) ((IMP::QuadContainer *) x));
}
static void *_p_IMP__QuadModifierTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::QuadModifier *) x));
}
static void *_p_IMP__QuadPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::QuadPredicate *) x));
}
static void *_p_IMP__QuadScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::QuadScore *) x));
}
static void *_p_IMP__RefinerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::Refiner *) x));
}
static void *_p_IMP__RestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *) ((IMP::Restraint *) x));
}
static void *_p_IMP__RestraintInfoTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::RestraintInfo *) x));
}
static void *_p_IMP__RestraintSetTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::RestraintSet *) x));
}
static void *_p_IMP__SamplerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::Sampler *) x));
}
static void *_p_IMP__SaveToConfigurationSetOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::SaveToConfigurationSetOptimizerState *) x));
}
static void *_p_IMP__ScoreStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *) ((IMP::ScoreState *) x));
}
static void *_p_IMP__ScoringFunctionTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *) ((IMP::ScoringFunction *) x));
}
static void *_p_IMP__SingletonContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *) ((IMP::SingletonContainer *) x));
}
static void *_p_IMP__SingletonModifierTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::SingletonModifier *) x));
}
static void *_p_IMP__SingletonPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::SingletonPredicate *) x));
}
static void *_p_IMP__SingletonScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::SingletonScore *) x));
}
static void *_p_IMP__TripletContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *) ((IMP::TripletContainer *) x));
}
static void *_p_IMP__TripletModifierTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::TripletModifier *) x));
}
static void *_p_IMP__TripletPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::TripletPredicate *) x));
}
static void *_p_IMP__TripletScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::TripletScore *) x));
}
static void *_p_IMP__UnaryFunctionTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::UnaryFunction *) x));
}
static void *_p_IMP__UndecoratorTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::Undecorator *) x));
}
static void *_p_IMP__algebra__DynamicNearestNeighbor3DTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::algebra::DynamicNearestNeighbor3D *) x));
}
static void *_p_IMP__algebra__EuclideanVectorKDMetricTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::algebra::VectorKDMetric *) ((IMP::algebra::EuclideanVectorKDMetric *) x));
}
static void *_p_IMP__algebra__MaxVectorKDMetricTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::algebra::VectorKDMetric *) ((IMP::algebra::MaxVectorKDMetric *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT__1_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::algebra::NearestNeighborD< -1 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_1_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::algebra::NearestNeighborD< 1 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_2_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::algebra::NearestNeighborD< 2 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_3_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::algebra::NearestNeighborD< 3 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_4_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::algebra::NearestNeighborD< 4 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_5_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::algebra::NearestNeighborD< 5 > *) x));
}
static void *_p_IMP__algebra__NearestNeighborDT_6_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::algebra::NearestNeighborD< 6 > *) x));
}
static void *_p_IMP__algebra__VectorKDMetricTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::algebra::VectorKDMetric *) x));
}
static void *_p_IMP__container__AllBipartitePairContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::AllBipartitePairContainer *) x));
}
static void *_p_IMP__container__AllPairContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::AllPairContainer *) x));
}
static void *_p_IMP__container__CloseBipartitePairContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::CloseBipartitePairContainer *) x));
}
static void *_p_IMP__container__ClosePairContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::ClosePairContainer *) x));
}
static void *_p_IMP__container__ConnectingPairContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::ConnectingPairContainer *) x));
}
static void *_p_IMP__container__ConsecutivePairContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::ConsecutivePairContainer *) x));
}
static void *_p_IMP__container__ConsecutivePairFilterTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairPredicate *) ((IMP::container::ConsecutivePairFilter *) x));
}
static void *_p_IMP__container__DistributePairsScoreStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::DistributePairsScoreState *) x));
}
static void *_p_IMP__container__DistributeQuadsScoreStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::DistributeQuadsScoreState *) x));
}
static void *_p_IMP__container__DistributeSingletonsScoreStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::DistributeSingletonsScoreState *) x));
}
static void *_p_IMP__container__DistributeTripletsScoreStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::DistributeTripletsScoreState *) x));
}
static void *_p_IMP__container__DynamicListPairContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::DynamicListPairContainer *) x));
}
static void *_p_IMP__container__DynamicListQuadContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::QuadContainer *) ((IMP::container::DynamicListQuadContainer *) x));
}
static void *_p_IMP__container__DynamicListSingletonContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::SingletonContainer *) ((IMP::container::DynamicListSingletonContainer *) x));
}
static void *_p_IMP__container__DynamicListTripletContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::TripletContainer *) ((IMP::container::DynamicListTripletContainer *) x));
}
static void *_p_IMP__container__EventPairsOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::EventPairsOptimizerState *) x));
}
static void *_p_IMP__container__EventQuadsOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::EventQuadsOptimizerState *) x));
}
static void *_p_IMP__container__EventSingletonsOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::EventSingletonsOptimizerState *) x));
}
static void *_p_IMP__container__EventTripletsOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::EventTripletsOptimizerState *) x));
}
static void *_p_IMP__container__ExclusiveConsecutivePairContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::ExclusiveConsecutivePairContainer *) x));
}
static void *_p_IMP__container__ExclusiveConsecutivePairFilterTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairPredicate *) ((IMP::container::ExclusiveConsecutivePairFilter *) x));
}
static void *_p_IMP__container__InContainerPairFilterTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairPredicate *) ((IMP::container::InContainerPairFilter *) x));
}
static void *_p_IMP__container__InContainerQuadFilterTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::QuadPredicate *) ((IMP::container::InContainerQuadFilter *) x));
}
static void *_p_IMP__container__InContainerSingletonFilterTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonPredicate *) ((IMP::container::InContainerSingletonFilter *) x));
}
static void *_p_IMP__container__InContainerTripletFilterTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::TripletPredicate *) ((IMP::container::InContainerTripletFilter *) x));
}
static void *_p_IMP__container__ListPairContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::ListPairContainer *) x));
}
static void *_p_IMP__container__ListQuadContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::QuadContainer *) ((IMP::container::ListQuadContainer *) x));
}
static void *_p_IMP__container__ListSingletonContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::SingletonContainer *) ((IMP::container::ListSingletonContainer *) x));
}
static void *_p_IMP__container__ListTripletContainerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::TripletContainer *) ((IMP::container::ListTripletContainer *) x));
}
static void *_p_IMP__container__MinimumPairRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::MinimumPairRestraint *) x));
}
static void *_p_IMP__container__MinimumPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::container::MinimumPairScore *) x));
}
static void *_p_IMP__container__MinimumQuadRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::MinimumQuadRestraint *) x));
}
static void *_p_IMP__container__MinimumQuadScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::QuadScore *) ((IMP::container::MinimumQuadScore *) x));
}
static void *_p_IMP__container__MinimumSingletonRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::MinimumSingletonRestraint *) x));
}
static void *_p_IMP__container__MinimumSingletonScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonScore *) ((IMP::container::MinimumSingletonScore *) x));
}
static void *_p_IMP__container__MinimumTripletRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::MinimumTripletRestraint *) x));
}
static void *_p_IMP__container__MinimumTripletScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::TripletScore *) ((IMP::container::MinimumTripletScore *) x));
}
static void *_p_IMP__container__PairContainerSetTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::PairContainer *) ((IMP::container::PairContainerSet *) x));
}
static void *_p_IMP__container__PairContainerStatisticsTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::PairContainerStatistics *) x));
}
static void *_p_IMP__container__PairsConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::PairsConstraint *) x));
}
static void *_p_IMP__container__PairsOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::PairsOptimizerState *) x));
}
static void *_p_IMP__container__PairsRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::PairsRestraint *) x));
}
static void *_p_IMP__container__PredicatePairsRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::PredicatePairsRestraint *) x));
}
static void *_p_IMP__container__PredicateQuadsRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::PredicateQuadsRestraint *) x));
}
static void *_p_IMP__container__PredicateSingletonsRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::PredicateSingletonsRestraint *) x));
}
static void *_p_IMP__container__PredicateTripletsRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::PredicateTripletsRestraint *) x));
}
static void *_p_IMP__container__QuadContainerSetTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::QuadContainer *) ((IMP::container::QuadContainerSet *) x));
}
static void *_p_IMP__container__QuadContainerStatisticsTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::QuadContainerStatistics *) x));
}
static void *_p_IMP__container__QuadsConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::QuadsConstraint *) x));
}
static void *_p_IMP__container__QuadsOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::QuadsOptimizerState *) x));
}
static void *_p_IMP__container__QuadsRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::QuadsRestraint *) x));
}
static void *_p_IMP__container__SingletonContainerSetTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::SingletonContainer *) ((IMP::container::SingletonContainerSet *) x));
}
static void *_p_IMP__container__SingletonContainerStatisticsTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::SingletonContainerStatistics *) x));
}
static void *_p_IMP__container__SingletonsConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::SingletonsConstraint *) x));
}
static void *_p_IMP__container__SingletonsOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::SingletonsOptimizerState *) x));
}
static void *_p_IMP__container__SingletonsRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::SingletonsRestraint *) x));
}
static void *_p_IMP__container__TripletContainerSetTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Container *)(IMP::TripletContainer *) ((IMP::container::TripletContainerSet *) x));
}
static void *_p_IMP__container__TripletContainerStatisticsTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::container::TripletContainerStatistics *) x));
}
static void *_p_IMP__container__TripletsConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::container::TripletsConstraint *) x));
}
static void *_p_IMP__container__TripletsOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::container::TripletsOptimizerState *) x));
}
static void *_p_IMP__container__TripletsRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::container::TripletsRestraint *) x));
}
static void *_p_IMP__core__AllSamePairPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairPredicate *) ((IMP::core::AllSamePairPredicate *) x));
}
static void *_p_IMP__core__AllSameQuadPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::QuadPredicate *) ((IMP::core::AllSameQuadPredicate *) x));
}
static void *_p_IMP__core__AllSameSingletonPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonPredicate *) ((IMP::core::AllSameSingletonPredicate *) x));
}
static void *_p_IMP__core__AllSameTripletPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::TripletPredicate *) ((IMP::core::AllSameTripletPredicate *) x));
}
static void *_p_IMP__core__AngleRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *)(IMP::core::TripletRestraint *) ((IMP::core::AngleRestraint *) x));
}
static void *_p_IMP__core__AngleTripletScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::TripletScore *) ((IMP::core::AngleTripletScore *) x));
}
static void *_p_IMP__core__AttributeSingletonPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonPredicate *) ((IMP::core::AttributeSingletonPredicate *) x));
}
static void *_p_IMP__core__BallMoverTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::BallMover *) x));
}
static void *_p_IMP__core__BoxSweepClosePairsFinderTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::core::ClosePairsFinder *) ((IMP::core::BoxSweepClosePairsFinder *) x));
}
static void *_p_IMP__core__CentroidOfRefinedTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonModifier *) ((IMP::core::CentroidOfRefined *) x));
}
static void *_p_IMP__core__ChecksScoreStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::core::ChecksScoreState *) x));
}
static void *_p_IMP__core__ChildrenRefinerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::Refiner *) ((IMP::core::ChildrenRefiner *) x));
}
static void *_p_IMP__core__ClosePairsFinderTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::core::ClosePairsFinder *) x));
}
static void *_p_IMP__core__ClosePairsPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::ClosePairsPairScore *) x));
}
static void *_p_IMP__core__ClosedCubicSplineTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::ClosedCubicSpline *) x));
}
static void *_p_IMP__core__CoinFlipPairPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairPredicate *) ((IMP::core::CoinFlipPairPredicate *) x));
}
static void *_p_IMP__core__CoinFlipQuadPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::QuadPredicate *) ((IMP::core::CoinFlipQuadPredicate *) x));
}
static void *_p_IMP__core__CoinFlipSingletonPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonPredicate *) ((IMP::core::CoinFlipSingletonPredicate *) x));
}
static void *_p_IMP__core__CoinFlipTripletPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::TripletPredicate *) ((IMP::core::CoinFlipTripletPredicate *) x));
}
static void *_p_IMP__core__ConjugateGradientsTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Optimizer *)(IMP::AttributeOptimizer *) ((IMP::core::ConjugateGradients *) x));
}
static void *_p_IMP__core__ConnectivityRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::ConnectivityRestraint *) x));
}
static void *_p_IMP__core__ConstantPairPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairPredicate *) ((IMP::core::ConstantPairPredicate *) x));
}
static void *_p_IMP__core__ConstantQuadPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::QuadPredicate *) ((IMP::core::ConstantQuadPredicate *) x));
}
static void *_p_IMP__core__ConstantRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::ConstantRestraint *) x));
}
static void *_p_IMP__core__ConstantSingletonPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonPredicate *) ((IMP::core::ConstantSingletonPredicate *) x));
}
static void *_p_IMP__core__ConstantTripletPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::TripletPredicate *) ((IMP::core::ConstantTripletPredicate *) x));
}
static void *_p_IMP__core__CosineTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::Cosine *) x));
}
static void *_p_IMP__core__CoverRefinedTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonModifier *) ((IMP::core::CoverRefined *) x));
}
static void *_p_IMP__core__DerivativesFromRefinedTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonModifier *) ((IMP::core::DerivativesFromRefined *) x));
}
static void *_p_IMP__core__DerivativesToRefinedTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonModifier *) ((IMP::core::DerivativesToRefined *) x));
}
static void *_p_IMP__core__DiameterRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::DiameterRestraint *) x));
}
static void *_p_IMP__core__DihedralRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::DihedralRestraint *) x));
}
static void *_p_IMP__core__DirectionMoverTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::DirectionMover *) x));
}
static void *_p_IMP__core__DistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::DistancePairScore *) x));
}
static void *_p_IMP__core__DistanceRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::DistanceRestraint *) x));
}
static void *_p_IMP__core__EdgePairGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::PairGeometry *) ((IMP::core::EdgePairGeometry *) x));
}
static void *_p_IMP__core__EdgePairsGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::PairsGeometry *) ((IMP::core::EdgePairsGeometry *) x));
}
static void *_p_IMP__core__ExcludedVolumeRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::ExcludedVolumeRestraint *) x));
}
static void *_p_IMP__core__FixedRefinerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::Refiner *) ((IMP::core::FixedRefiner *) x));
}
static void *_p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonScore *) ((IMP::core::GenericAttributeSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonScore *) ((IMP::core::GenericBoundingBox3DSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonScore *) ((IMP::core::GenericBoundingSphere3DSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonScore *) ((IMP::core::GenericDistanceToSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GridClosePairsFinderTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::core::ClosePairsFinder *) ((IMP::core::GridClosePairsFinder *) x));
}
static void *_p_IMP__core__HarmonicTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::Harmonic *) x));
}
static void *_p_IMP__core__HarmonicDistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::HarmonicDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicLowerBoundTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *)(IMP::core::Harmonic *) ((IMP::core::HarmonicLowerBound *) x));
}
static void *_p_IMP__core__HarmonicSphereDistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::HarmonicSphereDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceDepthPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::HarmonicSurfaceDepthPairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceDistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::HarmonicSurfaceDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceHeightPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::HarmonicSurfaceHeightPairScore *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *)(IMP::core::Harmonic *) ((IMP::core::HarmonicUpperBound *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundSphereDiameterPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::HarmonicUpperBoundSphereDiameterPairScore *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundSphereDistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::HarmonicUpperBoundSphereDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicWellTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::HarmonicWell *) x));
}
static void *_p_IMP__core__InBoundingBox3DSingletonPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonPredicate *) ((IMP::core::InBoundingBox3DSingletonPredicate *) x));
}
static void *_p_IMP__core__IsCollisionPairPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairPredicate *) ((IMP::core::IsCollisionPairPredicate *) x));
}
static void *_p_IMP__core__KClosePairsPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::KClosePairsPairScore *) x));
}
static void *_p_IMP__core__LateralSurfaceConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::LateralSurfaceConstraint *) x));
}
static void *_p_IMP__core__LeavesRefinerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::Refiner *) ((IMP::core::LeavesRefiner *) x));
}
static void *_p_IMP__core__LinearTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::Linear *) x));
}
static void *_p_IMP__core__LogNormalMoverTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::LogNormalMover *) x));
}
static void *_p_IMP__core__MCCGSamplerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::Sampler *) ((IMP::core::MCCGSampler *) x));
}
static void *_p_IMP__core__MSConnectivityRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::MSConnectivityRestraint *) x));
}
static void *_p_IMP__core__MinimumRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::MinimumRestraint *) x));
}
static void *_p_IMP__core__MonteCarloTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Optimizer *) ((IMP::core::MonteCarlo *) x));
}
static void *_p_IMP__core__MonteCarloMoverTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *) ((IMP::core::MonteCarloMover *) x));
}
static void *_p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Optimizer *)(IMP::core::MonteCarlo *)(IMP::core::MonteCarloWithLocalOptimization *) ((IMP::core::MonteCarloWithBasinHopping *) x));
}
static void *_p_IMP__core__MonteCarloWithLocalOptimizationTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Optimizer *)(IMP::core::MonteCarlo *) ((IMP::core::MonteCarloWithLocalOptimization *) x));
}
static void *_p_IMP__core__MoveStatisticsScoreStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::core::MoveStatisticsScoreState *) x));
}
static void *_p_IMP__core__MultipleBinormalRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::MultipleBinormalRestraint *) x));
}
static void *_p_IMP__core__NearestNeighborsClosePairsFinderTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::core::ClosePairsFinder *) ((IMP::core::NearestNeighborsClosePairsFinder *) x));
}
static void *_p_IMP__core__NeighborsTableTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *) ((IMP::core::NeighborsTable *) x));
}
static void *_p_IMP__core__NormalMoverTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::NormalMover *) x));
}
static void *_p_IMP__core__NormalizedSphereDistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::NormalizedSphereDistancePairScore *) x));
}
static void *_p_IMP__core__OpenCubicSplineTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *)(IMP::score_functor::ScoreUnaryFunction< IMP::score_functor::OpenCubicSpline > *) ((IMP::core::OpenCubicSpline *) x));
}
static void *_p_IMP__core__OrderedTypePairPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairPredicate *) ((IMP::core::OrderedTypePairPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeQuadPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::QuadPredicate *) ((IMP::core::OrderedTypeQuadPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeSingletonPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonPredicate *) ((IMP::core::OrderedTypeSingletonPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeTripletPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::TripletPredicate *) ((IMP::core::OrderedTypeTripletPredicate *) x));
}
static void *_p_IMP__core__PairConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::PairConstraint *) x));
}
static void *_p_IMP__core__PairRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::PairRestraint *) x));
}
static void *_p_IMP__core__QuadConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::QuadConstraint *) x));
}
static void *_p_IMP__core__QuadRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::QuadRestraint *) x));
}
static void *_p_IMP__core__QuadraticClosePairsFinderTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::core::ClosePairsFinder *) ((IMP::core::QuadraticClosePairsFinder *) x));
}
static void *_p_IMP__core__RefinedPairsPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::RefinedPairsPairScore *) x));
}
static void *_p_IMP__core__RestraintsScoringFunctionTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoringFunction *) ((IMP::core::RestraintsScoringFunction *) x));
}
static void *_p_IMP__core__RigidBodyAnglePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::RigidBodyAnglePairScore *) x));
}
static void *_p_IMP__core__RigidBodyDerivativeGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SingletonGeometry *) ((IMP::core::RigidBodyDerivativeGeometry *) x));
}
static void *_p_IMP__core__RigidBodyDerivativesGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SingletonsGeometry *) ((IMP::core::RigidBodyDerivativesGeometry *) x));
}
static void *_p_IMP__core__RigidBodyDistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *)(IMP::core::KClosePairsPairScore *) ((IMP::core::RigidBodyDistancePairScore *) x));
}
static void *_p_IMP__core__RigidBodyFrameGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SingletonGeometry *) ((IMP::core::RigidBodyFrameGeometry *) x));
}
static void *_p_IMP__core__RigidBodyFramesGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SingletonsGeometry *) ((IMP::core::RigidBodyFramesGeometry *) x));
}
static void *_p_IMP__core__RigidBodyHierarchyGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SingletonGeometry *) ((IMP::core::RigidBodyHierarchyGeometry *) x));
}
static void *_p_IMP__core__RigidBodyMoverTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::RigidBodyMover *) x));
}
static void *_p_IMP__core__RigidBodyTorqueTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SegmentGeometry *) ((IMP::core::RigidBodyTorque *) x));
}
static void *_p_IMP__core__RigidBodyTunnelerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::RigidBodyTunneler *) x));
}
static void *_p_IMP__core__RigidBodyUmbrellaTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::RigidBodyUmbrella *) x));
}
static void *_p_IMP__core__RigidClosePairsFinderTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::core::ClosePairsFinder *) ((IMP::core::RigidClosePairsFinder *) x));
}
static void *_p_IMP__core__RigidMembersRefinerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::Refiner *) ((IMP::core::RigidMembersRefiner *) x));
}
static void *_p_IMP__core__SerialMoverTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::SerialMover *) x));
}
static void *_p_IMP__core__SingletonConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::SingletonConstraint *) x));
}
static void *_p_IMP__core__SingletonRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::SingletonRestraint *) x));
}
static void *_p_IMP__core__SoftSpherePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::SoftSpherePairScore *) x));
}
static void *_p_IMP__core__SoftSubSurfacePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::SoftSubSurfacePairScore *) x));
}
static void *_p_IMP__core__SoftSuperSurfacePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::SoftSuperSurfacePairScore *) x));
}
static void *_p_IMP__core__SphereDistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::SphereDistancePairScore *) x));
}
static void *_p_IMP__core__SphereDistanceToSingletonScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonScore *) ((IMP::core::SphereDistanceToSingletonScore *) x));
}
static void *_p_IMP__core__SteepestDescentTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Optimizer *)(IMP::AttributeOptimizer *) ((IMP::core::SteepestDescent *) x));
}
static void *_p_IMP__core__SubsetMoverTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::SubsetMover *) x));
}
static void *_p_IMP__core__SurfaceDepthPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::SurfaceDepthPairScore *) x));
}
static void *_p_IMP__core__SurfaceDistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::SurfaceDistancePairScore *) x));
}
static void *_p_IMP__core__SurfaceGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::core::SurfaceGeometry *) x));
}
static void *_p_IMP__core__SurfaceGeometryConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::SurfaceGeometryConstraint *) x));
}
static void *_p_IMP__core__SurfaceHeightPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::SurfaceHeightPairScore *) x));
}
static void *_p_IMP__core__SurfaceMoverTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::SurfaceMover *) x));
}
static void *_p_IMP__core__SurfaceSymmetryConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::SurfaceSymmetryConstraint *) x));
}
static void *_p_IMP__core__SurfaceTetheredChainTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::SurfaceTetheredChain *) x));
}
static void *_p_IMP__core__TableRefinerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::Refiner *) ((IMP::core::TableRefiner *) x));
}
static void *_p_IMP__core__TransformTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonModifier *) ((IMP::core::Transform *) x));
}
static void *_p_IMP__core__TransformationAndReflectionSymmetryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonModifier *) ((IMP::core::TransformationAndReflectionSymmetry *) x));
}
static void *_p_IMP__core__TransformationSymmetryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonModifier *) ((IMP::core::TransformationSymmetry *) x));
}
static void *_p_IMP__core__TransformationSymmetryMoverTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::core::MonteCarloMover *) ((IMP::core::TransformationSymmetryMover *) x));
}
static void *_p_IMP__core__TransformedDistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::TransformedDistancePairScore *) x));
}
static void *_p_IMP__core__TripletConstraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::ScoreState *)(IMP::Constraint *) ((IMP::core::TripletConstraint *) x));
}
static void *_p_IMP__core__TripletRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::TripletRestraint *) x));
}
static void *_p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::TruncatedHarmonic< IMP::core::BOTH > *) x));
}
static void *_p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::TruncatedHarmonic< IMP::core::LOWER > *) x));
}
static void *_p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::TruncatedHarmonic< IMP::core::UPPER > *) x));
}
static void *_p_IMP__core__TypedPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::TypedPairScore *) x));
}
static void *_p_IMP__core__UnorderedTypePairPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairPredicate *) ((IMP::core::UnorderedTypePairPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeQuadPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::QuadPredicate *) ((IMP::core::UnorderedTypeQuadPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeSingletonPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonPredicate *) ((IMP::core::UnorderedTypeSingletonPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeTripletPredicateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::TripletPredicate *) ((IMP::core::UnorderedTypeTripletPredicate *) x));
}
static void *_p_IMP__core__VolumeRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::core::VolumeRestraint *) x));
}
static void *_p_IMP__core__WeightedSphereDistancePairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::core::WeightedSphereDistancePairScore *) x));
}
static void *_p_IMP__core__WeightedSumTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::WeightedSum *) x));
}
static void *_p_IMP__core__WeightedSumOfExponentialTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::core::WeightedSumOfExponential *) x));
}
static void *_p_IMP__core__WriteRestraintScoresOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::core::WriteRestraintScoresOptimizerState *) x));
}
static void *_p_IMP__core__XYZDerivativeGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SingletonGeometry *) ((IMP::core::XYZDerivativeGeometry *) x));
}
static void *_p_IMP__core__XYZDerivativesGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SingletonsGeometry *) ((IMP::core::XYZDerivativesGeometry *) x));
}
static void *_p_IMP__core__XYZRGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SingletonGeometry *) ((IMP::core::XYZRGeometry *) x));
}
static void *_p_IMP__core__XYZRsGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SingletonsGeometry *) ((IMP::core::XYZRsGeometry *) x));
}
static void *_p_IMP__display__BoundingBoxGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::BoundingBoxGeometry *) x));
}
static void *_p_IMP__display__CylinderGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::CylinderGeometry *) x));
}
static void *_p_IMP__display__EllipsoidGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::EllipsoidGeometry *) x));
}
static void *_p_IMP__display__FilterGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::FilterGeometry *) x));
}
static void *_p_IMP__display__GeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::display::Geometry *) x));
}
static void *_p_IMP__display__GeometrySetTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::GeometrySet *) x));
}
static void *_p_IMP__display__IsosurfaceGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SurfaceMeshGeometry *) ((IMP::display::IsosurfaceGeometry *) x));
}
static void *_p_IMP__display__LabelGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::LabelGeometry *) x));
}
static void *_p_IMP__display__PairGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::PairGeometry *) x));
}
static void *_p_IMP__display__PairsGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::PairsGeometry *) x));
}
static void *_p_IMP__display__PlaneGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::PlaneGeometry *) x));
}
static void *_p_IMP__display__PointGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::PointGeometry *) x));
}
static void *_p_IMP__display__PolygonGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::PolygonGeometry *) x));
}
static void *_p_IMP__display__PymolWriterTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Writer *)(IMP::display::TextWriter *) ((IMP::display::PymolWriter *) x));
}
static void *_p_IMP__display__ReferenceFrameGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::ReferenceFrameGeometry *) x));
}
static void *_p_IMP__display__RestraintGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::RestraintGeometry *) x));
}
static void *_p_IMP__display__RestraintSetGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::RestraintSetGeometry *) x));
}
static void *_p_IMP__display__SegmentGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::SegmentGeometry *) x));
}
static void *_p_IMP__display__SingletonGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::SingletonGeometry *) x));
}
static void *_p_IMP__display__SingletonsGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::SingletonsGeometry *) x));
}
static void *_p_IMP__display__SkinSurfaceGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *)(IMP::display::SurfaceMeshGeometry *) ((IMP::display::SkinSurfaceGeometry *) x));
}
static void *_p_IMP__display__SphereGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::SphereGeometry *) x));
}
static void *_p_IMP__display__SurfaceMeshGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::SurfaceMeshGeometry *) x));
}
static void *_p_IMP__display__TextWriterTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Writer *) ((IMP::display::TextWriter *) x));
}
static void *_p_IMP__display__TriangleGeometryTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::display::Geometry *) ((IMP::display::TriangleGeometry *) x));
}
static void *_p_IMP__display__WriteOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::display::WriteOptimizerState *) x));
}
static void *_p_IMP__display__WriterTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::display::Writer *) x));
}
static void *_p_IMP__insulinsecretion__CaChannelOpeningOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::insulinsecretion::CaChannelOpeningOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__InsulinSecretionOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::insulinsecretion::InsulinSecretionOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonScore *) ((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) x));
}
static void *_p_IMP__insulinsecretion__VesicleDockingOptimizerStateTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::OptimizerState *) ((IMP::insulinsecretion::VesicleDockingOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__VesicleTraffickingSingletonScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonScore *) ((IMP::insulinsecretion::VesicleTraffickingSingletonScore *) x));
}
static void *_p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::internal::BoostDigraph< IMP::DependencyGraph,IMP::ModelObject *,IMP::ShowDependencyGraphVertex > *) x));
}
static void *_p_IMP__internal___ConstOptimizerTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Optimizer *) ((IMP::internal::_ConstOptimizer *) x));
}
static void *_p_IMP__internal___ConstPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::internal::_ConstPairScore *) x));
}
static void *_p_IMP__internal___ConstRestraintTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::ModelObject *)(IMP::Restraint *) ((IMP::internal::_ConstRestraint *) x));
}
static void *_p_IMP__internal___ConstSingletonScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::SingletonScore *) ((IMP::internal::_ConstSingletonScore *) x));
}
static void *_p_IMP__internal___LogPairScoreTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::PairScore *) ((IMP::internal::_LogPairScore *) x));
}
static void *_p_IMP__internal___TestObjectTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *)  ((IMP::internal::_TestObject *) x));
}
static void *_p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_tTo_p_IMP__Object(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Object *) (IMP::UnaryFunction *) ((IMP::score_functor::ScoreUnaryFunction< IMP::score_functor::OpenCubicSpline,2 > *) x));
}
static void *_p_IMP__AttributeOptimizerTo_p_IMP__Optimizer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Optimizer *)  ((IMP::AttributeOptimizer *) x));
}
static void *_p_IMP__core__ConjugateGradientsTo_p_IMP__Optimizer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Optimizer *) (IMP::AttributeOptimizer *) ((IMP::core::ConjugateGradients *) x));
}
static void *_p_IMP__core__MonteCarloTo_p_IMP__Optimizer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Optimizer *)  ((IMP::core::MonteCarlo *) x));
}
static void *_p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__Optimizer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Optimizer *) (IMP::core::MonteCarlo *)(IMP::core::MonteCarloWithLocalOptimization *) ((IMP::core::MonteCarloWithBasinHopping *) x));
}
static void *_p_IMP__core__MonteCarloWithLocalOptimizationTo_p_IMP__Optimizer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Optimizer *) (IMP::core::MonteCarlo *) ((IMP::core::MonteCarloWithLocalOptimization *) x));
}
static void *_p_IMP__core__SteepestDescentTo_p_IMP__Optimizer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Optimizer *) (IMP::AttributeOptimizer *) ((IMP::core::SteepestDescent *) x));
}
static void *_p_IMP__internal___ConstOptimizerTo_p_IMP__Optimizer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Optimizer *)  ((IMP::internal::_ConstOptimizer *) x));
}
static void *_p_IMP__SaveToConfigurationSetOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::SaveToConfigurationSetOptimizerState *) x));
}
static void *_p_IMP__container__EventPairsOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::container::EventPairsOptimizerState *) x));
}
static void *_p_IMP__container__EventQuadsOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::container::EventQuadsOptimizerState *) x));
}
static void *_p_IMP__container__EventSingletonsOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::container::EventSingletonsOptimizerState *) x));
}
static void *_p_IMP__container__EventTripletsOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::container::EventTripletsOptimizerState *) x));
}
static void *_p_IMP__container__PairsOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::container::PairsOptimizerState *) x));
}
static void *_p_IMP__container__QuadsOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::container::QuadsOptimizerState *) x));
}
static void *_p_IMP__container__SingletonsOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::container::SingletonsOptimizerState *) x));
}
static void *_p_IMP__container__TripletsOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::container::TripletsOptimizerState *) x));
}
static void *_p_IMP__core__WriteRestraintScoresOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::core::WriteRestraintScoresOptimizerState *) x));
}
static void *_p_IMP__display__WriteOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::display::WriteOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__CaChannelOpeningOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::insulinsecretion::CaChannelOpeningOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__InsulinSecretionOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::insulinsecretion::InsulinSecretionOptimizerState *) x));
}
static void *_p_IMP__insulinsecretion__VesicleDockingOptimizerStateTo_p_IMP__OptimizerState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::OptimizerState *)  ((IMP::insulinsecretion::VesicleDockingOptimizerState *) x));
}
static void *_p_IMP__container__AllBipartitePairContainerTo_p_IMP__PairContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairContainer *)  ((IMP::container::AllBipartitePairContainer *) x));
}
static void *_p_IMP__container__AllPairContainerTo_p_IMP__PairContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairContainer *)  ((IMP::container::AllPairContainer *) x));
}
static void *_p_IMP__container__CloseBipartitePairContainerTo_p_IMP__PairContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairContainer *)  ((IMP::container::CloseBipartitePairContainer *) x));
}
static void *_p_IMP__container__ClosePairContainerTo_p_IMP__PairContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairContainer *)  ((IMP::container::ClosePairContainer *) x));
}
static void *_p_IMP__container__ConnectingPairContainerTo_p_IMP__PairContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairContainer *)  ((IMP::container::ConnectingPairContainer *) x));
}
static void *_p_IMP__container__ConsecutivePairContainerTo_p_IMP__PairContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairContainer *)  ((IMP::container::ConsecutivePairContainer *) x));
}
static void *_p_IMP__container__DynamicListPairContainerTo_p_IMP__PairContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairContainer *)  ((IMP::container::DynamicListPairContainer *) x));
}
static void *_p_IMP__container__ExclusiveConsecutivePairContainerTo_p_IMP__PairContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairContainer *)  ((IMP::container::ExclusiveConsecutivePairContainer *) x));
}
static void *_p_IMP__container__ListPairContainerTo_p_IMP__PairContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairContainer *)  ((IMP::container::ListPairContainer *) x));
}
static void *_p_IMP__container__PairContainerSetTo_p_IMP__PairContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairContainer *)  ((IMP::container::PairContainerSet *) x));
}
static void *_p_IMP__container__ConsecutivePairFilterTo_p_IMP__PairPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairPredicate *)  ((IMP::container::ConsecutivePairFilter *) x));
}
static void *_p_IMP__container__ExclusiveConsecutivePairFilterTo_p_IMP__PairPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairPredicate *)  ((IMP::container::ExclusiveConsecutivePairFilter *) x));
}
static void *_p_IMP__container__InContainerPairFilterTo_p_IMP__PairPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairPredicate *)  ((IMP::container::InContainerPairFilter *) x));
}
static void *_p_IMP__core__AllSamePairPredicateTo_p_IMP__PairPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairPredicate *)  ((IMP::core::AllSamePairPredicate *) x));
}
static void *_p_IMP__core__CoinFlipPairPredicateTo_p_IMP__PairPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairPredicate *)  ((IMP::core::CoinFlipPairPredicate *) x));
}
static void *_p_IMP__core__ConstantPairPredicateTo_p_IMP__PairPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairPredicate *)  ((IMP::core::ConstantPairPredicate *) x));
}
static void *_p_IMP__core__IsCollisionPairPredicateTo_p_IMP__PairPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairPredicate *)  ((IMP::core::IsCollisionPairPredicate *) x));
}
static void *_p_IMP__core__OrderedTypePairPredicateTo_p_IMP__PairPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairPredicate *)  ((IMP::core::OrderedTypePairPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypePairPredicateTo_p_IMP__PairPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairPredicate *)  ((IMP::core::UnorderedTypePairPredicate *) x));
}
static void *_p_IMP__container__MinimumPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::container::MinimumPairScore *) x));
}
static void *_p_IMP__core__ClosePairsPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::ClosePairsPairScore *) x));
}
static void *_p_IMP__core__DistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::DistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicDistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::HarmonicDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicSphereDistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::HarmonicSphereDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceDepthPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::HarmonicSurfaceDepthPairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceDistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::HarmonicSurfaceDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceHeightPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::HarmonicSurfaceHeightPairScore *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundSphereDiameterPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::HarmonicUpperBoundSphereDiameterPairScore *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundSphereDistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::HarmonicUpperBoundSphereDistancePairScore *) x));
}
static void *_p_IMP__core__KClosePairsPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::KClosePairsPairScore *) x));
}
static void *_p_IMP__core__NormalizedSphereDistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::NormalizedSphereDistancePairScore *) x));
}
static void *_p_IMP__core__RefinedPairsPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::RefinedPairsPairScore *) x));
}
static void *_p_IMP__core__RigidBodyAnglePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::RigidBodyAnglePairScore *) x));
}
static void *_p_IMP__core__RigidBodyDistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *) (IMP::core::KClosePairsPairScore *) ((IMP::core::RigidBodyDistancePairScore *) x));
}
static void *_p_IMP__core__SoftSpherePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::SoftSpherePairScore *) x));
}
static void *_p_IMP__core__SoftSubSurfacePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::SoftSubSurfacePairScore *) x));
}
static void *_p_IMP__core__SoftSuperSurfacePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::SoftSuperSurfacePairScore *) x));
}
static void *_p_IMP__core__SphereDistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::SphereDistancePairScore *) x));
}
static void *_p_IMP__core__SurfaceDepthPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::SurfaceDepthPairScore *) x));
}
static void *_p_IMP__core__SurfaceDistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::SurfaceDistancePairScore *) x));
}
static void *_p_IMP__core__SurfaceHeightPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::SurfaceHeightPairScore *) x));
}
static void *_p_IMP__core__TransformedDistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::TransformedDistancePairScore *) x));
}
static void *_p_IMP__core__TypedPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::TypedPairScore *) x));
}
static void *_p_IMP__core__WeightedSphereDistancePairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::core::WeightedSphereDistancePairScore *) x));
}
static void *_p_IMP__internal___ConstPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::internal::_ConstPairScore *) x));
}
static void *_p_IMP__internal___LogPairScoreTo_p_IMP__PairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::PairScore *)  ((IMP::internal::_LogPairScore *) x));
}
static void *_p_IMP__PairModifierTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::PairModifier *) x));
}
static void *_p_IMP__PairPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::PairPredicate *) x));
}
static void *_p_IMP__PairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::PairScore *) x));
}
static void *_p_IMP__QuadModifierTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::QuadModifier *) x));
}
static void *_p_IMP__QuadPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::QuadPredicate *) x));
}
static void *_p_IMP__QuadScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::QuadScore *) x));
}
static void *_p_IMP__RefinerTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::Refiner *) x));
}
static void *_p_IMP__SingletonModifierTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::SingletonModifier *) x));
}
static void *_p_IMP__SingletonPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::SingletonPredicate *) x));
}
static void *_p_IMP__SingletonScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::SingletonScore *) x));
}
static void *_p_IMP__TripletModifierTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::TripletModifier *) x));
}
static void *_p_IMP__TripletPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::TripletPredicate *) x));
}
static void *_p_IMP__TripletScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::TripletScore *) x));
}
static void *_p_IMP__container__ConsecutivePairFilterTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairPredicate *) ((IMP::container::ConsecutivePairFilter *) x));
}
static void *_p_IMP__container__ExclusiveConsecutivePairFilterTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairPredicate *) ((IMP::container::ExclusiveConsecutivePairFilter *) x));
}
static void *_p_IMP__container__InContainerPairFilterTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairPredicate *) ((IMP::container::InContainerPairFilter *) x));
}
static void *_p_IMP__container__InContainerQuadFilterTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::QuadPredicate *) ((IMP::container::InContainerQuadFilter *) x));
}
static void *_p_IMP__container__InContainerSingletonFilterTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonPredicate *) ((IMP::container::InContainerSingletonFilter *) x));
}
static void *_p_IMP__container__InContainerTripletFilterTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::TripletPredicate *) ((IMP::container::InContainerTripletFilter *) x));
}
static void *_p_IMP__container__MinimumPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::container::MinimumPairScore *) x));
}
static void *_p_IMP__container__MinimumQuadScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::QuadScore *) ((IMP::container::MinimumQuadScore *) x));
}
static void *_p_IMP__container__MinimumSingletonScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonScore *) ((IMP::container::MinimumSingletonScore *) x));
}
static void *_p_IMP__container__MinimumTripletScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::TripletScore *) ((IMP::container::MinimumTripletScore *) x));
}
static void *_p_IMP__core__AllSamePairPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairPredicate *) ((IMP::core::AllSamePairPredicate *) x));
}
static void *_p_IMP__core__AllSameQuadPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::QuadPredicate *) ((IMP::core::AllSameQuadPredicate *) x));
}
static void *_p_IMP__core__AllSameSingletonPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonPredicate *) ((IMP::core::AllSameSingletonPredicate *) x));
}
static void *_p_IMP__core__AllSameTripletPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::TripletPredicate *) ((IMP::core::AllSameTripletPredicate *) x));
}
static void *_p_IMP__core__AngleTripletScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::TripletScore *) ((IMP::core::AngleTripletScore *) x));
}
static void *_p_IMP__core__AttributeSingletonPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonPredicate *) ((IMP::core::AttributeSingletonPredicate *) x));
}
static void *_p_IMP__core__BoxSweepClosePairsFinderTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::core::ClosePairsFinder *) ((IMP::core::BoxSweepClosePairsFinder *) x));
}
static void *_p_IMP__core__CentroidOfRefinedTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonModifier *) ((IMP::core::CentroidOfRefined *) x));
}
static void *_p_IMP__core__ChildrenRefinerTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::Refiner *) ((IMP::core::ChildrenRefiner *) x));
}
static void *_p_IMP__core__ClosePairsFinderTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *)  ((IMP::core::ClosePairsFinder *) x));
}
static void *_p_IMP__core__ClosePairsPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::ClosePairsPairScore *) x));
}
static void *_p_IMP__core__CoinFlipPairPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairPredicate *) ((IMP::core::CoinFlipPairPredicate *) x));
}
static void *_p_IMP__core__CoinFlipQuadPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::QuadPredicate *) ((IMP::core::CoinFlipQuadPredicate *) x));
}
static void *_p_IMP__core__CoinFlipSingletonPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonPredicate *) ((IMP::core::CoinFlipSingletonPredicate *) x));
}
static void *_p_IMP__core__CoinFlipTripletPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::TripletPredicate *) ((IMP::core::CoinFlipTripletPredicate *) x));
}
static void *_p_IMP__core__ConstantPairPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairPredicate *) ((IMP::core::ConstantPairPredicate *) x));
}
static void *_p_IMP__core__ConstantQuadPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::QuadPredicate *) ((IMP::core::ConstantQuadPredicate *) x));
}
static void *_p_IMP__core__ConstantSingletonPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonPredicate *) ((IMP::core::ConstantSingletonPredicate *) x));
}
static void *_p_IMP__core__ConstantTripletPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::TripletPredicate *) ((IMP::core::ConstantTripletPredicate *) x));
}
static void *_p_IMP__core__CoverRefinedTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonModifier *) ((IMP::core::CoverRefined *) x));
}
static void *_p_IMP__core__DerivativesFromRefinedTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonModifier *) ((IMP::core::DerivativesFromRefined *) x));
}
static void *_p_IMP__core__DerivativesToRefinedTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonModifier *) ((IMP::core::DerivativesToRefined *) x));
}
static void *_p_IMP__core__DistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::DistancePairScore *) x));
}
static void *_p_IMP__core__FixedRefinerTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::Refiner *) ((IMP::core::FixedRefiner *) x));
}
static void *_p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonScore *) ((IMP::core::GenericAttributeSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonScore *) ((IMP::core::GenericBoundingBox3DSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonScore *) ((IMP::core::GenericBoundingSphere3DSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonScore *) ((IMP::core::GenericDistanceToSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GridClosePairsFinderTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::core::ClosePairsFinder *) ((IMP::core::GridClosePairsFinder *) x));
}
static void *_p_IMP__core__HarmonicDistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::HarmonicDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicSphereDistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::HarmonicSphereDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceDepthPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::HarmonicSurfaceDepthPairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceDistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::HarmonicSurfaceDistancePairScore *) x));
}
static void *_p_IMP__core__HarmonicSurfaceHeightPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::HarmonicSurfaceHeightPairScore *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundSphereDiameterPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::HarmonicUpperBoundSphereDiameterPairScore *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundSphereDistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::HarmonicUpperBoundSphereDistancePairScore *) x));
}
static void *_p_IMP__core__InBoundingBox3DSingletonPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonPredicate *) ((IMP::core::InBoundingBox3DSingletonPredicate *) x));
}
static void *_p_IMP__core__IsCollisionPairPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairPredicate *) ((IMP::core::IsCollisionPairPredicate *) x));
}
static void *_p_IMP__core__KClosePairsPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::KClosePairsPairScore *) x));
}
static void *_p_IMP__core__LeavesRefinerTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::Refiner *) ((IMP::core::LeavesRefiner *) x));
}
static void *_p_IMP__core__NearestNeighborsClosePairsFinderTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::core::ClosePairsFinder *) ((IMP::core::NearestNeighborsClosePairsFinder *) x));
}
static void *_p_IMP__core__NormalizedSphereDistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::NormalizedSphereDistancePairScore *) x));
}
static void *_p_IMP__core__OrderedTypePairPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairPredicate *) ((IMP::core::OrderedTypePairPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeQuadPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::QuadPredicate *) ((IMP::core::OrderedTypeQuadPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeSingletonPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonPredicate *) ((IMP::core::OrderedTypeSingletonPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeTripletPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::TripletPredicate *) ((IMP::core::OrderedTypeTripletPredicate *) x));
}
static void *_p_IMP__core__QuadraticClosePairsFinderTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::core::ClosePairsFinder *) ((IMP::core::QuadraticClosePairsFinder *) x));
}
static void *_p_IMP__core__RefinedPairsPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::RefinedPairsPairScore *) x));
}
static void *_p_IMP__core__RigidBodyAnglePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::RigidBodyAnglePairScore *) x));
}
static void *_p_IMP__core__RigidBodyDistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *)(IMP::core::KClosePairsPairScore *) ((IMP::core::RigidBodyDistancePairScore *) x));
}
static void *_p_IMP__core__RigidClosePairsFinderTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::core::ClosePairsFinder *) ((IMP::core::RigidClosePairsFinder *) x));
}
static void *_p_IMP__core__RigidMembersRefinerTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::Refiner *) ((IMP::core::RigidMembersRefiner *) x));
}
static void *_p_IMP__core__SoftSpherePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::SoftSpherePairScore *) x));
}
static void *_p_IMP__core__SoftSubSurfacePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::SoftSubSurfacePairScore *) x));
}
static void *_p_IMP__core__SoftSuperSurfacePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::SoftSuperSurfacePairScore *) x));
}
static void *_p_IMP__core__SphereDistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::SphereDistancePairScore *) x));
}
static void *_p_IMP__core__SphereDistanceToSingletonScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonScore *) ((IMP::core::SphereDistanceToSingletonScore *) x));
}
static void *_p_IMP__core__SurfaceDepthPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::SurfaceDepthPairScore *) x));
}
static void *_p_IMP__core__SurfaceDistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::SurfaceDistancePairScore *) x));
}
static void *_p_IMP__core__SurfaceHeightPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::SurfaceHeightPairScore *) x));
}
static void *_p_IMP__core__TableRefinerTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::Refiner *) ((IMP::core::TableRefiner *) x));
}
static void *_p_IMP__core__TransformTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonModifier *) ((IMP::core::Transform *) x));
}
static void *_p_IMP__core__TransformationAndReflectionSymmetryTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonModifier *) ((IMP::core::TransformationAndReflectionSymmetry *) x));
}
static void *_p_IMP__core__TransformationSymmetryTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonModifier *) ((IMP::core::TransformationSymmetry *) x));
}
static void *_p_IMP__core__TransformedDistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::TransformedDistancePairScore *) x));
}
static void *_p_IMP__core__TypedPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::TypedPairScore *) x));
}
static void *_p_IMP__core__UnorderedTypePairPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairPredicate *) ((IMP::core::UnorderedTypePairPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeQuadPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::QuadPredicate *) ((IMP::core::UnorderedTypeQuadPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeSingletonPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonPredicate *) ((IMP::core::UnorderedTypeSingletonPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeTripletPredicateTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::TripletPredicate *) ((IMP::core::UnorderedTypeTripletPredicate *) x));
}
static void *_p_IMP__core__WeightedSphereDistancePairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::core::WeightedSphereDistancePairScore *) x));
}
static void *_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonScore *) ((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) x));
}
static void *_p_IMP__insulinsecretion__VesicleTraffickingSingletonScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonScore *) ((IMP::insulinsecretion::VesicleTraffickingSingletonScore *) x));
}
static void *_p_IMP__internal___ConstPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::internal::_ConstPairScore *) x));
}
static void *_p_IMP__internal___ConstSingletonScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::SingletonScore *) ((IMP::internal::_ConstSingletonScore *) x));
}
static void *_p_IMP__internal___LogPairScoreTo_p_IMP__ParticleInputs(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ParticleInputs *) (IMP::PairScore *) ((IMP::internal::_LogPairScore *) x));
}
static void *_p_IMP__container__DynamicListQuadContainerTo_p_IMP__QuadContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::QuadContainer *)  ((IMP::container::DynamicListQuadContainer *) x));
}
static void *_p_IMP__container__ListQuadContainerTo_p_IMP__QuadContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::QuadContainer *)  ((IMP::container::ListQuadContainer *) x));
}
static void *_p_IMP__container__QuadContainerSetTo_p_IMP__QuadContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::QuadContainer *)  ((IMP::container::QuadContainerSet *) x));
}
static void *_p_IMP__container__InContainerQuadFilterTo_p_IMP__QuadPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::QuadPredicate *)  ((IMP::container::InContainerQuadFilter *) x));
}
static void *_p_IMP__core__AllSameQuadPredicateTo_p_IMP__QuadPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::QuadPredicate *)  ((IMP::core::AllSameQuadPredicate *) x));
}
static void *_p_IMP__core__CoinFlipQuadPredicateTo_p_IMP__QuadPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::QuadPredicate *)  ((IMP::core::CoinFlipQuadPredicate *) x));
}
static void *_p_IMP__core__ConstantQuadPredicateTo_p_IMP__QuadPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::QuadPredicate *)  ((IMP::core::ConstantQuadPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeQuadPredicateTo_p_IMP__QuadPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::QuadPredicate *)  ((IMP::core::OrderedTypeQuadPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeQuadPredicateTo_p_IMP__QuadPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::QuadPredicate *)  ((IMP::core::UnorderedTypeQuadPredicate *) x));
}
static void *_p_IMP__container__MinimumQuadScoreTo_p_IMP__QuadScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::QuadScore *)  ((IMP::container::MinimumQuadScore *) x));
}
static void *_p_IMP__core__ChildrenRefinerTo_p_IMP__Refiner(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Refiner *)  ((IMP::core::ChildrenRefiner *) x));
}
static void *_p_IMP__core__FixedRefinerTo_p_IMP__Refiner(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Refiner *)  ((IMP::core::FixedRefiner *) x));
}
static void *_p_IMP__core__LeavesRefinerTo_p_IMP__Refiner(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Refiner *)  ((IMP::core::LeavesRefiner *) x));
}
static void *_p_IMP__core__RigidMembersRefinerTo_p_IMP__Refiner(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Refiner *)  ((IMP::core::RigidMembersRefiner *) x));
}
static void *_p_IMP__core__TableRefinerTo_p_IMP__Refiner(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Refiner *)  ((IMP::core::TableRefiner *) x));
}
static void *_p_IMP__RestraintSetTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::RestraintSet *) x));
}
static void *_p_IMP__container__MinimumPairRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::MinimumPairRestraint *) x));
}
static void *_p_IMP__container__MinimumQuadRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::MinimumQuadRestraint *) x));
}
static void *_p_IMP__container__MinimumSingletonRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::MinimumSingletonRestraint *) x));
}
static void *_p_IMP__container__MinimumTripletRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::MinimumTripletRestraint *) x));
}
static void *_p_IMP__container__PairsRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::PairsRestraint *) x));
}
static void *_p_IMP__container__PredicatePairsRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::PredicatePairsRestraint *) x));
}
static void *_p_IMP__container__PredicateQuadsRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::PredicateQuadsRestraint *) x));
}
static void *_p_IMP__container__PredicateSingletonsRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::PredicateSingletonsRestraint *) x));
}
static void *_p_IMP__container__PredicateTripletsRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::PredicateTripletsRestraint *) x));
}
static void *_p_IMP__container__QuadsRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::QuadsRestraint *) x));
}
static void *_p_IMP__container__SingletonsRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::SingletonsRestraint *) x));
}
static void *_p_IMP__container__TripletsRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::container::TripletsRestraint *) x));
}
static void *_p_IMP__core__AngleRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *) (IMP::core::TripletRestraint *) ((IMP::core::AngleRestraint *) x));
}
static void *_p_IMP__core__ConnectivityRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::ConnectivityRestraint *) x));
}
static void *_p_IMP__core__ConstantRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::ConstantRestraint *) x));
}
static void *_p_IMP__core__DiameterRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::DiameterRestraint *) x));
}
static void *_p_IMP__core__DihedralRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::DihedralRestraint *) x));
}
static void *_p_IMP__core__DistanceRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::DistanceRestraint *) x));
}
static void *_p_IMP__core__ExcludedVolumeRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::ExcludedVolumeRestraint *) x));
}
static void *_p_IMP__core__MSConnectivityRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::MSConnectivityRestraint *) x));
}
static void *_p_IMP__core__MinimumRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::MinimumRestraint *) x));
}
static void *_p_IMP__core__MultipleBinormalRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::MultipleBinormalRestraint *) x));
}
static void *_p_IMP__core__PairRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::PairRestraint *) x));
}
static void *_p_IMP__core__QuadRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::QuadRestraint *) x));
}
static void *_p_IMP__core__RigidBodyUmbrellaTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::RigidBodyUmbrella *) x));
}
static void *_p_IMP__core__SingletonRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::SingletonRestraint *) x));
}
static void *_p_IMP__core__TripletRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::TripletRestraint *) x));
}
static void *_p_IMP__core__VolumeRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::core::VolumeRestraint *) x));
}
static void *_p_IMP__internal___ConstRestraintTo_p_IMP__Restraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Restraint *)  ((IMP::internal::_ConstRestraint *) x));
}
static void *_p_IMP__core__MCCGSamplerTo_p_IMP__Sampler(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Sampler *)  ((IMP::core::MCCGSampler *) x));
}
static void *_p_IMP__ConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::Constraint *) x));
}
static void *_p_IMP__container__DistributePairsScoreStateTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::container::DistributePairsScoreState *) x));
}
static void *_p_IMP__container__DistributeQuadsScoreStateTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::container::DistributeQuadsScoreState *) x));
}
static void *_p_IMP__container__DistributeSingletonsScoreStateTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::container::DistributeSingletonsScoreState *) x));
}
static void *_p_IMP__container__DistributeTripletsScoreStateTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::container::DistributeTripletsScoreState *) x));
}
static void *_p_IMP__container__PairContainerStatisticsTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::container::PairContainerStatistics *) x));
}
static void *_p_IMP__container__PairsConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::container::PairsConstraint *) x));
}
static void *_p_IMP__container__QuadContainerStatisticsTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::container::QuadContainerStatistics *) x));
}
static void *_p_IMP__container__QuadsConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::container::QuadsConstraint *) x));
}
static void *_p_IMP__container__SingletonContainerStatisticsTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::container::SingletonContainerStatistics *) x));
}
static void *_p_IMP__container__SingletonsConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::container::SingletonsConstraint *) x));
}
static void *_p_IMP__container__TripletContainerStatisticsTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::container::TripletContainerStatistics *) x));
}
static void *_p_IMP__container__TripletsConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::container::TripletsConstraint *) x));
}
static void *_p_IMP__core__ChecksScoreStateTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::core::ChecksScoreState *) x));
}
static void *_p_IMP__core__LateralSurfaceConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::core::LateralSurfaceConstraint *) x));
}
static void *_p_IMP__core__MoveStatisticsScoreStateTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::core::MoveStatisticsScoreState *) x));
}
static void *_p_IMP__core__NeighborsTableTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *)  ((IMP::core::NeighborsTable *) x));
}
static void *_p_IMP__core__PairConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::core::PairConstraint *) x));
}
static void *_p_IMP__core__QuadConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::core::QuadConstraint *) x));
}
static void *_p_IMP__core__SingletonConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::core::SingletonConstraint *) x));
}
static void *_p_IMP__core__SurfaceGeometryConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::core::SurfaceGeometryConstraint *) x));
}
static void *_p_IMP__core__SurfaceSymmetryConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::core::SurfaceSymmetryConstraint *) x));
}
static void *_p_IMP__core__TripletConstraintTo_p_IMP__ScoreState(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoreState *) (IMP::Constraint *) ((IMP::core::TripletConstraint *) x));
}
static void *_p_IMP__core__RestraintsScoringFunctionTo_p_IMP__ScoringFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::ScoringFunction *)  ((IMP::core::RestraintsScoringFunction *) x));
}
static void *_p_IMP__container__DynamicListSingletonContainerTo_p_IMP__SingletonContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonContainer *)  ((IMP::container::DynamicListSingletonContainer *) x));
}
static void *_p_IMP__container__ListSingletonContainerTo_p_IMP__SingletonContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonContainer *)  ((IMP::container::ListSingletonContainer *) x));
}
static void *_p_IMP__container__SingletonContainerSetTo_p_IMP__SingletonContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonContainer *)  ((IMP::container::SingletonContainerSet *) x));
}
static void *_p_IMP__core__CentroidOfRefinedTo_p_IMP__SingletonModifier(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonModifier *)  ((IMP::core::CentroidOfRefined *) x));
}
static void *_p_IMP__core__CoverRefinedTo_p_IMP__SingletonModifier(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonModifier *)  ((IMP::core::CoverRefined *) x));
}
static void *_p_IMP__core__DerivativesFromRefinedTo_p_IMP__SingletonModifier(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonModifier *)  ((IMP::core::DerivativesFromRefined *) x));
}
static void *_p_IMP__core__DerivativesToRefinedTo_p_IMP__SingletonModifier(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonModifier *)  ((IMP::core::DerivativesToRefined *) x));
}
static void *_p_IMP__core__TransformTo_p_IMP__SingletonModifier(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonModifier *)  ((IMP::core::Transform *) x));
}
static void *_p_IMP__core__TransformationAndReflectionSymmetryTo_p_IMP__SingletonModifier(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonModifier *)  ((IMP::core::TransformationAndReflectionSymmetry *) x));
}
static void *_p_IMP__core__TransformationSymmetryTo_p_IMP__SingletonModifier(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonModifier *)  ((IMP::core::TransformationSymmetry *) x));
}
static void *_p_IMP__container__InContainerSingletonFilterTo_p_IMP__SingletonPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonPredicate *)  ((IMP::container::InContainerSingletonFilter *) x));
}
static void *_p_IMP__core__AllSameSingletonPredicateTo_p_IMP__SingletonPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonPredicate *)  ((IMP::core::AllSameSingletonPredicate *) x));
}
static void *_p_IMP__core__AttributeSingletonPredicateTo_p_IMP__SingletonPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonPredicate *)  ((IMP::core::AttributeSingletonPredicate *) x));
}
static void *_p_IMP__core__CoinFlipSingletonPredicateTo_p_IMP__SingletonPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonPredicate *)  ((IMP::core::CoinFlipSingletonPredicate *) x));
}
static void *_p_IMP__core__ConstantSingletonPredicateTo_p_IMP__SingletonPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonPredicate *)  ((IMP::core::ConstantSingletonPredicate *) x));
}
static void *_p_IMP__core__InBoundingBox3DSingletonPredicateTo_p_IMP__SingletonPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonPredicate *)  ((IMP::core::InBoundingBox3DSingletonPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeSingletonPredicateTo_p_IMP__SingletonPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonPredicate *)  ((IMP::core::OrderedTypeSingletonPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeSingletonPredicateTo_p_IMP__SingletonPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonPredicate *)  ((IMP::core::UnorderedTypeSingletonPredicate *) x));
}
static void *_p_IMP__container__MinimumSingletonScoreTo_p_IMP__SingletonScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonScore *)  ((IMP::container::MinimumSingletonScore *) x));
}
static void *_p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__SingletonScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonScore *)  ((IMP::core::GenericAttributeSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__SingletonScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonScore *)  ((IMP::core::GenericBoundingBox3DSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__SingletonScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonScore *)  ((IMP::core::GenericBoundingSphere3DSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__SingletonScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonScore *)  ((IMP::core::GenericDistanceToSingletonScore< IMP::UnaryFunction > *) x));
}
static void *_p_IMP__core__SphereDistanceToSingletonScoreTo_p_IMP__SingletonScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonScore *)  ((IMP::core::SphereDistanceToSingletonScore *) x));
}
static void *_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScoreTo_p_IMP__SingletonScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonScore *)  ((IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *) x));
}
static void *_p_IMP__insulinsecretion__VesicleTraffickingSingletonScoreTo_p_IMP__SingletonScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonScore *)  ((IMP::insulinsecretion::VesicleTraffickingSingletonScore *) x));
}
static void *_p_IMP__internal___ConstSingletonScoreTo_p_IMP__SingletonScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::SingletonScore *)  ((IMP::internal::_ConstSingletonScore *) x));
}
static void *_p_IMP__container__DynamicListTripletContainerTo_p_IMP__TripletContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletContainer *)  ((IMP::container::DynamicListTripletContainer *) x));
}
static void *_p_IMP__container__ListTripletContainerTo_p_IMP__TripletContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletContainer *)  ((IMP::container::ListTripletContainer *) x));
}
static void *_p_IMP__container__TripletContainerSetTo_p_IMP__TripletContainer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletContainer *)  ((IMP::container::TripletContainerSet *) x));
}
static void *_p_IMP__container__InContainerTripletFilterTo_p_IMP__TripletPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletPredicate *)  ((IMP::container::InContainerTripletFilter *) x));
}
static void *_p_IMP__core__AllSameTripletPredicateTo_p_IMP__TripletPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletPredicate *)  ((IMP::core::AllSameTripletPredicate *) x));
}
static void *_p_IMP__core__CoinFlipTripletPredicateTo_p_IMP__TripletPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletPredicate *)  ((IMP::core::CoinFlipTripletPredicate *) x));
}
static void *_p_IMP__core__ConstantTripletPredicateTo_p_IMP__TripletPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletPredicate *)  ((IMP::core::ConstantTripletPredicate *) x));
}
static void *_p_IMP__core__OrderedTypeTripletPredicateTo_p_IMP__TripletPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletPredicate *)  ((IMP::core::OrderedTypeTripletPredicate *) x));
}
static void *_p_IMP__core__UnorderedTypeTripletPredicateTo_p_IMP__TripletPredicate(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletPredicate *)  ((IMP::core::UnorderedTypeTripletPredicate *) x));
}
static void *_p_IMP__container__MinimumTripletScoreTo_p_IMP__TripletScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletScore *)  ((IMP::container::MinimumTripletScore *) x));
}
static void *_p_IMP__core__AngleTripletScoreTo_p_IMP__TripletScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::TripletScore *)  ((IMP::core::AngleTripletScore *) x));
}
static void *_p_IMP__core__ClosedCubicSplineTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::ClosedCubicSpline *) x));
}
static void *_p_IMP__core__CosineTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::Cosine *) x));
}
static void *_p_IMP__core__HarmonicTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::Harmonic *) x));
}
static void *_p_IMP__core__HarmonicLowerBoundTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *) (IMP::core::Harmonic *) ((IMP::core::HarmonicLowerBound *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *) (IMP::core::Harmonic *) ((IMP::core::HarmonicUpperBound *) x));
}
static void *_p_IMP__core__HarmonicWellTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::HarmonicWell *) x));
}
static void *_p_IMP__core__LinearTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::Linear *) x));
}
static void *_p_IMP__core__OpenCubicSplineTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *) (IMP::score_functor::ScoreUnaryFunction< IMP::score_functor::OpenCubicSpline > *) ((IMP::core::OpenCubicSpline *) x));
}
static void *_p_IMP__core__SurfaceTetheredChainTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::SurfaceTetheredChain *) x));
}
static void *_p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_tTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::TruncatedHarmonic< IMP::core::BOTH > *) x));
}
static void *_p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_tTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::TruncatedHarmonic< IMP::core::LOWER > *) x));
}
static void *_p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_tTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::TruncatedHarmonic< IMP::core::UPPER > *) x));
}
static void *_p_IMP__core__WeightedSumTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::WeightedSum *) x));
}
static void *_p_IMP__core__WeightedSumOfExponentialTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::core::WeightedSumOfExponential *) x));
}
static void *_p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_tTo_p_IMP__UnaryFunction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::UnaryFunction *)  ((IMP::score_functor::ScoreUnaryFunction< IMP::score_functor::OpenCubicSpline,2 > *) x));
}
static void *_p_IMP__DecoratorTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Decorator *) x));
}
static void *_p_IMP__FloatIndexTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::FloatIndex *) x));
}
static void *_p_IMP__IndexT_IMP__ParticleIndexTag_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Index< IMP::ParticleIndexTag > *) x));
}
static void *_p_IMP__KeyT_0_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 0 > *) x));
}
static void *_p_IMP__KeyT_1_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 1 > *) x));
}
static void *_p_IMP__KeyT_10_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 10 > *) x));
}
static void *_p_IMP__KeyT_11_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 11 > *) x));
}
static void *_p_IMP__KeyT_12_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 12 > *) x));
}
static void *_p_IMP__KeyT_13_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 13 > *) x));
}
static void *_p_IMP__KeyT_14_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 14 > *) x));
}
static void *_p_IMP__KeyT_15_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 15 > *) x));
}
static void *_p_IMP__KeyT_2_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 2 > *) x));
}
static void *_p_IMP__KeyT_3_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 3 > *) x));
}
static void *_p_IMP__KeyT_34897493_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 34897493 > *) x));
}
static void *_p_IMP__KeyT_4_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 4 > *) x));
}
static void *_p_IMP__KeyT_5_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 5 > *) x));
}
static void *_p_IMP__KeyT_6_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 6 > *) x));
}
static void *_p_IMP__KeyT_8_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::Key< 8 > *) x));
}
static void *_p_IMP__ScoreAccumulatorTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::ScoreAccumulator *) x));
}
static void *_p_IMP__VersionInfoTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::VersionInfo *) x));
}
static void *_p_IMP__algebra__ExtendedGridIndexDT__1_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::ExtendedGridIndexD< -1 > *) x));
}
static void *_p_IMP__algebra__ExtendedGridIndexDT_1_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::ExtendedGridIndexD< 1 > *) x));
}
static void *_p_IMP__algebra__ExtendedGridIndexDT_2_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::ExtendedGridIndexD< 2 > *) x));
}
static void *_p_IMP__algebra__ExtendedGridIndexDT_3_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::ExtendedGridIndexD< 3 > *) x));
}
static void *_p_IMP__algebra__ExtendedGridIndexDT_4_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::ExtendedGridIndexD< 4 > *) x));
}
static void *_p_IMP__algebra__ExtendedGridIndexDT_5_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::ExtendedGridIndexD< 5 > *) x));
}
static void *_p_IMP__algebra__ExtendedGridIndexDT_6_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::ExtendedGridIndexD< 6 > *) x));
}
static void *_p_IMP__algebra__GridIndexDT__1_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::GridIndexD< -1 > *) x));
}
static void *_p_IMP__algebra__GridIndexDT_1_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::GridIndexD< 1 > *) x));
}
static void *_p_IMP__algebra__GridIndexDT_2_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::GridIndexD< 2 > *) x));
}
static void *_p_IMP__algebra__GridIndexDT_3_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::GridIndexD< 3 > *) x));
}
static void *_p_IMP__algebra__GridIndexDT_4_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::GridIndexD< 4 > *) x));
}
static void *_p_IMP__algebra__GridIndexDT_5_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::GridIndexD< 5 > *) x));
}
static void *_p_IMP__algebra__GridIndexDT_6_tTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::algebra::GridIndexD< 6 > *) x));
}
static void *_p_IMP__core__CentroidTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::XYZ *) ((IMP::core::Centroid *) x));
}
static void *_p_IMP__core__ClusterProvenanceTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::Provenance *) ((IMP::core::ClusterProvenance *) x));
}
static void *_p_IMP__core__CombineProvenanceTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::Provenance *) ((IMP::core::CombineProvenance *) x));
}
static void *_p_IMP__core__CoverTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::XYZ *)(IMP::core::XYZR *) ((IMP::core::Cover *) x));
}
static void *_p_IMP__core__DirectionTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::core::Direction *) x));
}
static void *_p_IMP__core__DirectionAngleTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::core::DirectionAngle *) x));
}
static void *_p_IMP__core__FilterProvenanceTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::Provenance *) ((IMP::core::FilterProvenance *) x));
}
static void *_p_IMP__core__GaussianTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::XYZ *)(IMP::core::RigidBody *) ((IMP::core::Gaussian *) x));
}
static void *_p_IMP__core__HierarchyTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::core::Hierarchy *) x));
}
static void *_p_IMP__core__MonteCarloMoverResultTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::core::MonteCarloMoverResult *) x));
}
static void *_p_IMP__core__NonRigidMemberTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::XYZ *)(IMP::core::RigidBodyMember *) ((IMP::core::NonRigidMember *) x));
}
static void *_p_IMP__core__ProvenanceTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::core::Provenance *) x));
}
static void *_p_IMP__core__ProvenancedTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::core::Provenanced *) x));
}
static void *_p_IMP__core__ReferenceTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::core::Reference *) x));
}
static void *_p_IMP__core__RigidBodyTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::XYZ *) ((IMP::core::RigidBody *) x));
}
static void *_p_IMP__core__RigidBodyMemberTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::XYZ *) ((IMP::core::RigidBodyMember *) x));
}
static void *_p_IMP__core__RigidMemberTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::XYZ *)(IMP::core::RigidBodyMember *) ((IMP::core::RigidMember *) x));
}
static void *_p_IMP__core__SampleProvenanceTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::Provenance *) ((IMP::core::SampleProvenance *) x));
}
static void *_p_IMP__core__ScriptProvenanceTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::Provenance *) ((IMP::core::ScriptProvenance *) x));
}
static void *_p_IMP__core__SoftwareProvenanceTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::Provenance *) ((IMP::core::SoftwareProvenance *) x));
}
static void *_p_IMP__core__StructureProvenanceTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::Provenance *) ((IMP::core::StructureProvenance *) x));
}
static void *_p_IMP__core__SurfaceTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::XYZ *) ((IMP::core::Surface *) x));
}
static void *_p_IMP__core__TypedTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::core::Typed *) x));
}
static void *_p_IMP__core__XYZTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::core::XYZ *) x));
}
static void *_p_IMP__core__XYZRTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::core::XYZ *) ((IMP::core::XYZR *) x));
}
static void *_p_IMP__display__ColorTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *)  ((IMP::display::Color *) x));
}
static void *_p_IMP__display__ColoredTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::display::Colored *) x));
}
static void *_p_IMP__insulinsecretion__CaChannelStateDecoratorTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::insulinsecretion::CaChannelStateDecorator *) x));
}
static void *_p_IMP__insulinsecretion__DockingStateDecoratorTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::insulinsecretion::DockingStateDecorator *) x));
}
static void *_p_IMP__insulinsecretion__MaturationStateDecoratorTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::insulinsecretion::MaturationStateDecorator *) x));
}
static void *_p_IMP__insulinsecretion__SecretionCounterDecoratorTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::insulinsecretion::SecretionCounterDecorator *) x));
}
static void *_p_IMP__internal___TrivialDecoratorTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::internal::_TrivialDecorator *) x));
}
static void *_p_IMP__internal___TrivialDerivedDecoratorTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *)(IMP::internal::_TrivialDecorator *) ((IMP::internal::_TrivialDerivedDecorator *) x));
}
static void *_p_IMP__internal___TrivialTraitsDecoratorTo_p_IMP__Value(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::Value *) (IMP::Decorator *) ((IMP::internal::_TrivialTraitsDecorator *) x));
}
static void *_p_IMP__algebra__PrincipalComponentAnalysisDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< -1 > *)  ((IMP::algebra::PrincipalComponentAnalysisD< -1 > *) x));
}
static void *_p_IMP__algebra__SphereDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< -1 > *)  ((IMP::algebra::SphereD< -1 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexBaseDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< -1 > *)  ((IMP::algebra::UnitSimplexBaseD< -1 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< -1 > *) (IMP::algebra::UnitSimplexBaseD< -1 > *) ((IMP::algebra::UnitSimplexD< -1 > *) x));
}
static void *_p_IMP__algebra__VectorBaseDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< -1 > *)  ((IMP::algebra::VectorBaseD< -1 > *) x));
}
static void *_p_IMP__algebra__VectorDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< -1 > *) (IMP::algebra::VectorBaseD< -1 > *) ((IMP::algebra::VectorD< -1 > *) x));
}
static void *_p_IMP__algebra__PrincipalComponentAnalysisDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 1 > *)  ((IMP::algebra::PrincipalComponentAnalysisD< 1 > *) x));
}
static void *_p_IMP__algebra__SphereDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 1 > *)  ((IMP::algebra::SphereD< 1 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexBaseDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 1 > *)  ((IMP::algebra::UnitSimplexBaseD< 1 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 1 > *) (IMP::algebra::UnitSimplexBaseD< 1 > *) ((IMP::algebra::UnitSimplexD< 1 > *) x));
}
static void *_p_IMP__algebra__VectorBaseDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 1 > *)  ((IMP::algebra::VectorBaseD< 1 > *) x));
}
static void *_p_IMP__algebra__VectorDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 1 > *) (IMP::algebra::VectorBaseD< 1 > *) ((IMP::algebra::VectorD< 1 > *) x));
}
static void *_p_IMP__algebra__LinearFit2DTo_p_IMP__algebra__GeometricPrimitiveDT_2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 2 > *)  ((IMP::algebra::LinearFit2D *) x));
}
static void *_p_IMP__algebra__ParabolicFit2DTo_p_IMP__algebra__GeometricPrimitiveDT_2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 2 > *)  ((IMP::algebra::ParabolicFit2D *) x));
}
static void *_p_IMP__algebra__PrincipalComponentAnalysisDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 2 > *)  ((IMP::algebra::PrincipalComponentAnalysisD< 2 > *) x));
}
static void *_p_IMP__algebra__Rotation2DTo_p_IMP__algebra__GeometricPrimitiveDT_2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 2 > *)  ((IMP::algebra::Rotation2D *) x));
}
static void *_p_IMP__algebra__SphereDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 2 > *)  ((IMP::algebra::SphereD< 2 > *) x));
}
static void *_p_IMP__algebra__Transformation2DTo_p_IMP__algebra__GeometricPrimitiveDT_2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 2 > *)  ((IMP::algebra::Transformation2D *) x));
}
static void *_p_IMP__algebra__UnitSimplexBaseDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 2 > *)  ((IMP::algebra::UnitSimplexBaseD< 2 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 2 > *) (IMP::algebra::UnitSimplexBaseD< 2 > *) ((IMP::algebra::UnitSimplexD< 2 > *) x));
}
static void *_p_IMP__algebra__VectorBaseDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 2 > *)  ((IMP::algebra::VectorBaseD< 2 > *) x));
}
static void *_p_IMP__algebra__VectorDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 2 > *) (IMP::algebra::VectorBaseD< 2 > *) ((IMP::algebra::VectorD< 2 > *) x));
}
static void *_p_IMP__algebra__Cone3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Cone3D *) x));
}
static void *_p_IMP__algebra__Cylinder3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Cylinder3D *) x));
}
static void *_p_IMP__algebra__Ellipsoid3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Ellipsoid3D *) x));
}
static void *_p_IMP__algebra__FixedXYZTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::FixedXYZ *) x));
}
static void *_p_IMP__algebra__Gaussian3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Gaussian3D *) x));
}
static void *_p_IMP__algebra__Line3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Line3D *) x));
}
static void *_p_IMP__algebra__Plane3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Plane3D *) x));
}
static void *_p_IMP__algebra__PrincipalComponentAnalysisDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::PrincipalComponentAnalysisD< 3 > *) x));
}
static void *_p_IMP__algebra__Reflection3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Reflection3D *) x));
}
static void *_p_IMP__algebra__Rotation3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Rotation3D *) x));
}
static void *_p_IMP__algebra__Segment3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Segment3D *) x));
}
static void *_p_IMP__algebra__SphereDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::SphereD< 3 > *) x));
}
static void *_p_IMP__algebra__SpherePatch3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::SpherePatch3D *) x));
}
static void *_p_IMP__algebra__SphericalVector3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::SphericalVector3D *) x));
}
static void *_p_IMP__algebra__Transformation3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Transformation3D *) x));
}
static void *_p_IMP__algebra__Triangle3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::Triangle3D *) x));
}
static void *_p_IMP__algebra__UnitSimplexBaseDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::UnitSimplexBaseD< 3 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *) (IMP::algebra::UnitSimplexBaseD< 3 > *) ((IMP::algebra::UnitSimplexD< 3 > *) x));
}
static void *_p_IMP__algebra__VectorBaseDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *)  ((IMP::algebra::VectorBaseD< 3 > *) x));
}
static void *_p_IMP__algebra__VectorDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 3 > *) (IMP::algebra::VectorBaseD< 3 > *) ((IMP::algebra::VectorD< 3 > *) x));
}
static void *_p_IMP__algebra__PrincipalComponentAnalysisDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 4 > *)  ((IMP::algebra::PrincipalComponentAnalysisD< 4 > *) x));
}
static void *_p_IMP__algebra__SphereDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 4 > *)  ((IMP::algebra::SphereD< 4 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexBaseDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 4 > *)  ((IMP::algebra::UnitSimplexBaseD< 4 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 4 > *) (IMP::algebra::UnitSimplexBaseD< 4 > *) ((IMP::algebra::UnitSimplexD< 4 > *) x));
}
static void *_p_IMP__algebra__VectorBaseDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 4 > *)  ((IMP::algebra::VectorBaseD< 4 > *) x));
}
static void *_p_IMP__algebra__VectorDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 4 > *) (IMP::algebra::VectorBaseD< 4 > *) ((IMP::algebra::VectorD< 4 > *) x));
}
static void *_p_IMP__algebra__PrincipalComponentAnalysisDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 5 > *)  ((IMP::algebra::PrincipalComponentAnalysisD< 5 > *) x));
}
static void *_p_IMP__algebra__SphereDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 5 > *)  ((IMP::algebra::SphereD< 5 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexBaseDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 5 > *)  ((IMP::algebra::UnitSimplexBaseD< 5 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 5 > *) (IMP::algebra::UnitSimplexBaseD< 5 > *) ((IMP::algebra::UnitSimplexD< 5 > *) x));
}
static void *_p_IMP__algebra__VectorBaseDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 5 > *)  ((IMP::algebra::VectorBaseD< 5 > *) x));
}
static void *_p_IMP__algebra__VectorDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 5 > *) (IMP::algebra::VectorBaseD< 5 > *) ((IMP::algebra::VectorD< 5 > *) x));
}
static void *_p_IMP__algebra__PrincipalComponentAnalysisDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 6 > *)  ((IMP::algebra::PrincipalComponentAnalysisD< 6 > *) x));
}
static void *_p_IMP__algebra__SphereDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 6 > *)  ((IMP::algebra::SphereD< 6 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexBaseDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 6 > *)  ((IMP::algebra::UnitSimplexBaseD< 6 > *) x));
}
static void *_p_IMP__algebra__UnitSimplexDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 6 > *) (IMP::algebra::UnitSimplexBaseD< 6 > *) ((IMP::algebra::UnitSimplexD< 6 > *) x));
}
static void *_p_IMP__algebra__VectorBaseDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 6 > *)  ((IMP::algebra::VectorBaseD< 6 > *) x));
}
static void *_p_IMP__algebra__VectorDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::GeometricPrimitiveD< 6 > *) (IMP::algebra::VectorBaseD< 6 > *) ((IMP::algebra::VectorD< 6 > *) x));
}
static void *_p_IMP__algebra__EuclideanVectorKDMetricTo_p_IMP__algebra__VectorKDMetric(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::VectorKDMetric *)  ((IMP::algebra::EuclideanVectorKDMetric *) x));
}
static void *_p_IMP__algebra__MaxVectorKDMetricTo_p_IMP__algebra__VectorKDMetric(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::algebra::VectorKDMetric *)  ((IMP::algebra::MaxVectorKDMetric *) x));
}
static void *_p_IMP__core__BoxSweepClosePairsFinderTo_p_IMP__core__ClosePairsFinder(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::ClosePairsFinder *)  ((IMP::core::BoxSweepClosePairsFinder *) x));
}
static void *_p_IMP__core__GridClosePairsFinderTo_p_IMP__core__ClosePairsFinder(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::ClosePairsFinder *)  ((IMP::core::GridClosePairsFinder *) x));
}
static void *_p_IMP__core__NearestNeighborsClosePairsFinderTo_p_IMP__core__ClosePairsFinder(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::ClosePairsFinder *)  ((IMP::core::NearestNeighborsClosePairsFinder *) x));
}
static void *_p_IMP__core__QuadraticClosePairsFinderTo_p_IMP__core__ClosePairsFinder(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::ClosePairsFinder *)  ((IMP::core::QuadraticClosePairsFinder *) x));
}
static void *_p_IMP__core__RigidClosePairsFinderTo_p_IMP__core__ClosePairsFinder(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::ClosePairsFinder *)  ((IMP::core::RigidClosePairsFinder *) x));
}
static void *_p_IMP__core__HarmonicLowerBoundTo_p_IMP__core__Harmonic(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::Harmonic *)  ((IMP::core::HarmonicLowerBound *) x));
}
static void *_p_IMP__core__HarmonicUpperBoundTo_p_IMP__core__Harmonic(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::Harmonic *)  ((IMP::core::HarmonicUpperBound *) x));
}
static void *_p_IMP__core__RigidBodyDistancePairScoreTo_p_IMP__core__KClosePairsPairScore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::KClosePairsPairScore *)  ((IMP::core::RigidBodyDistancePairScore *) x));
}
static void *_p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__core__MonteCarlo(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarlo *) (IMP::core::MonteCarloWithLocalOptimization *) ((IMP::core::MonteCarloWithBasinHopping *) x));
}
static void *_p_IMP__core__MonteCarloWithLocalOptimizationTo_p_IMP__core__MonteCarlo(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarlo *)  ((IMP::core::MonteCarloWithLocalOptimization *) x));
}
static void *_p_IMP__core__BallMoverTo_p_IMP__core__MonteCarloMover(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloMover *)  ((IMP::core::BallMover *) x));
}
static void *_p_IMP__core__DirectionMoverTo_p_IMP__core__MonteCarloMover(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloMover *)  ((IMP::core::DirectionMover *) x));
}
static void *_p_IMP__core__LogNormalMoverTo_p_IMP__core__MonteCarloMover(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloMover *)  ((IMP::core::LogNormalMover *) x));
}
static void *_p_IMP__core__NormalMoverTo_p_IMP__core__MonteCarloMover(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloMover *)  ((IMP::core::NormalMover *) x));
}
static void *_p_IMP__core__RigidBodyMoverTo_p_IMP__core__MonteCarloMover(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloMover *)  ((IMP::core::RigidBodyMover *) x));
}
static void *_p_IMP__core__RigidBodyTunnelerTo_p_IMP__core__MonteCarloMover(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloMover *)  ((IMP::core::RigidBodyTunneler *) x));
}
static void *_p_IMP__core__SerialMoverTo_p_IMP__core__MonteCarloMover(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloMover *)  ((IMP::core::SerialMover *) x));
}
static void *_p_IMP__core__SubsetMoverTo_p_IMP__core__MonteCarloMover(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloMover *)  ((IMP::core::SubsetMover *) x));
}
static void *_p_IMP__core__SurfaceMoverTo_p_IMP__core__MonteCarloMover(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloMover *)  ((IMP::core::SurfaceMover *) x));
}
static void *_p_IMP__core__TransformationSymmetryMoverTo_p_IMP__core__MonteCarloMover(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloMover *)  ((IMP::core::TransformationSymmetryMover *) x));
}
static void *_p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__core__MonteCarloWithLocalOptimization(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::MonteCarloWithLocalOptimization *)  ((IMP::core::MonteCarloWithBasinHopping *) x));
}
static void *_p_IMP__core__ClusterProvenanceTo_p_IMP__core__Provenance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::Provenance *)  ((IMP::core::ClusterProvenance *) x));
}
static void *_p_IMP__core__CombineProvenanceTo_p_IMP__core__Provenance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::Provenance *)  ((IMP::core::CombineProvenance *) x));
}
static void *_p_IMP__core__FilterProvenanceTo_p_IMP__core__Provenance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::Provenance *)  ((IMP::core::FilterProvenance *) x));
}
static void *_p_IMP__core__SampleProvenanceTo_p_IMP__core__Provenance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::Provenance *)  ((IMP::core::SampleProvenance *) x));
}
static void *_p_IMP__core__ScriptProvenanceTo_p_IMP__core__Provenance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::Provenance *)  ((IMP::core::ScriptProvenance *) x));
}
static void *_p_IMP__core__SoftwareProvenanceTo_p_IMP__core__Provenance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::Provenance *)  ((IMP::core::SoftwareProvenance *) x));
}
static void *_p_IMP__core__StructureProvenanceTo_p_IMP__core__Provenance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::Provenance *)  ((IMP::core::StructureProvenance *) x));
}
static void *_p_IMP__core__GaussianTo_p_IMP__core__RigidBody(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::RigidBody *)  ((IMP::core::Gaussian *) x));
}
static void *_p_IMP__core__NonRigidMemberTo_p_IMP__core__RigidBodyMember(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::RigidBodyMember *)  ((IMP::core::NonRigidMember *) x));
}
static void *_p_IMP__core__RigidMemberTo_p_IMP__core__RigidBodyMember(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::RigidBodyMember *)  ((IMP::core::RigidMember *) x));
}
static void *_p_IMP__core__AngleRestraintTo_p_IMP__core__TripletRestraint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::TripletRestraint *)  ((IMP::core::AngleRestraint *) x));
}
static void *_p_IMP__core__CentroidTo_p_IMP__core__XYZ(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::XYZ *)  ((IMP::core::Centroid *) x));
}
static void *_p_IMP__core__CoverTo_p_IMP__core__XYZ(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::XYZ *) (IMP::core::XYZR *) ((IMP::core::Cover *) x));
}
static void *_p_IMP__core__GaussianTo_p_IMP__core__XYZ(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::XYZ *) (IMP::core::RigidBody *) ((IMP::core::Gaussian *) x));
}
static void *_p_IMP__core__NonRigidMemberTo_p_IMP__core__XYZ(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::XYZ *) (IMP::core::RigidBodyMember *) ((IMP::core::NonRigidMember *) x));
}
static void *_p_IMP__core__RigidBodyTo_p_IMP__core__XYZ(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::XYZ *)  ((IMP::core::RigidBody *) x));
}
static void *_p_IMP__core__RigidBodyMemberTo_p_IMP__core__XYZ(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::XYZ *)  ((IMP::core::RigidBodyMember *) x));
}
static void *_p_IMP__core__RigidMemberTo_p_IMP__core__XYZ(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::XYZ *) (IMP::core::RigidBodyMember *) ((IMP::core::RigidMember *) x));
}
static void *_p_IMP__core__SurfaceTo_p_IMP__core__XYZ(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::XYZ *)  ((IMP::core::Surface *) x));
}
static void *_p_IMP__core__XYZRTo_p_IMP__core__XYZ(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::XYZ *)  ((IMP::core::XYZR *) x));
}
static void *_p_IMP__core__CoverTo_p_IMP__core__XYZR(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::core::XYZR *)  ((IMP::core::Cover *) x));
}
static void *_p_IMP__core__EdgePairGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::PairGeometry *) ((IMP::core::EdgePairGeometry *) x));
}
static void *_p_IMP__core__EdgePairsGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::PairsGeometry *) ((IMP::core::EdgePairsGeometry *) x));
}
static void *_p_IMP__core__RigidBodyDerivativeGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SingletonGeometry *) ((IMP::core::RigidBodyDerivativeGeometry *) x));
}
static void *_p_IMP__core__RigidBodyDerivativesGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SingletonsGeometry *) ((IMP::core::RigidBodyDerivativesGeometry *) x));
}
static void *_p_IMP__core__RigidBodyFrameGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SingletonGeometry *) ((IMP::core::RigidBodyFrameGeometry *) x));
}
static void *_p_IMP__core__RigidBodyFramesGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SingletonsGeometry *) ((IMP::core::RigidBodyFramesGeometry *) x));
}
static void *_p_IMP__core__RigidBodyHierarchyGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SingletonGeometry *) ((IMP::core::RigidBodyHierarchyGeometry *) x));
}
static void *_p_IMP__core__RigidBodyTorqueTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SegmentGeometry *) ((IMP::core::RigidBodyTorque *) x));
}
static void *_p_IMP__core__SurfaceGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::core::SurfaceGeometry *) x));
}
static void *_p_IMP__core__XYZDerivativeGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SingletonGeometry *) ((IMP::core::XYZDerivativeGeometry *) x));
}
static void *_p_IMP__core__XYZDerivativesGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SingletonsGeometry *) ((IMP::core::XYZDerivativesGeometry *) x));
}
static void *_p_IMP__core__XYZRGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SingletonGeometry *) ((IMP::core::XYZRGeometry *) x));
}
static void *_p_IMP__core__XYZRsGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SingletonsGeometry *) ((IMP::core::XYZRsGeometry *) x));
}
static void *_p_IMP__display__BoundingBoxGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::BoundingBoxGeometry *) x));
}
static void *_p_IMP__display__CylinderGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::CylinderGeometry *) x));
}
static void *_p_IMP__display__EllipsoidGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::EllipsoidGeometry *) x));
}
static void *_p_IMP__display__FilterGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::FilterGeometry *) x));
}
static void *_p_IMP__display__GeometrySetTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::GeometrySet *) x));
}
static void *_p_IMP__display__IsosurfaceGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SurfaceMeshGeometry *) ((IMP::display::IsosurfaceGeometry *) x));
}
static void *_p_IMP__display__LabelGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::LabelGeometry *) x));
}
static void *_p_IMP__display__PairGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::PairGeometry *) x));
}
static void *_p_IMP__display__PairsGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::PairsGeometry *) x));
}
static void *_p_IMP__display__PlaneGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::PlaneGeometry *) x));
}
static void *_p_IMP__display__PointGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::PointGeometry *) x));
}
static void *_p_IMP__display__PolygonGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::PolygonGeometry *) x));
}
static void *_p_IMP__display__ReferenceFrameGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::ReferenceFrameGeometry *) x));
}
static void *_p_IMP__display__RestraintGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::RestraintGeometry *) x));
}
static void *_p_IMP__display__RestraintSetGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::RestraintSetGeometry *) x));
}
static void *_p_IMP__display__SegmentGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::SegmentGeometry *) x));
}
static void *_p_IMP__display__SingletonGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::SingletonGeometry *) x));
}
static void *_p_IMP__display__SingletonsGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::SingletonsGeometry *) x));
}
static void *_p_IMP__display__SkinSurfaceGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *) (IMP::display::SurfaceMeshGeometry *) ((IMP::display::SkinSurfaceGeometry *) x));
}
static void *_p_IMP__display__SphereGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::SphereGeometry *) x));
}
static void *_p_IMP__display__SurfaceMeshGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::SurfaceMeshGeometry *) x));
}
static void *_p_IMP__display__TriangleGeometryTo_p_IMP__display__Geometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Geometry *)  ((IMP::display::TriangleGeometry *) x));
}
static void *_p_IMP__core__EdgePairGeometryTo_p_IMP__display__PairGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::PairGeometry *)  ((IMP::core::EdgePairGeometry *) x));
}
static void *_p_IMP__core__EdgePairsGeometryTo_p_IMP__display__PairsGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::PairsGeometry *)  ((IMP::core::EdgePairsGeometry *) x));
}
static void *_p_IMP__core__RigidBodyTorqueTo_p_IMP__display__SegmentGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SegmentGeometry *)  ((IMP::core::RigidBodyTorque *) x));
}
static void *_p_IMP__core__RigidBodyDerivativeGeometryTo_p_IMP__display__SingletonGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SingletonGeometry *)  ((IMP::core::RigidBodyDerivativeGeometry *) x));
}
static void *_p_IMP__core__RigidBodyFrameGeometryTo_p_IMP__display__SingletonGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SingletonGeometry *)  ((IMP::core::RigidBodyFrameGeometry *) x));
}
static void *_p_IMP__core__RigidBodyHierarchyGeometryTo_p_IMP__display__SingletonGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SingletonGeometry *)  ((IMP::core::RigidBodyHierarchyGeometry *) x));
}
static void *_p_IMP__core__XYZDerivativeGeometryTo_p_IMP__display__SingletonGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SingletonGeometry *)  ((IMP::core::XYZDerivativeGeometry *) x));
}
static void *_p_IMP__core__XYZRGeometryTo_p_IMP__display__SingletonGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SingletonGeometry *)  ((IMP::core::XYZRGeometry *) x));
}
static void *_p_IMP__core__RigidBodyDerivativesGeometryTo_p_IMP__display__SingletonsGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SingletonsGeometry *)  ((IMP::core::RigidBodyDerivativesGeometry *) x));
}
static void *_p_IMP__core__RigidBodyFramesGeometryTo_p_IMP__display__SingletonsGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SingletonsGeometry *)  ((IMP::core::RigidBodyFramesGeometry *) x));
}
static void *_p_IMP__core__XYZDerivativesGeometryTo_p_IMP__display__SingletonsGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SingletonsGeometry *)  ((IMP::core::XYZDerivativesGeometry *) x));
}
static void *_p_IMP__core__XYZRsGeometryTo_p_IMP__display__SingletonsGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SingletonsGeometry *)  ((IMP::core::XYZRsGeometry *) x));
}
static void *_p_IMP__display__IsosurfaceGeometryTo_p_IMP__display__SurfaceMeshGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SurfaceMeshGeometry *)  ((IMP::display::IsosurfaceGeometry *) x));
}
static void *_p_IMP__display__SkinSurfaceGeometryTo_p_IMP__display__SurfaceMeshGeometry(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::SurfaceMeshGeometry *)  ((IMP::display::SkinSurfaceGeometry *) x));
}
static void *_p_IMP__display__PymolWriterTo_p_IMP__display__TextWriter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::TextWriter *)  ((IMP::display::PymolWriter *) x));
}
static void *_p_IMP__display__PymolWriterTo_p_IMP__display__Writer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Writer *) (IMP::display::TextWriter *) ((IMP::display::PymolWriter *) x));
}
static void *_p_IMP__display__TextWriterTo_p_IMP__display__Writer(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::display::Writer *)  ((IMP::display::TextWriter *) x));
}
static void *_p_IMP__internal___TrivialDerivedDecoratorTo_p_IMP__internal___TrivialDecorator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IMP::internal::_TrivialDecorator *)  ((IMP::internal::_TrivialDerivedDecorator *) x));
}
static swig_type_info _swigt__p_Argument = {"_p_Argument", "Argument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ContainedIndexType = {"_p_ContainedIndexType", "ContainedIndexType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ContainedIndexTypes = {"_p_ContainedIndexTypes", "ContainedIndexTypes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ContainedType = {"_p_ContainedType", "ContainedType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ContainedTypes = {"_p_ContainedTypes", "ContainedTypes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DecoratorHasTraits = {"_p_DecoratorHasTraits", "DecoratorHasTraits *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DecoratorTraits = {"_p_DecoratorTraits", "DecoratorTraits *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Eigen__ArrayXXd = {"_p_Eigen__ArrayXXd", "Eigen::ArrayXXd *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Eigen__ArrayXXf = {"_p_Eigen__ArrayXXf", "Eigen::ArrayXXf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Eigen__Matrix3d = {"_p_Eigen__Matrix3d", "Eigen::Matrix3d *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Eigen__MatrixXd = {"_p_Eigen__MatrixXd", "Eigen::MatrixXd *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Eigen__MatrixXf = {"_p_Eigen__MatrixXf", "Eigen::MatrixXf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Eigen__Vector3d = {"_p_Eigen__Vector3d", "Eigen::Vector3d *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Eigen__VectorXd = {"_p_Eigen__VectorXd", "Eigen::VectorXd *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Eigen__VectorXf = {"_p_Eigen__VectorXf", "Eigen::VectorXf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ExtendedIndex = {"_p_ExtendedIndex", "ExtendedIndex *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t = {"_p_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t", "IMP::ParticleIndexPair *|IMP::Array< 2,IMP::Index< IMP::ParticleIndexTag >,IMP::Index< IMP::ParticleIndexTag > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t = {"_p_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t", "IMP::ParticlePair *|IMP::Array< 2,WeakPointer< IMP::Particle >,IMP::Particle * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t = {"_p_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t", "IMP::ParticleIndexTriplet *|IMP::Array< 3,IMP::Index< IMP::ParticleIndexTag >,IMP::Index< IMP::ParticleIndexTag > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t = {"_p_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t", "IMP::ParticleTriplet *|IMP::Array< 3,WeakPointer< IMP::Particle >,IMP::Particle * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t = {"_p_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t", "IMP::ParticleIndexQuad *|IMP::Array< 4,IMP::Index< IMP::ParticleIndexTag >,IMP::Index< IMP::ParticleIndexTag > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t = {"_p_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t", "IMP::ParticleQuad *|IMP::Array< 4,WeakPointer< IMP::Particle >,IMP::Particle * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__AttributeOptimizer = {"_p_IMP__AttributeOptimizer", "IMP::AttributeOptimizer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__CheckLevel = {"_p_IMP__CheckLevel", "IMP::CheckLevel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Configuration = {"_p_IMP__Configuration", "IMP::Configuration *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ConfigurationSet = {"_p_IMP__ConfigurationSet", "IMP::ConfigurationSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Constraint = {"_p_IMP__Constraint", "IMP::Constraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Container = {"_p_IMP__Container", "IMP::Container *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__CreateLogContext = {"_p_IMP__CreateLogContext", "IMP::CreateLogContext *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Decorator = {"_p_IMP__Decorator", "IMP::Decorator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__DerivativeAccumulator = {"_p_IMP__DerivativeAccumulator", "IMP::DerivativeAccumulator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__EvaluationState = {"_p_IMP__EvaluationState", "IMP::EvaluationState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__FloatIndex = {"_p_IMP__FloatIndex", "IMP::FloatIndex *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__IndexT_IMP__ParticleIndexTag_t = {"_p_IMP__IndexT_IMP__ParticleIndexTag_t", "IMP::ParticleIndex *|IMP::Index< IMP::ParticleIndexTag > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_0_t = {"_p_IMP__KeyT_0_t", "IMP::FloatKey *|IMP::Key< 0 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_10_t = {"_p_IMP__KeyT_10_t", "IMP::FloatsKey *|IMP::Key< 10 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_11_t = {"_p_IMP__KeyT_11_t", "IMP::TriggerKey *|IMP::Key< 11 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_12_t = {"_p_IMP__KeyT_12_t", "IMP::SparseStringKey *|IMP::Key< 12 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_13_t = {"_p_IMP__KeyT_13_t", "IMP::SparseIntKey *|IMP::Key< 13 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_14_t = {"_p_IMP__KeyT_14_t", "IMP::SparseFloatKey *|IMP::Key< 14 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_15_t = {"_p_IMP__KeyT_15_t", "IMP::SparseParticleIndexKey *|IMP::Key< 15 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_1_t = {"_p_IMP__KeyT_1_t", "IMP::IntKey *|IMP::Key< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_2_t = {"_p_IMP__KeyT_2_t", "IMP::StringKey *|IMP::Key< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_34897493_t = {"_p_IMP__KeyT_34897493_t", "IMP::core::ParticleType *|IMP::Key< 34897493 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_3_t = {"_p_IMP__KeyT_3_t", "IMP::ParticleIndexKey *|IMP::ParticleKey *|IMP::Key< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_4_t = {"_p_IMP__KeyT_4_t", "IMP::ObjectKey *|IMP::Key< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_5_t = {"_p_IMP__KeyT_5_t", "IMP::IntsKey *|IMP::Key< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_6_t = {"_p_IMP__KeyT_6_t", "IMP::ParticleIndexesKey *|IMP::ParticlesKey *|IMP::Key< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_7_t = {"_p_IMP__KeyT_7_t", "IMP::ObjectsKey *|IMP::Key< 7 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_8_t = {"_p_IMP__KeyT_8_t", "IMP::ModelKey *|IMP::Key< 8 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__KeyT_9_t = {"_p_IMP__KeyT_9_t", "IMP::WeakObjectKey *|IMP::Key< 9 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Model = {"_p_IMP__Model", "::IMP::Model *|IMP::Model *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ModelObject = {"_p_IMP__ModelObject", "IMP::ModelObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__NonCopyable = {"_p_IMP__NonCopyable", "IMP::NonCopyable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__RAII = {"_p_IMP__RAII", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__internal___LogPairScore = {"_p_IMP__internal___LogPairScore", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_t = {"_p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__Object = {"_p_IMP__Object", "IMP::Object *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Optimizer = {"_p_IMP__Optimizer", "IMP::Optimizer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__OptimizerState = {"_p_IMP__OptimizerState", "IMP::core::PeriodicOptimizerState *|IMP::OptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__PairContainer = {"_p_IMP__PairContainer", "IMP::PairContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__PairModifier = {"_p_IMP__PairModifier", "IMP::PairDerivativeModifier *|IMP::PairModifier *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__PairPredicate = {"_p_IMP__PairPredicate", "IMP::PairPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__PairScore = {"_p_IMP__PairScore", "IMP::PairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Particle = {"_p_IMP__Particle", "IMP::Particle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ParticleAdaptor = {"_p_IMP__ParticleAdaptor", "IMP::ParticleAdaptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ParticleIndexesAdaptor = {"_p_IMP__ParticleIndexesAdaptor", "IMP::ParticleIndexesAdaptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ParticleInputs = {"_p_IMP__ParticleInputs", "IMP::ParticleInputs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__QuadContainer = {"_p_IMP__QuadContainer", "IMP::QuadContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__QuadModifier = {"_p_IMP__QuadModifier", "IMP::QuadDerivativeModifier *|IMP::QuadModifier *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__QuadPredicate = {"_p_IMP__QuadPredicate", "IMP::QuadPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__QuadScore = {"_p_IMP__QuadScore", "IMP::QuadScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Refiner = {"_p_IMP__Refiner", "IMP::Refiner *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Restraint = {"_p_IMP__Restraint", "IMP::Restraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__RestraintInfo = {"_p_IMP__RestraintInfo", "IMP::RestraintInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__RestraintSet = {"_p_IMP__RestraintSet", "IMP::RestraintSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Sampler = {"_p_IMP__Sampler", "IMP::Sampler *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__SaveToConfigurationSetOptimizerState = {"_p_IMP__SaveToConfigurationSetOptimizerState", "IMP::SaveToConfigurationSetOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ScopedSetAttributeT_IMP__KeyT_0_t_double_t = {"_p_IMP__ScopedSetAttributeT_IMP__KeyT_0_t_double_t", "IMP::ScopedSetFloatAttribute *|IMP::ScopedSetAttribute< IMP::Key< 0 >,double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ScoreAccumulator = {"_p_IMP__ScoreAccumulator", "IMP::ScoreAccumulator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ScoreState = {"_p_IMP__ScoreState", "IMP::ScoreState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__ScoringFunction = {"_p_IMP__ScoringFunction", "IMP::ScoringFunction *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__SetCheckState = {"_p_IMP__SetCheckState", "IMP::SetCheckState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__SetLogState = {"_p_IMP__SetLogState", "IMP::SetLogState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__SetLogTarget = {"_p_IMP__SetLogTarget", "IMP::SetLogTarget *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__SetNumberOfThreads = {"_p_IMP__SetNumberOfThreads", "IMP::SetNumberOfThreads *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__SingletonContainer = {"_p_IMP__SingletonContainer", "IMP::SingletonContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__SingletonContainerAdaptor = {"_p_IMP__SingletonContainerAdaptor", "IMP::SingletonContainerAdaptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__SingletonModifier = {"_p_IMP__SingletonModifier", "IMP::SingletonDerivativeModifier *|IMP::SingletonModifier *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__SingletonPredicate = {"_p_IMP__SingletonPredicate", "IMP::SingletonPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__SingletonScore = {"_p_IMP__SingletonScore", "IMP::SingletonScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__TripletContainer = {"_p_IMP__TripletContainer", "IMP::TripletContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__TripletModifier = {"_p_IMP__TripletModifier", "IMP::TripletDerivativeModifier *|IMP::TripletModifier *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__TripletPredicate = {"_p_IMP__TripletPredicate", "IMP::TripletPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__TripletScore = {"_p_IMP__TripletScore", "IMP::TripletScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__UnaryFunction = {"_p_IMP__UnaryFunction", "IMP::UnaryFunction *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Undecorator = {"_p_IMP__Undecorator", "IMP::Undecorator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__Value = {"_p_IMP__Value", "IMP::Value *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t = {"_p_IMP__VectorT_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t", "IMP::ParticleIndexPairs *|IMP::Vector< IMP::Array< 2,IMP::Index< IMP::ParticleIndexTag >,IMP::Index< IMP::ParticleIndexTag > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t = {"_p_IMP__VectorT_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t", "IMP::ParticlePairsTemp *|IMP::Vector< IMP::Array< 2,WeakPointer< IMP::Particle >,IMP::Particle * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t = {"_p_IMP__VectorT_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t", "IMP::ParticleIndexTriplets *|IMP::Vector< IMP::Array< 3,IMP::Index< IMP::ParticleIndexTag >,IMP::Index< IMP::ParticleIndexTag > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t = {"_p_IMP__VectorT_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t", "IMP::ParticleTripletsTemp *|IMP::Vector< IMP::Array< 3,WeakPointer< IMP::Particle >,IMP::Particle * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t = {"_p_IMP__VectorT_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t", "IMP::ParticleIndexQuads *|IMP::Vector< IMP::Array< 4,IMP::Index< IMP::ParticleIndexTag >,IMP::Index< IMP::ParticleIndexTag > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t = {"_p_IMP__VectorT_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t", "IMP::ParticleQuadsTemp *|IMP::Vector< IMP::Array< 4,WeakPointer< IMP::Particle >,IMP::Particle * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__DerivativeAccumulator_t = {"_p_IMP__VectorT_IMP__DerivativeAccumulator_t", "IMP::DerivativeAccumulators *|IMP::Vector< IMP::DerivativeAccumulator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__EvaluationState_t = {"_p_IMP__VectorT_IMP__EvaluationState_t", "IMP::EvaluationStates *|IMP::Vector< IMP::EvaluationState > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__FloatIndex_t = {"_p_IMP__VectorT_IMP__FloatIndex_t", "IMP::FloatIndexes *|IMP::Vector< IMP::FloatIndex > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__IndexT_IMP__ParticleIndexTag_t_t = {"_p_IMP__VectorT_IMP__IndexT_IMP__ParticleIndexTag_t_t", "IMP::ParticleIndexes *|IMP::Vector< IMP::Index< IMP::ParticleIndexTag > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_0_t_t = {"_p_IMP__VectorT_IMP__KeyT_0_t_t", "IMP::FloatKeys *|IMP::Vector< IMP::Key< 0 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_10_t_t = {"_p_IMP__VectorT_IMP__KeyT_10_t_t", "IMP::FloatsKeys *|IMP::Vector< IMP::Key< 10 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_11_t_t = {"_p_IMP__VectorT_IMP__KeyT_11_t_t", "IMP::TriggerKeys *|IMP::Vector< IMP::Key< 11 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_12_t_t = {"_p_IMP__VectorT_IMP__KeyT_12_t_t", "IMP::SparseStringKeys *|IMP::Vector< IMP::Key< 12 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_13_t_t = {"_p_IMP__VectorT_IMP__KeyT_13_t_t", "IMP::SparseIntKeys *|IMP::Vector< IMP::Key< 13 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_14_t_t = {"_p_IMP__VectorT_IMP__KeyT_14_t_t", "IMP::SparseFloatKeys *|IMP::Vector< IMP::Key< 14 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_15_t_t = {"_p_IMP__VectorT_IMP__KeyT_15_t_t", "IMP::SparseParticleIndexKeys *|IMP::Vector< IMP::Key< 15 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_1_t_t = {"_p_IMP__VectorT_IMP__KeyT_1_t_t", "IMP::IntKeys *|IMP::Vector< IMP::Key< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_2_t_t = {"_p_IMP__VectorT_IMP__KeyT_2_t_t", "IMP::StringKeys *|IMP::Vector< IMP::Key< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_34897493_t_t = {"_p_IMP__VectorT_IMP__KeyT_34897493_t_t", "IMP::core::ParticleTypes *|IMP::Vector< IMP::Key< 34897493 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_3_t_t = {"_p_IMP__VectorT_IMP__KeyT_3_t_t", "IMP::ParticleIndexKeys *|IMP::Vector< IMP::Key< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_4_t_t = {"_p_IMP__VectorT_IMP__KeyT_4_t_t", "IMP::ObjectKeys *|IMP::Vector< IMP::Key< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_5_t_t = {"_p_IMP__VectorT_IMP__KeyT_5_t_t", "IMP::IntsKeys *|IMP::Vector< IMP::Key< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_6_t_t = {"_p_IMP__VectorT_IMP__KeyT_6_t_t", "IMP::ParticleIndexesKeys *|IMP::Vector< IMP::Key< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_7_t_t = {"_p_IMP__VectorT_IMP__KeyT_7_t_t", "IMP::ObjectsKeys *|IMP::Vector< IMP::Key< 7 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_8_t_t = {"_p_IMP__VectorT_IMP__KeyT_8_t_t", "IMP::ModelKeys *|IMP::Vector< IMP::Key< 8 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__KeyT_9_t_t = {"_p_IMP__VectorT_IMP__KeyT_9_t_t", "IMP::WeakObjectKeys *|IMP::Vector< IMP::Key< 9 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__AttributeOptimizer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__AttributeOptimizer_t_t", "IMP::AttributeOptimizers *|IMP::Vector< IMP::Pointer< IMP::AttributeOptimizer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__ConfigurationSet_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__ConfigurationSet_t_t", "IMP::ConfigurationSets *|IMP::Vector< IMP::Pointer< IMP::ConfigurationSet > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__Configuration_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__Configuration_t_t", "IMP::Configurations *|IMP::Vector< IMP::Pointer< IMP::Configuration > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__Constraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__Constraint_t_t", "IMP::Constraints *|IMP::Vector< IMP::Pointer< IMP::Constraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__Container_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__Container_t_t", "IMP::Containers *|IMP::Vector< IMP::Pointer< IMP::Container > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__ModelObject_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__ModelObject_t_t", "IMP::ModelObjects *|IMP::Vector< IMP::Pointer< IMP::ModelObject > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__Model_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__Model_t_t", "IMP::Models *|IMP::Vector< IMP::Pointer< IMP::Model > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__Object_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__Object_t_t", "IMP::Objects *|IMP::Vector< IMP::Pointer< IMP::Object > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__OptimizerState_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__OptimizerState_t_t", "IMP::OptimizerStates *|IMP::Vector< IMP::Pointer< IMP::OptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__Optimizer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__Optimizer_t_t", "IMP::Optimizers *|IMP::Vector< IMP::Pointer< IMP::Optimizer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__PairContainer_t_t", "IMP::PairContainers *|IMP::Vector< IMP::Pointer< IMP::PairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairModifier_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__PairModifier_t_t", "IMP::PairModifiers *|IMP::Vector< IMP::Pointer< IMP::PairModifier > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairPredicate_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__PairPredicate_t_t", "IMP::PairPredicates *|IMP::Vector< IMP::Pointer< IMP::PairPredicate > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__PairScore_t_t", "IMP::PairScores *|IMP::Vector< IMP::Pointer< IMP::PairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__QuadContainer_t_t", "IMP::QuadContainers *|IMP::Vector< IMP::Pointer< IMP::QuadContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadModifier_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__QuadModifier_t_t", "IMP::QuadModifiers *|IMP::Vector< IMP::Pointer< IMP::QuadModifier > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadPredicate_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__QuadPredicate_t_t", "IMP::QuadPredicates *|IMP::Vector< IMP::Pointer< IMP::QuadPredicate > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__QuadScore_t_t", "IMP::QuadScores *|IMP::Vector< IMP::Pointer< IMP::QuadScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__Refiner_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__Refiner_t_t", "IMP::Refiners *|IMP::Vector< IMP::Pointer< IMP::Refiner > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__RestraintSet_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__RestraintSet_t_t", "IMP::RestraintSets *|IMP::Vector< IMP::Pointer< IMP::RestraintSet > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__Restraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__Restraint_t_t", "IMP::Restraints *|IMP::Vector< IMP::Pointer< IMP::Restraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__Sampler_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__Sampler_t_t", "IMP::Samplers *|IMP::Vector< IMP::Pointer< IMP::Sampler > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__ScoreState_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__ScoreState_t_t", "IMP::ScoreStates *|IMP::Vector< IMP::Pointer< IMP::ScoreState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__ScoringFunction_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__ScoringFunction_t_t", "IMP::ScoringFunctions *|IMP::Vector< IMP::Pointer< IMP::ScoringFunction > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__SingletonContainer_t_t", "IMP::SingletonContainers *|IMP::Vector< IMP::Pointer< IMP::SingletonContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonModifier_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__SingletonModifier_t_t", "IMP::SingletonModifiers *|IMP::Vector< IMP::Pointer< IMP::SingletonModifier > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonPredicate_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__SingletonPredicate_t_t", "IMP::SingletonPredicates *|IMP::Vector< IMP::Pointer< IMP::SingletonPredicate > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__SingletonScore_t_t", "IMP::SingletonScores *|IMP::Vector< IMP::Pointer< IMP::SingletonScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__TripletContainer_t_t", "IMP::TripletContainers *|IMP::Vector< IMP::Pointer< IMP::TripletContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletModifier_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__TripletModifier_t_t", "IMP::TripletModifiers *|IMP::Vector< IMP::Pointer< IMP::TripletModifier > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletPredicate_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__TripletPredicate_t_t", "IMP::TripletPredicates *|IMP::Vector< IMP::Pointer< IMP::TripletPredicate > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__TripletScore_t_t", "IMP::TripletScores *|IMP::Vector< IMP::Pointer< IMP::TripletScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__UnaryFunction_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__UnaryFunction_t_t", "IMP::UnaryFunctions *|IMP::Vector< IMP::Pointer< IMP::UnaryFunction > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__Undecorator_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__Undecorator_t_t", "IMP::Undecorators *|IMP::Vector< IMP::Pointer< IMP::Undecorator > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__algebra__VectorKDMetric_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__algebra__VectorKDMetric_t_t", "IMP::algebra::VectorKDMetrics *|IMP::Vector< IMP::Pointer< IMP::algebra::VectorKDMetric > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__AllBipartitePairContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__AllBipartitePairContainer_t_t", "IMP::container::AllBipartitePairContainers *|IMP::Vector< IMP::Pointer< IMP::container::AllBipartitePairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__AllPairContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__AllPairContainer_t_t", "IMP::container::AllPairContainers *|IMP::Vector< IMP::Pointer< IMP::container::AllPairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ClosePairContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__ClosePairContainer_t_t", "IMP::container::ClosePairContainers *|IMP::Vector< IMP::Pointer< IMP::container::ClosePairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ConnectingPairContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__ConnectingPairContainer_t_t", "IMP::container::ConnectingPairContainers *|IMP::Vector< IMP::Pointer< IMP::container::ConnectingPairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ConsecutivePairContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__ConsecutivePairContainer_t_t", "IMP::container::ConsecutivePairContainers *|IMP::Vector< IMP::Pointer< IMP::container::ConsecutivePairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListPairContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListPairContainer_t_t", "IMP::container::DynamicListPairContainers *|IMP::Vector< IMP::Pointer< IMP::container::DynamicListPairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListQuadContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListQuadContainer_t_t", "IMP::container::DynamicListQuadContainers *|IMP::Vector< IMP::Pointer< IMP::container::DynamicListQuadContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListSingletonContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListSingletonContainer_t_t", "IMP::container::DynamicListSingletonContainers *|IMP::Vector< IMP::Pointer< IMP::container::DynamicListSingletonContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListTripletContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListTripletContainer_t_t", "IMP::container::DynamicListTripletContainers *|IMP::Vector< IMP::Pointer< IMP::container::DynamicListTripletContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerPairFilter_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerPairFilter_t_t", "IMP::container::InContainerPairFilters *|IMP::Vector< IMP::Pointer< IMP::container::InContainerPairFilter > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerQuadFilter_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerQuadFilter_t_t", "IMP::container::InContainerQuadFilters *|IMP::Vector< IMP::Pointer< IMP::container::InContainerQuadFilter > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerSingletonFilter_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerSingletonFilter_t_t", "IMP::container::InContainerSingletonFilters *|IMP::Vector< IMP::Pointer< IMP::container::InContainerSingletonFilter > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerTripletFilter_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerTripletFilter_t_t", "IMP::container::InContainerTripletFilters *|IMP::Vector< IMP::Pointer< IMP::container::InContainerTripletFilter > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListPairContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__ListPairContainer_t_t", "IMP::container::ListPairContainers *|IMP::Vector< IMP::Pointer< IMP::container::ListPairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListQuadContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__ListQuadContainer_t_t", "IMP::container::ListQuadContainers *|IMP::Vector< IMP::Pointer< IMP::container::ListQuadContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListSingletonContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__ListSingletonContainer_t_t", "IMP::container::ListSingletonContainers *|IMP::Vector< IMP::Pointer< IMP::container::ListSingletonContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListTripletContainer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__ListTripletContainer_t_t", "IMP::container::ListTripletContainers *|IMP::Vector< IMP::Pointer< IMP::container::ListTripletContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumPairScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumPairScore_t_t", "IMP::container::MinimumPairScores *|IMP::Vector< IMP::Pointer< IMP::container::MinimumPairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumQuadScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumQuadScore_t_t", "IMP::container::MinimumQuadScores *|IMP::Vector< IMP::Pointer< IMP::container::MinimumQuadScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumSingletonScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumSingletonScore_t_t", "IMP::container::MinimumSingletonScores *|IMP::Vector< IMP::Pointer< IMP::container::MinimumSingletonScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumTripletScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumTripletScore_t_t", "IMP::container::MinimumTripletScores *|IMP::Vector< IMP::Pointer< IMP::container::MinimumTripletScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsConstraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__PairsConstraint_t_t", "IMP::container::PairsConstraints *|IMP::Vector< IMP::Pointer< IMP::container::PairsConstraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsOptimizerState_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__PairsOptimizerState_t_t", "IMP::container::PairsOptimizerStates *|IMP::Vector< IMP::Pointer< IMP::container::PairsOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsRestraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__PairsRestraint_t_t", "IMP::container::PairsRestraints *|IMP::Vector< IMP::Pointer< IMP::container::PairsRestraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsConstraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsConstraint_t_t", "IMP::container::QuadsConstraints *|IMP::Vector< IMP::Pointer< IMP::container::QuadsConstraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsOptimizerState_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsOptimizerState_t_t", "IMP::container::QuadsOptimizerStates *|IMP::Vector< IMP::Pointer< IMP::container::QuadsOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsRestraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsRestraint_t_t", "IMP::container::QuadsRestraints *|IMP::Vector< IMP::Pointer< IMP::container::QuadsRestraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsConstraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsConstraint_t_t", "IMP::container::SingletonsConstraints *|IMP::Vector< IMP::Pointer< IMP::container::SingletonsConstraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsOptimizerState_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsOptimizerState_t_t", "IMP::container::SingletonsOptimizerStates *|IMP::Vector< IMP::Pointer< IMP::container::SingletonsOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsRestraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsRestraint_t_t", "IMP::container::SingletonsRestraints *|IMP::Vector< IMP::Pointer< IMP::container::SingletonsRestraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsConstraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsConstraint_t_t", "IMP::container::TripletsConstraints *|IMP::Vector< IMP::Pointer< IMP::container::TripletsConstraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsOptimizerState_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsOptimizerState_t_t", "IMP::container::TripletsOptimizerStates *|IMP::Vector< IMP::Pointer< IMP::container::TripletsOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsRestraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsRestraint_t_t", "IMP::container::TripletsRestraints *|IMP::Vector< IMP::Pointer< IMP::container::TripletsRestraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__DistancePairScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__core__DistancePairScore_t_t", "IMP::core::DistancePairScores *|IMP::Vector< IMP::Pointer< IMP::core::DistancePairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicDistancePairScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicDistancePairScore_t_t", "IMP::core::HarmonicDistancePairScores *|IMP::Vector< IMP::Pointer< IMP::core::HarmonicDistancePairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t", "IMP::core::HarmonicUpperBoundSphereDiameterPairScores *|IMP::Vector< IMP::Pointer< IMP::core::HarmonicUpperBoundSphereDiameterPairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicWell_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicWell_t_t", "IMP::core::HarmonicWells *|IMP::Vector< IMP::Pointer< IMP::core::HarmonicWell > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__MonteCarloMover_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__core__MonteCarloMover_t_t", "IMP::core::MonteCarloMovers *|IMP::Vector< IMP::Pointer< IMP::core::MonteCarloMover > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometryConstraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometryConstraint_t_t", "IMP::core::SurfaceGeometryConstraints *|IMP::Vector< IMP::Pointer< IMP::core::SurfaceGeometryConstraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometry_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometry_t_t", "IMP::core::SurfaceGeometries *|IMP::Vector< IMP::Pointer< IMP::core::SurfaceGeometry > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__display__Geometry_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__display__Geometry_t_t", "IMP::display::Geometries *|IMP::Vector< IMP::Pointer< IMP::display::Geometry > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__display__TextWriter_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__display__TextWriter_t_t", "IMP::display::TextWriters *|IMP::Vector< IMP::Pointer< IMP::display::TextWriter > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__display__Writer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__display__Writer_t_t", "IMP::display::Writers *|IMP::Vector< IMP::Pointer< IMP::display::Writer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t", "IMP::insulinsecretion::CaChannelOpeningOptimizerStates *|IMP::Vector< IMP::Pointer< IMP::insulinsecretion::CaChannelOpeningOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t", "IMP::insulinsecretion::InsulinSecretionOptimizerStates *|IMP::Vector< IMP::Pointer< IMP::insulinsecretion::InsulinSecretionOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t", "IMP::insulinsecretion::VesicleDockingOptimizerStates *|IMP::Vector< IMP::Pointer< IMP::insulinsecretion::VesicleDockingOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstOptimizer_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstOptimizer_t_t", "IMP::internal::_ConstOptimizers *|IMP::Vector< IMP::Pointer< IMP::internal::_ConstOptimizer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstPairScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstPairScore_t_t", "IMP::internal::_ConstPairScores *|IMP::Vector< IMP::Pointer< IMP::internal::_ConstPairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstRestraint_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstRestraint_t_t", "IMP::internal::_ConstRestraints *|IMP::Vector< IMP::Pointer< IMP::internal::_ConstRestraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstSingletonScore_t_t = {"_p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstSingletonScore_t_t", "IMP::internal::_ConstSingletonScores *|IMP::Vector< IMP::Pointer< IMP::internal::_ConstSingletonScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__ScoreAccumulator_t = {"_p_IMP__VectorT_IMP__ScoreAccumulator_t", "IMP::ScoreAccumulators *|IMP::Vector< IMP::ScoreAccumulator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__SetCheckState_t = {"_p_IMP__VectorT_IMP__SetCheckState_t", "IMP::SetCheckStates *|IMP::Vector< IMP::SetCheckState > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__SetLogState_t = {"_p_IMP__VectorT_IMP__SetLogState_t", "IMP::SetLogStates *|IMP::Vector< IMP::SetLogState > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__TextInput_t = {"_p_IMP__VectorT_IMP__TextInput_t", "IMP::TextInputs *|IMP::Vector< IMP::TextInput > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__TextOutput_t = {"_p_IMP__VectorT_IMP__TextOutput_t", "IMP::TextOutputs *|IMP::Vector< IMP::TextOutput > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_double_t_t_t = {"_p_IMP__VectorT_IMP__VectorT_IMP__VectorT_double_t_t_t", "IMP::FloatsLists *|IMP::Vector< IMP::Vector< IMP::Vector< double > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_int_t_t_t = {"_p_IMP__VectorT_IMP__VectorT_IMP__VectorT_int_t_t_t", "IMP::IntsLists *|IMP::Vector< IMP::Vector< IMP::Vector< int > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_std__string_t_t_t = {"_p_IMP__VectorT_IMP__VectorT_IMP__VectorT_std__string_t_t_t", "IMP::StringsLists *|IMP::Vector< IMP::Vector< IMP::Vector< std::string > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t_t = {"_p_IMP__VectorT_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t_t", "IMP::ModelObjectsTemps *|IMP::Vector< IMP::Vector< IMP::WeakPointer< IMP::ModelObject > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VectorT_WeakPointerT_IMP__Particle_t_t_t = {"_p_IMP__VectorT_IMP__VectorT_WeakPointerT_IMP__Particle_t_t_t", "IMP::ParticlesTemps *|IMP::Vector< IMP::Vector< WeakPointer< IMP::Particle > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VectorT_double_t_t = {"_p_IMP__VectorT_IMP__VectorT_double_t_t", "IMP::FloatsList *|IMP::Floatss *|IMP::Vector< IMP::Vector< double > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VectorT_int_t_t = {"_p_IMP__VectorT_IMP__VectorT_int_t_t", "IMP::IntsList *|IMP::Intss *|IMP::Vector< IMP::Vector< int > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VectorT_std__pairT_double_double_t_t_t = {"_p_IMP__VectorT_IMP__VectorT_std__pairT_double_double_t_t_t", "IMP::DerivativePairss *|IMP::FloatPairss *|IMP::FloatRangess *|IMP::Vector< IMP::Vector< std::pair< double,double > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VectorT_std__pairT_int_int_t_t_t = {"_p_IMP__VectorT_IMP__VectorT_std__pairT_int_int_t_t_t", "IMP::IntPairss *|IMP::IntRangess *|IMP::Vector< IMP::Vector< std::pair< int,int > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VectorT_std__string_t_t = {"_p_IMP__VectorT_IMP__VectorT_std__string_t_t", "IMP::StringsList *|IMP::Stringss *|IMP::Vector< IMP::Vector< std::string > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__VersionInfo_t = {"_p_IMP__VectorT_IMP__VersionInfo_t", "IMP::VersionInfos *|IMP::Vector< IMP::VersionInfo > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__AttributeOptimizer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__AttributeOptimizer_t_t", "IMP::AttributeOptimizersTemp *|IMP::Vector< IMP::WeakPointer< IMP::AttributeOptimizer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ConfigurationSet_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__ConfigurationSet_t_t", "IMP::ConfigurationSetsTemp *|IMP::Vector< IMP::WeakPointer< IMP::ConfigurationSet > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Configuration_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__Configuration_t_t", "IMP::ConfigurationsTemp *|IMP::Vector< IMP::WeakPointer< IMP::Configuration > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Constraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__Constraint_t_t", "IMP::ConstraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::Constraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Container_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__Container_t_t", "IMP::ContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::Container > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t", "IMP::ModelObjectsTemp *|IMP::Vector< IMP::WeakPointer< IMP::ModelObject > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Model_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__Model_t_t", "IMP::ModelsTemp *|IMP::Vector< IMP::WeakPointer< IMP::Model > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Object_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__Object_t_t", "IMP::ObjectsTemp *|IMP::Vector< IMP::WeakPointer< IMP::Object > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__OptimizerState_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__OptimizerState_t_t", "IMP::OptimizerStatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::OptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Optimizer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__Optimizer_t_t", "IMP::OptimizersTemp *|IMP::Vector< IMP::WeakPointer< IMP::Optimizer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__PairContainer_t_t", "IMP::PairContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::PairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairModifier_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__PairModifier_t_t", "IMP::PairModifiersTemp *|IMP::Vector< IMP::WeakPointer< IMP::PairModifier > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairPredicate_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__PairPredicate_t_t", "IMP::PairPredicatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::PairPredicate > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__PairScore_t_t", "IMP::PairScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::PairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadContainer_t_t", "IMP::QuadContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::QuadContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadModifier_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadModifier_t_t", "IMP::QuadModifiersTemp *|IMP::Vector< IMP::WeakPointer< IMP::QuadModifier > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadPredicate_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadPredicate_t_t", "IMP::QuadPredicatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::QuadPredicate > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadScore_t_t", "IMP::QuadScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::QuadScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Refiner_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__Refiner_t_t", "IMP::RefinersTemp *|IMP::Vector< IMP::WeakPointer< IMP::Refiner > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__RestraintSet_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__RestraintSet_t_t", "IMP::RestraintSetsTemp *|IMP::Vector< IMP::WeakPointer< IMP::RestraintSet > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Restraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__Restraint_t_t", "IMP::RestraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::Restraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Sampler_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__Sampler_t_t", "IMP::SamplersTemp *|IMP::Vector< IMP::WeakPointer< IMP::Sampler > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoreState_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoreState_t_t", "IMP::ScoreStatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::ScoreState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoringFunction_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoringFunction_t_t", "IMP::ScoringFunctionsTemp *|IMP::Vector< IMP::WeakPointer< IMP::ScoringFunction > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonContainer_t_t", "IMP::SingletonContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::SingletonContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonModifier_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonModifier_t_t", "IMP::SingletonModifiersTemp *|IMP::Vector< IMP::WeakPointer< IMP::SingletonModifier > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonPredicate_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonPredicate_t_t", "IMP::SingletonPredicatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::SingletonPredicate > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonScore_t_t", "IMP::SingletonScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::SingletonScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletContainer_t_t", "IMP::TripletContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::TripletContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletModifier_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletModifier_t_t", "IMP::TripletModifiersTemp *|IMP::Vector< IMP::WeakPointer< IMP::TripletModifier > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletPredicate_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletPredicate_t_t", "IMP::TripletPredicatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::TripletPredicate > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletScore_t_t", "IMP::TripletScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::TripletScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__UnaryFunction_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__UnaryFunction_t_t", "IMP::UnaryFunctionsTemp *|IMP::Vector< IMP::WeakPointer< IMP::UnaryFunction > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Undecorator_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__Undecorator_t_t", "IMP::UndecoratorsTemp *|IMP::Vector< IMP::WeakPointer< IMP::Undecorator > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__algebra__VectorKDMetric_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__algebra__VectorKDMetric_t_t", "IMP::algebra::VectorKDMetricsTemp *|IMP::Vector< IMP::WeakPointer< IMP::algebra::VectorKDMetric > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllBipartitePairContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllBipartitePairContainer_t_t", "IMP::container::AllBipartitePairContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::AllBipartitePairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllPairContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllPairContainer_t_t", "IMP::container::AllPairContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::AllPairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ClosePairContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ClosePairContainer_t_t", "IMP::container::ClosePairContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::ClosePairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConnectingPairContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConnectingPairContainer_t_t", "IMP::container::ConnectingPairContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::ConnectingPairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConsecutivePairContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConsecutivePairContainer_t_t", "IMP::container::ConsecutivePairContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::ConsecutivePairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListPairContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListPairContainer_t_t", "IMP::container::DynamicListPairContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::DynamicListPairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListQuadContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListQuadContainer_t_t", "IMP::container::DynamicListQuadContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::DynamicListQuadContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListSingletonContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListSingletonContainer_t_t", "IMP::container::DynamicListSingletonContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::DynamicListSingletonContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListTripletContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListTripletContainer_t_t", "IMP::container::DynamicListTripletContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::DynamicListTripletContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerPairFilter_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerPairFilter_t_t", "IMP::container::InContainerPairFiltersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::InContainerPairFilter > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerQuadFilter_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerQuadFilter_t_t", "IMP::container::InContainerQuadFiltersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::InContainerQuadFilter > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerSingletonFilter_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerSingletonFilter_t_t", "IMP::container::InContainerSingletonFiltersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::InContainerSingletonFilter > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerTripletFilter_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerTripletFilter_t_t", "IMP::container::InContainerTripletFiltersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::InContainerTripletFilter > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListPairContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListPairContainer_t_t", "IMP::container::ListPairContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::ListPairContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListQuadContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListQuadContainer_t_t", "IMP::container::ListQuadContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::ListQuadContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListSingletonContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListSingletonContainer_t_t", "IMP::container::ListSingletonContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::ListSingletonContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListTripletContainer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListTripletContainer_t_t", "IMP::container::ListTripletContainersTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::ListTripletContainer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumPairScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumPairScore_t_t", "IMP::container::MinimumPairScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::MinimumPairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumQuadScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumQuadScore_t_t", "IMP::container::MinimumQuadScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::MinimumQuadScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumSingletonScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumSingletonScore_t_t", "IMP::container::MinimumSingletonScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::MinimumSingletonScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumTripletScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumTripletScore_t_t", "IMP::container::MinimumTripletScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::MinimumTripletScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsConstraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsConstraint_t_t", "IMP::container::PairsConstraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::PairsConstraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsOptimizerState_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsOptimizerState_t_t", "IMP::container::PairsOptimizerStatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::PairsOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsRestraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsRestraint_t_t", "IMP::container::PairsRestraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::PairsRestraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsConstraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsConstraint_t_t", "IMP::container::QuadsConstraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::QuadsConstraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsOptimizerState_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsOptimizerState_t_t", "IMP::container::QuadsOptimizerStatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::QuadsOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsRestraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsRestraint_t_t", "IMP::container::QuadsRestraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::QuadsRestraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsConstraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsConstraint_t_t", "IMP::container::SingletonsConstraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::SingletonsConstraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsOptimizerState_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsOptimizerState_t_t", "IMP::container::SingletonsOptimizerStatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::SingletonsOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsRestraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsRestraint_t_t", "IMP::container::SingletonsRestraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::SingletonsRestraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsConstraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsConstraint_t_t", "IMP::container::TripletsConstraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::TripletsConstraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsOptimizerState_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsOptimizerState_t_t", "IMP::container::TripletsOptimizerStatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::TripletsOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsRestraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsRestraint_t_t", "IMP::container::TripletsRestraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::container::TripletsRestraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__DistancePairScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__DistancePairScore_t_t", "IMP::core::DistancePairScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::core::DistancePairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicDistancePairScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicDistancePairScore_t_t", "IMP::core::HarmonicDistancePairScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::core::HarmonicDistancePairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t", "IMP::core::HarmonicUpperBoundSphereDiameterPairScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::core::HarmonicUpperBoundSphereDiameterPairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicWell_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicWell_t_t", "IMP::core::HarmonicWellsTemp *|IMP::Vector< IMP::WeakPointer< IMP::core::HarmonicWell > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__MonteCarloMover_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__MonteCarloMover_t_t", "IMP::core::MonteCarloMoversTemp *|IMP::Vector< IMP::WeakPointer< IMP::core::MonteCarloMover > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometryConstraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometryConstraint_t_t", "IMP::core::SurfaceGeometryConstraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::core::SurfaceGeometryConstraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometry_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometry_t_t", "IMP::core::SurfaceGeometriesTemp *|IMP::Vector< IMP::WeakPointer< IMP::core::SurfaceGeometry > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Geometry_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Geometry_t_t", "IMP::display::GeometriesTemp *|IMP::Vector< IMP::WeakPointer< IMP::display::Geometry > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__TextWriter_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__display__TextWriter_t_t", "IMP::display::TextWritersTemp *|IMP::Vector< IMP::WeakPointer< IMP::display::TextWriter > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Writer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Writer_t_t", "IMP::display::WritersTemp *|IMP::Vector< IMP::WeakPointer< IMP::display::Writer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t", "IMP::insulinsecretion::CaChannelOpeningOptimizerStatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::insulinsecretion::CaChannelOpeningOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t", "IMP::insulinsecretion::InsulinSecretionOptimizerStatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::insulinsecretion::InsulinSecretionOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t", "IMP::insulinsecretion::VesicleDockingOptimizerStatesTemp *|IMP::Vector< IMP::WeakPointer< IMP::insulinsecretion::VesicleDockingOptimizerState > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstOptimizer_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstOptimizer_t_t", "IMP::internal::_ConstOptimizersTemp *|IMP::Vector< IMP::WeakPointer< IMP::internal::_ConstOptimizer > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstPairScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstPairScore_t_t", "IMP::internal::_ConstPairScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::internal::_ConstPairScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstRestraint_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstRestraint_t_t", "IMP::internal::_ConstRestraintsTemp *|IMP::Vector< IMP::WeakPointer< IMP::internal::_ConstRestraint > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstSingletonScore_t_t = {"_p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstSingletonScore_t_t", "IMP::internal::_ConstSingletonScoresTemp *|IMP::Vector< IMP::WeakPointer< IMP::internal::_ConstSingletonScore > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_1_t_t", "IMP::algebra::BoundedGridRange1Ds *|IMP::Vector< IMP::algebra::BoundedGridRangeD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_2_t_t", "IMP::algebra::BoundedGridRange2Ds *|IMP::Vector< IMP::algebra::BoundedGridRangeD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_3_t_t", "IMP::algebra::BoundedGridRange3Ds *|IMP::Vector< IMP::algebra::BoundedGridRangeD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_4_t_t", "IMP::algebra::BoundedGridRange4Ds *|IMP::Vector< IMP::algebra::BoundedGridRangeD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_5_t_t", "IMP::algebra::BoundedGridRange5Ds *|IMP::Vector< IMP::algebra::BoundedGridRangeD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_6_t_t", "IMP::algebra::BoundedGridRange6Ds *|IMP::Vector< IMP::algebra::BoundedGridRangeD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT__1_t_t", "IMP::algebra::BoundedGridRangeKDs *|IMP::Vector< IMP::algebra::BoundedGridRangeD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_1_t_t", "IMP::algebra::BoundingBox1Ds *|IMP::Vector< IMP::algebra::BoundingBoxD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_2_t_t", "IMP::algebra::BoundingBox2Ds *|IMP::Vector< IMP::algebra::BoundingBoxD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_3_t_t", "IMP::algebra::BoundingBox3Ds *|IMP::Vector< IMP::algebra::BoundingBoxD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_4_t_t", "IMP::algebra::BoundingBox4Ds *|IMP::Vector< IMP::algebra::BoundingBoxD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_5_t_t", "IMP::algebra::BoundingBox5Ds *|IMP::Vector< IMP::algebra::BoundingBoxD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundingBoxDT_6_t_t", "IMP::algebra::BoundingBox6Ds *|IMP::Vector< IMP::algebra::BoundingBoxD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__BoundingBoxDT__1_t_t", "IMP::algebra::BoundingBoxKDs *|IMP::Vector< IMP::algebra::BoundingBoxD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Cone3D_t = {"_p_IMP__VectorT_IMP__algebra__Cone3D_t", "IMP::algebra::Cone3Ds *|IMP::Vector< IMP::algebra::Cone3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__ConnollySurfacePoint_t = {"_p_IMP__VectorT_IMP__algebra__ConnollySurfacePoint_t", "IMP::algebra::ConnollySurfacePoints *|IMP::Vector< IMP::algebra::ConnollySurfacePoint > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Cylinder3D_t = {"_p_IMP__VectorT_IMP__algebra__Cylinder3D_t", "IMP::algebra::Cylinder3Ds *|IMP::Vector< IMP::algebra::Cylinder3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_1_t_t", "IMP::algebra::DefaultEmbedding1Ds *|IMP::Vector< IMP::algebra::DefaultEmbeddingD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_2_t_t", "IMP::algebra::DefaultEmbedding2Ds *|IMP::Vector< IMP::algebra::DefaultEmbeddingD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_3_t_t", "IMP::algebra::DefaultEmbedding3Ds *|IMP::Vector< IMP::algebra::DefaultEmbeddingD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_4_t_t", "IMP::algebra::DefaultEmbedding4Ds *|IMP::Vector< IMP::algebra::DefaultEmbeddingD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_5_t_t", "IMP::algebra::DefaultEmbedding5Ds *|IMP::Vector< IMP::algebra::DefaultEmbeddingD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_6_t_t", "IMP::algebra::DefaultEmbedding6Ds *|IMP::Vector< IMP::algebra::DefaultEmbeddingD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT__1_t_t", "IMP::algebra::DefaultEmbeddingKDs *|IMP::Vector< IMP::algebra::DefaultEmbeddingD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Ellipsoid3D_t = {"_p_IMP__VectorT_IMP__algebra__Ellipsoid3D_t", "IMP::algebra::Ellipsoid3Ds *|IMP::Vector< IMP::algebra::Ellipsoid3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_1_t_t", "IMP::algebra::ExtendedGridIndex1Ds *|IMP::Vector< IMP::algebra::ExtendedGridIndexD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_2_t_t", "IMP::algebra::ExtendedGridIndex2Ds *|IMP::Vector< IMP::algebra::ExtendedGridIndexD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_3_t_t", "IMP::algebra::ExtendedGridIndex3Ds *|IMP::Vector< IMP::algebra::ExtendedGridIndexD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_4_t_t", "IMP::algebra::ExtendedGridIndex4Ds *|IMP::Vector< IMP::algebra::ExtendedGridIndexD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_5_t_t", "IMP::algebra::ExtendedGridIndex5Ds *|IMP::Vector< IMP::algebra::ExtendedGridIndexD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_6_t_t", "IMP::algebra::ExtendedGridIndex6Ds *|IMP::Vector< IMP::algebra::ExtendedGridIndexD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT__1_t_t", "IMP::algebra::ExtendedGridIndexKDs *|IMP::Vector< IMP::algebra::ExtendedGridIndexD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__FixedXYZ_t = {"_p_IMP__VectorT_IMP__algebra__FixedXYZ_t", "IMP::algebra::FixedXYZs *|IMP::Vector< IMP::algebra::FixedXYZ > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Gaussian3D_t = {"_p_IMP__VectorT_IMP__algebra__Gaussian3D_t", "IMP::algebra::Gaussian3Ds *|IMP::Vector< IMP::algebra::Gaussian3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__GridIndexDT_1_t_t", "IMP::algebra::GridIndex1Ds *|IMP::Vector< IMP::algebra::GridIndexD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__GridIndexDT_2_t_t", "IMP::algebra::GridIndex2Ds *|IMP::Vector< IMP::algebra::GridIndexD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__GridIndexDT_3_t_t", "IMP::algebra::GridIndex3Ds *|IMP::Vector< IMP::algebra::GridIndexD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__GridIndexDT_4_t_t", "IMP::algebra::GridIndex4Ds *|IMP::Vector< IMP::algebra::GridIndexD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__GridIndexDT_5_t_t", "IMP::algebra::GridIndex5Ds *|IMP::Vector< IMP::algebra::GridIndexD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__GridIndexDT_6_t_t", "IMP::algebra::GridIndex6Ds *|IMP::Vector< IMP::algebra::GridIndexD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__GridIndexDT__1_t_t", "IMP::algebra::GridIndexKDs *|IMP::Vector< IMP::algebra::GridIndexD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Line3D_t = {"_p_IMP__VectorT_IMP__algebra__Line3D_t", "IMP::algebra::Line3Ds *|IMP::Vector< IMP::algebra::Line3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__LinearFit2D_t = {"_p_IMP__VectorT_IMP__algebra__LinearFit2D_t", "IMP::algebra::LinearFit2Ds *|IMP::Vector< IMP::algebra::LinearFit2D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_1_t_t", "IMP::algebra::LogEmbedding1Ds *|IMP::Vector< IMP::algebra::LogEmbeddingD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_2_t_t", "IMP::algebra::LogEmbedding2Ds *|IMP::Vector< IMP::algebra::LogEmbeddingD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_3_t_t", "IMP::algebra::LogEmbedding3Ds *|IMP::Vector< IMP::algebra::LogEmbeddingD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_4_t_t", "IMP::algebra::LogEmbedding4Ds *|IMP::Vector< IMP::algebra::LogEmbeddingD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_5_t_t", "IMP::algebra::LogEmbedding5Ds *|IMP::Vector< IMP::algebra::LogEmbeddingD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_6_t_t", "IMP::algebra::LogEmbedding6Ds *|IMP::Vector< IMP::algebra::LogEmbeddingD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__LogEmbeddingDT__1_t_t", "IMP::algebra::LogEmbeddingKDs *|IMP::Vector< IMP::algebra::LogEmbeddingD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__ParabolicFit2D_t = {"_p_IMP__VectorT_IMP__algebra__ParabolicFit2D_t", "IMP::algebra::ParabolicFit2Ds *|IMP::Vector< IMP::algebra::ParabolicFit2D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Plane3D_t = {"_p_IMP__VectorT_IMP__algebra__Plane3D_t", "IMP::algebra::Plane3Ds *|IMP::Vector< IMP::algebra::Plane3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_1_t_t", "IMP::algebra::PrincipalComponentAnalysis1Ds *|IMP::Vector< IMP::algebra::PrincipalComponentAnalysisD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_2_t_t", "IMP::algebra::PrincipalComponentAnalysis2Ds *|IMP::Vector< IMP::algebra::PrincipalComponentAnalysisD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_3_t_t", "IMP::algebra::PrincipalComponentAnalysis3Ds *|IMP::Vector< IMP::algebra::PrincipalComponentAnalysisD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_4_t_t", "IMP::algebra::PrincipalComponentAnalysis4Ds *|IMP::Vector< IMP::algebra::PrincipalComponentAnalysisD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_5_t_t", "IMP::algebra::PrincipalComponentAnalysis5Ds *|IMP::Vector< IMP::algebra::PrincipalComponentAnalysisD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_6_t_t", "IMP::algebra::PrincipalComponentAnalysis6Ds *|IMP::Vector< IMP::algebra::PrincipalComponentAnalysisD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT__1_t_t", "IMP::algebra::PrincipalComponentAnalysisKDs *|IMP::Vector< IMP::algebra::PrincipalComponentAnalysisD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__ReferenceFrame3D_t = {"_p_IMP__VectorT_IMP__algebra__ReferenceFrame3D_t", "IMP::algebra::ReferenceFrame3Ds *|IMP::Vector< IMP::algebra::ReferenceFrame3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Reflection3D_t = {"_p_IMP__VectorT_IMP__algebra__Reflection3D_t", "IMP::algebra::Reflection3Ds *|IMP::Vector< IMP::algebra::Reflection3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Rotation2D_t = {"_p_IMP__VectorT_IMP__algebra__Rotation2D_t", "IMP::algebra::Rotation2Ds *|IMP::Vector< IMP::algebra::Rotation2D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Rotation3D_t = {"_p_IMP__VectorT_IMP__algebra__Rotation3D_t", "IMP::algebra::Rotation3Ds *|IMP::Vector< IMP::algebra::Rotation3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Segment3D_t = {"_p_IMP__VectorT_IMP__algebra__Segment3D_t", "IMP::algebra::Segment3Ds *|IMP::Vector< IMP::algebra::Segment3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__SphereDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__SphereDT_1_t_t", "IMP::algebra::Sphere1Ds *|IMP::Vector< IMP::algebra::SphereD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__SphereDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__SphereDT_2_t_t", "IMP::algebra::Sphere2Ds *|IMP::Vector< IMP::algebra::SphereD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__SphereDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__SphereDT_3_t_t", "IMP::algebra::Sphere3Ds *|IMP::Vector< IMP::algebra::SphereD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__SphereDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__SphereDT_4_t_t", "IMP::algebra::Sphere4Ds *|IMP::Vector< IMP::algebra::SphereD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__SphereDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__SphereDT_5_t_t", "IMP::algebra::Sphere5Ds *|IMP::Vector< IMP::algebra::SphereD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__SphereDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__SphereDT_6_t_t", "IMP::algebra::Sphere6Ds *|IMP::Vector< IMP::algebra::SphereD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__SphereDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__SphereDT__1_t_t", "IMP::algebra::SphereKDs *|IMP::Vector< IMP::algebra::SphereD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__SpherePatch3D_t = {"_p_IMP__VectorT_IMP__algebra__SpherePatch3D_t", "IMP::algebra::SpherePatch3Ds *|IMP::Vector< IMP::algebra::SpherePatch3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__SphericalVector3D_t = {"_p_IMP__VectorT_IMP__algebra__SphericalVector3D_t", "IMP::algebra::SphericalVector3Ds *|IMP::Vector< IMP::algebra::SphericalVector3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Transformation2D_t = {"_p_IMP__VectorT_IMP__algebra__Transformation2D_t", "IMP::algebra::Transformation2Ds *|IMP::Vector< IMP::algebra::Transformation2D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Transformation3D_t = {"_p_IMP__VectorT_IMP__algebra__Transformation3D_t", "IMP::algebra::Transformation3Ds *|IMP::Vector< IMP::algebra::Transformation3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__Triangle3D_t = {"_p_IMP__VectorT_IMP__algebra__Triangle3D_t", "IMP::algebra::Triangle3Ds *|IMP::Vector< IMP::algebra::Triangle3D > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_1_t_t", "IMP::algebra::UnboundedGridRange1Ds *|IMP::Vector< IMP::algebra::UnboundedGridRangeD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_2_t_t", "IMP::algebra::UnboundedGridRange2Ds *|IMP::Vector< IMP::algebra::UnboundedGridRangeD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_3_t_t", "IMP::algebra::UnboundedGridRange3Ds *|IMP::Vector< IMP::algebra::UnboundedGridRangeD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_4_t_t", "IMP::algebra::UnboundedGridRange4Ds *|IMP::Vector< IMP::algebra::UnboundedGridRangeD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_5_t_t", "IMP::algebra::UnboundedGridRange5Ds *|IMP::Vector< IMP::algebra::UnboundedGridRangeD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_6_t_t", "IMP::algebra::UnboundedGridRange6Ds *|IMP::Vector< IMP::algebra::UnboundedGridRangeD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT__1_t_t", "IMP::algebra::UnboundedGridRangeKDs *|IMP::Vector< IMP::algebra::UnboundedGridRangeD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_1_t_t", "IMP::algebra::UnitSimplex1Ds *|IMP::Vector< IMP::algebra::UnitSimplexD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_2_t_t", "IMP::algebra::UnitSimplex2Ds *|IMP::Vector< IMP::algebra::UnitSimplexD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_3_t_t", "IMP::algebra::UnitSimplex3Ds *|IMP::Vector< IMP::algebra::UnitSimplexD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_4_t_t", "IMP::algebra::UnitSimplex4Ds *|IMP::Vector< IMP::algebra::UnitSimplexD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_5_t_t", "IMP::algebra::UnitSimplex5Ds *|IMP::Vector< IMP::algebra::UnitSimplexD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__UnitSimplexDT_6_t_t", "IMP::algebra::UnitSimplex6Ds *|IMP::Vector< IMP::algebra::UnitSimplexD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__UnitSimplexDT__1_t_t", "IMP::algebra::UnitSimplexKDs *|IMP::Vector< IMP::algebra::UnitSimplexD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__VectorDT_1_t_t = {"_p_IMP__VectorT_IMP__algebra__VectorDT_1_t_t", "IMP::algebra::Vector1Ds *|IMP::Vector< IMP::algebra::VectorD< 1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__VectorDT_2_t_t = {"_p_IMP__VectorT_IMP__algebra__VectorDT_2_t_t", "IMP::algebra::Vector2Ds *|IMP::Vector< IMP::algebra::VectorD< 2 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__VectorDT_3_t_t = {"_p_IMP__VectorT_IMP__algebra__VectorDT_3_t_t", "IMP::algebra::Vector3Ds *|IMP::Vector< IMP::algebra::VectorD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__VectorDT_4_t_t = {"_p_IMP__VectorT_IMP__algebra__VectorDT_4_t_t", "IMP::algebra::Vector4Ds *|IMP::Vector< IMP::algebra::VectorD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__VectorDT_5_t_t = {"_p_IMP__VectorT_IMP__algebra__VectorDT_5_t_t", "IMP::algebra::Vector5Ds *|IMP::Vector< IMP::algebra::VectorD< 5 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__VectorDT_6_t_t = {"_p_IMP__VectorT_IMP__algebra__VectorDT_6_t_t", "IMP::algebra::Vector6Ds *|IMP::Vector< IMP::algebra::VectorD< 6 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__algebra__VectorDT__1_t_t = {"_p_IMP__VectorT_IMP__algebra__VectorDT__1_t_t", "IMP::algebra::VectorKDs *|IMP::Vector< IMP::algebra::VectorD< -1 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__BinormalTerm_t = {"_p_IMP__VectorT_IMP__core__BinormalTerm_t", "IMP::core::BinormalTermList *|IMP::Vector< IMP::core::BinormalTerm > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__Centroid_t = {"_p_IMP__VectorT_IMP__core__Centroid_t", "IMP::core::Centroids *|IMP::Vector< IMP::core::Centroid > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__Cover_t = {"_p_IMP__VectorT_IMP__core__Cover_t", "IMP::core::Covers *|IMP::Vector< IMP::core::Cover > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__DirectionAngle_t = {"_p_IMP__VectorT_IMP__core__DirectionAngle_t", "IMP::core::DirectionAngles *|IMP::Vector< IMP::core::DirectionAngle > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__Direction_t = {"_p_IMP__VectorT_IMP__core__Direction_t", "IMP::core::Directions *|IMP::Vector< IMP::core::Direction > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__Gaussian_t = {"_p_IMP__VectorT_IMP__core__Gaussian_t", "IMP::core::Gaussians *|IMP::Vector< IMP::core::Gaussian > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__HierarchyCounter_t = {"_p_IMP__VectorT_IMP__core__HierarchyCounter_t", "IMP::core::HierarchyCounters *|IMP::Vector< IMP::core::HierarchyCounter > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__HierarchyTraits_t = {"_p_IMP__VectorT_IMP__core__HierarchyTraits_t", "IMP::core::HierarchyTraitsList *|IMP::Vector< IMP::core::HierarchyTraits > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__Hierarchy_t = {"_p_IMP__VectorT_IMP__core__Hierarchy_t", "IMP::core::GenericHierarchies *|IMP::Vector< IMP::core::Hierarchy > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__MonteCarloMoverResult_t = {"_p_IMP__VectorT_IMP__core__MonteCarloMoverResult_t", "IMP::core::MonteCarloMoverResults *|IMP::Vector< IMP::core::MonteCarloMoverResult > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__Reference_t = {"_p_IMP__VectorT_IMP__core__Reference_t", "IMP::core::References *|IMP::Vector< IMP::core::Reference > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__RigidBodyMember_t = {"_p_IMP__VectorT_IMP__core__RigidBodyMember_t", "IMP::core::RigidBodyMembers *|IMP::Vector< IMP::core::RigidBodyMember > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__RigidBody_t = {"_p_IMP__VectorT_IMP__core__RigidBody_t", "IMP::core::RigidBodies *|IMP::Vector< IMP::core::RigidBody > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__RigidMember_t = {"_p_IMP__VectorT_IMP__core__RigidMember_t", "IMP::core::RigidMembers *|IMP::Vector< IMP::core::RigidMember > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__Surface_t = {"_p_IMP__VectorT_IMP__core__Surface_t", "IMP::core::Surfaces *|IMP::Vector< IMP::core::Surface > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__Typed_t = {"_p_IMP__VectorT_IMP__core__Typed_t", "IMP::core::Typeds *|IMP::Vector< IMP::core::Typed > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__XYZR_t = {"_p_IMP__VectorT_IMP__core__XYZR_t", "IMP::core::XYZRs *|IMP::Vector< IMP::core::XYZR > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__core__XYZ_t = {"_p_IMP__VectorT_IMP__core__XYZ_t", "IMP::core::XYZs *|IMP::Vector< IMP::core::XYZ > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__display__Color_t = {"_p_IMP__VectorT_IMP__display__Color_t", "IMP::display::Colors *|IMP::Vector< IMP::display::Color > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__display__Colored_t = {"_p_IMP__VectorT_IMP__display__Colored_t", "IMP::display::Coloreds *|IMP::Vector< IMP::display::Colored > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__display__GeometryProcessor_t = {"_p_IMP__VectorT_IMP__display__GeometryProcessor_t", "IMP::display::GeometryProcessors *|IMP::Vector< IMP::display::GeometryProcessor > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__display__WriterAdaptor_t = {"_p_IMP__VectorT_IMP__display__WriterAdaptor_t", "IMP::display::WriterAdaptors *|IMP::Vector< IMP::display::WriterAdaptor > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__internal___Protection_t = {"_p_IMP__VectorT_IMP__internal___Protection_t", "IMP::internal::_Protections *|IMP::Vector< IMP::internal::_Protection > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__internal___TestValue_t = {"_p_IMP__VectorT_IMP__internal___TestValue_t", "IMP::internal::_TestValues *|IMP::Vector< IMP::internal::_TestValue > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__internal___TrivialDecorator_t = {"_p_IMP__VectorT_IMP__internal___TrivialDecorator_t", "IMP::internal::_TrivialDecorators *|IMP::Vector< IMP::internal::_TrivialDecorator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__internal___TrivialDerivedDecorator_t = {"_p_IMP__VectorT_IMP__internal___TrivialDerivedDecorator_t", "IMP::internal::_TrivialDerivedDecorators *|IMP::Vector< IMP::internal::_TrivialDerivedDecorator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_IMP__internal___TrivialTraitsDecorator_t = {"_p_IMP__VectorT_IMP__internal___TrivialTraitsDecorator_t", "IMP::internal::_TrivialTraitsDecorators *|IMP::Vector< IMP::internal::_TrivialTraitsDecorator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_PointerT_IMP__Particle_t_t = {"_p_IMP__VectorT_PointerT_IMP__Particle_t_t", "IMP::Particles *|IMP::Vector< Pointer< IMP::Particle > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_WeakPointerT_IMP__Particle_t_t = {"_p_IMP__VectorT_WeakPointerT_IMP__Particle_t_t", "IMP::ParticlesTemp *|IMP::Vector< WeakPointer< IMP::Particle > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_double_t = {"_p_IMP__VectorT_double_t", "IMP::Floats *|IMP::Vector< double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_int_t = {"_p_IMP__VectorT_int_t", "IMP::Ints *|IMP::Vector< int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_std__pairT_IMP__algebra__VectorDT_3_t_double_t_t = {"_p_IMP__VectorT_std__pairT_IMP__algebra__VectorDT_3_t_double_t_t", "IMP::algebra::AxisAnglePairs *|IMP::Vector< std::pair< IMP::algebra::VectorD< 3 >,double > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_std__pairT_double_double_t_t = {"_p_IMP__VectorT_std__pairT_double_double_t_t", "IMP::DerivativePairs *|IMP::FloatPairs *|IMP::FloatRanges *|IMP::Vector< std::pair< double,double > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_std__pairT_int_int_t_t = {"_p_IMP__VectorT_std__pairT_int_int_t_t", "IMP::IntPairs *|IMP::IntRanges *|IMP::Vector< std::pair< int,int > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VectorT_std__string_t = {"_p_IMP__VectorT_std__string_t", "IMP::Strings *|IMP::Vector< std::string > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__VersionInfo = {"_p_IMP__VersionInfo", "::IMP::VersionInfo *|IMP::VersionInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__WarningContext = {"_p_IMP__WarningContext", "IMP::WarningContext *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundedGridRangeDT_1_t = {"_p_IMP__algebra__BoundedGridRangeDT_1_t", "IMP::algebra::BoundedGridRange1D *|IMP::algebra::BoundedGridRangeD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundedGridRangeDT_2_t = {"_p_IMP__algebra__BoundedGridRangeDT_2_t", "IMP::algebra::BoundedGridRange2D *|IMP::algebra::BoundedGridRangeD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundedGridRangeDT_3_t = {"_p_IMP__algebra__BoundedGridRangeDT_3_t", "IMP::algebra::BoundedGridRange3D *|IMP::algebra::BoundedGridRangeD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundedGridRangeDT_4_t = {"_p_IMP__algebra__BoundedGridRangeDT_4_t", "IMP::algebra::BoundedGridRange4D *|IMP::algebra::BoundedGridRangeD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundedGridRangeDT_5_t = {"_p_IMP__algebra__BoundedGridRangeDT_5_t", "IMP::algebra::BoundedGridRange5D *|IMP::algebra::BoundedGridRangeD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundedGridRangeDT_6_t = {"_p_IMP__algebra__BoundedGridRangeDT_6_t", "IMP::algebra::BoundedGridRange6D *|IMP::algebra::BoundedGridRangeD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundedGridRangeDT__1_t = {"_p_IMP__algebra__BoundedGridRangeDT__1_t", "IMP::algebra::BoundedGridRangeKD *|IMP::algebra::BoundedGridRangeD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundingBoxDT_1_t = {"_p_IMP__algebra__BoundingBoxDT_1_t", "IMP::algebra::BoundingBox1D *|IMP::algebra::BoundingBoxD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundingBoxDT_2_t = {"_p_IMP__algebra__BoundingBoxDT_2_t", "IMP::algebra::BoundingBox2D *|IMP::algebra::BoundingBoxD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundingBoxDT_3_t = {"_p_IMP__algebra__BoundingBoxDT_3_t", "IMP::algebra::BoundingBox3D *|IMP::algebra::BoundingBoxD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundingBoxDT_4_t = {"_p_IMP__algebra__BoundingBoxDT_4_t", "IMP::algebra::BoundingBox4D *|IMP::algebra::BoundingBoxD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundingBoxDT_5_t = {"_p_IMP__algebra__BoundingBoxDT_5_t", "IMP::algebra::BoundingBox5D *|IMP::algebra::BoundingBoxD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundingBoxDT_6_t = {"_p_IMP__algebra__BoundingBoxDT_6_t", "IMP::algebra::BoundingBox6D *|IMP::algebra::BoundingBoxD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__BoundingBoxDT__1_t = {"_p_IMP__algebra__BoundingBoxDT__1_t", "IMP::algebra::BoundingBoxKD *|IMP::algebra::BoundingBoxD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Cone3D = {"_p_IMP__algebra__Cone3D", "IMP::algebra::Cone3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__ConnollySurfacePoint = {"_p_IMP__algebra__ConnollySurfacePoint", "IMP::algebra::ConnollySurfacePoint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Cylinder3D = {"_p_IMP__algebra__Cylinder3D", "IMP::algebra::Cylinder3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__DefaultEmbeddingDT_1_t = {"_p_IMP__algebra__DefaultEmbeddingDT_1_t", "IMP::algebra::DefaultEmbedding1D *|IMP::algebra::DefaultEmbeddingD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__DefaultEmbeddingDT_2_t = {"_p_IMP__algebra__DefaultEmbeddingDT_2_t", "IMP::algebra::DefaultEmbedding2D *|IMP::algebra::DefaultEmbeddingD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__DefaultEmbeddingDT_3_t = {"_p_IMP__algebra__DefaultEmbeddingDT_3_t", "IMP::algebra::DefaultEmbedding3D *|IMP::algebra::DefaultEmbeddingD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__DefaultEmbeddingDT_4_t = {"_p_IMP__algebra__DefaultEmbeddingDT_4_t", "IMP::algebra::DefaultEmbedding4D *|IMP::algebra::DefaultEmbeddingD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__DefaultEmbeddingDT_5_t = {"_p_IMP__algebra__DefaultEmbeddingDT_5_t", "IMP::algebra::DefaultEmbedding5D *|IMP::algebra::DefaultEmbeddingD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__DefaultEmbeddingDT_6_t = {"_p_IMP__algebra__DefaultEmbeddingDT_6_t", "IMP::algebra::DefaultEmbedding6D *|IMP::algebra::DefaultEmbeddingD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__DefaultEmbeddingDT__1_t = {"_p_IMP__algebra__DefaultEmbeddingDT__1_t", "IMP::algebra::DefaultEmbeddingKD *|IMP::algebra::DefaultEmbeddingD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__DynamicNearestNeighbor3D = {"_p_IMP__algebra__DynamicNearestNeighbor3D", "IMP::algebra::DynamicNearestNeighbor3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Ellipsoid3D = {"_p_IMP__algebra__Ellipsoid3D", "IMP::algebra::Ellipsoid3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__EuclideanVectorKDMetric = {"_p_IMP__algebra__EuclideanVectorKDMetric", "IMP::algebra::EuclideanVectorKDMetric *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__ExtendedGridIndexDT_1_t = {"_p_IMP__algebra__ExtendedGridIndexDT_1_t", "IMP::algebra::ExtendedGridIndex1D *|IMP::algebra::ExtendedGridIndexD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__ExtendedGridIndexDT_2_t = {"_p_IMP__algebra__ExtendedGridIndexDT_2_t", "IMP::algebra::ExtendedGridIndex2D *|IMP::algebra::ExtendedGridIndexD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__ExtendedGridIndexDT_3_t = {"_p_IMP__algebra__ExtendedGridIndexDT_3_t", "IMP::algebra::ExtendedGridIndex3D *|IMP::algebra::ExtendedGridIndexD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__ExtendedGridIndexDT_4_t = {"_p_IMP__algebra__ExtendedGridIndexDT_4_t", "IMP::algebra::ExtendedGridIndex4D *|IMP::algebra::ExtendedGridIndexD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__ExtendedGridIndexDT_5_t = {"_p_IMP__algebra__ExtendedGridIndexDT_5_t", "IMP::algebra::ExtendedGridIndex5D *|IMP::algebra::ExtendedGridIndexD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__ExtendedGridIndexDT_6_t = {"_p_IMP__algebra__ExtendedGridIndexDT_6_t", "IMP::algebra::ExtendedGridIndex6D *|IMP::algebra::ExtendedGridIndexD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__ExtendedGridIndexDT__1_t = {"_p_IMP__algebra__ExtendedGridIndexDT__1_t", "IMP::algebra::ExtendedGridIndexKD *|IMP::algebra::ExtendedGridIndexD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__FixedXYZ = {"_p_IMP__algebra__FixedXYZ", "IMP::algebra::FixedXYZ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Gaussian3D = {"_p_IMP__algebra__Gaussian3D", "IMP::algebra::Gaussian3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__GeometricPrimitiveDT_1_t = {"_p_IMP__algebra__GeometricPrimitiveDT_1_t", "IMP::algebra::GeometricPrimitive1D *|IMP::algebra::GeometricPrimitiveD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexBaseDT_1_t = {"_p_IMP__algebra__UnitSimplexBaseDT_1_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorBaseDT_1_t = {"_p_IMP__algebra__VectorBaseDT_1_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__GeometricPrimitiveDT_2_t = {"_p_IMP__algebra__GeometricPrimitiveDT_2_t", "IMP::algebra::GeometricPrimitive2D *|IMP::algebra::GeometricPrimitiveD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexBaseDT_2_t = {"_p_IMP__algebra__UnitSimplexBaseDT_2_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorBaseDT_2_t = {"_p_IMP__algebra__VectorBaseDT_2_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__GeometricPrimitiveDT_3_t = {"_p_IMP__algebra__GeometricPrimitiveDT_3_t", "IMP::algebra::GeometricPrimitive3D *|IMP::algebra::GeometricPrimitiveD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexBaseDT_3_t = {"_p_IMP__algebra__UnitSimplexBaseDT_3_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorBaseDT_3_t = {"_p_IMP__algebra__VectorBaseDT_3_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__GeometricPrimitiveDT_4_t = {"_p_IMP__algebra__GeometricPrimitiveDT_4_t", "IMP::algebra::GeometricPrimitive4D *|IMP::algebra::GeometricPrimitiveD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexBaseDT_4_t = {"_p_IMP__algebra__UnitSimplexBaseDT_4_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorBaseDT_4_t = {"_p_IMP__algebra__VectorBaseDT_4_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__GeometricPrimitiveDT_5_t = {"_p_IMP__algebra__GeometricPrimitiveDT_5_t", "IMP::algebra::GeometricPrimitive5D *|IMP::algebra::GeometricPrimitiveD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexBaseDT_5_t = {"_p_IMP__algebra__UnitSimplexBaseDT_5_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorBaseDT_5_t = {"_p_IMP__algebra__VectorBaseDT_5_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__GeometricPrimitiveDT_6_t = {"_p_IMP__algebra__GeometricPrimitiveDT_6_t", "IMP::algebra::GeometricPrimitive6D *|IMP::algebra::GeometricPrimitiveD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexBaseDT_6_t = {"_p_IMP__algebra__UnitSimplexBaseDT_6_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorBaseDT_6_t = {"_p_IMP__algebra__VectorBaseDT_6_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__GeometricPrimitiveDT__1_t = {"_p_IMP__algebra__GeometricPrimitiveDT__1_t", "IMP::algebra::GeometricPrimitiveKD *|IMP::algebra::GeometricPrimitiveD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexBaseDT__1_t = {"_p_IMP__algebra__UnitSimplexBaseDT__1_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorBaseDT__1_t = {"_p_IMP__algebra__VectorBaseDT__1_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_IMP__algebra__GridIndexDT_1_t = {"_p_IMP__algebra__GridIndexDT_1_t", "IMP::algebra::GridIndex1D *|IMP::algebra::GridIndexD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__GridIndexDT_2_t = {"_p_IMP__algebra__GridIndexDT_2_t", "IMP::algebra::GridIndex2D *|IMP::algebra::GridIndexD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__GridIndexDT_3_t = {"_p_IMP__algebra__GridIndexDT_3_t", "IMP::algebra::GridIndex3D *|IMP::algebra::GridIndexD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__GridIndexDT_4_t = {"_p_IMP__algebra__GridIndexDT_4_t", "IMP::algebra::GridIndex4D *|IMP::algebra::GridIndexD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__GridIndexDT_5_t = {"_p_IMP__algebra__GridIndexDT_5_t", "IMP::algebra::GridIndex5D *|IMP::algebra::GridIndexD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__GridIndexDT_6_t = {"_p_IMP__algebra__GridIndexDT_6_t", "IMP::algebra::GridIndex6D *|IMP::algebra::GridIndexD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__GridIndexDT__1_t = {"_p_IMP__algebra__GridIndexDT__1_t", "IMP::algebra::GridIndexKD *|IMP::algebra::GridIndexD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Line3D = {"_p_IMP__algebra__Line3D", "IMP::algebra::Line3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__LinearFit2D = {"_p_IMP__algebra__LinearFit2D", "IMP::algebra::LinearFit *|IMP::algebra::LinearFit2D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__LogEmbeddingDT_1_t = {"_p_IMP__algebra__LogEmbeddingDT_1_t", "IMP::algebra::LogEmbedding1D *|IMP::algebra::LogEmbeddingD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__LogEmbeddingDT_2_t = {"_p_IMP__algebra__LogEmbeddingDT_2_t", "IMP::algebra::LogEmbedding2D *|IMP::algebra::LogEmbeddingD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__LogEmbeddingDT_3_t = {"_p_IMP__algebra__LogEmbeddingDT_3_t", "IMP::algebra::LogEmbedding3D *|IMP::algebra::LogEmbeddingD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__LogEmbeddingDT_4_t = {"_p_IMP__algebra__LogEmbeddingDT_4_t", "IMP::algebra::LogEmbedding4D *|IMP::algebra::LogEmbeddingD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__LogEmbeddingDT_5_t = {"_p_IMP__algebra__LogEmbeddingDT_5_t", "IMP::algebra::LogEmbedding5D *|IMP::algebra::LogEmbeddingD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__LogEmbeddingDT_6_t = {"_p_IMP__algebra__LogEmbeddingDT_6_t", "IMP::algebra::LogEmbedding6D *|IMP::algebra::LogEmbeddingD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__LogEmbeddingDT__1_t = {"_p_IMP__algebra__LogEmbeddingDT__1_t", "IMP::algebra::LogEmbeddingKD *|IMP::algebra::LogEmbeddingD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__MaxVectorKDMetric = {"_p_IMP__algebra__MaxVectorKDMetric", "IMP::algebra::MaxVectorKDMetric *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__NearestNeighborDT_1_t = {"_p_IMP__algebra__NearestNeighborDT_1_t", "IMP::algebra::NearestNeighbor1D *|IMP::algebra::NearestNeighborD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__NearestNeighborDT_2_t = {"_p_IMP__algebra__NearestNeighborDT_2_t", "IMP::algebra::NearestNeighbor2D *|IMP::algebra::NearestNeighborD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__NearestNeighborDT_3_t = {"_p_IMP__algebra__NearestNeighborDT_3_t", "IMP::algebra::NearestNeighbor3D *|IMP::algebra::NearestNeighborD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__NearestNeighborDT_4_t = {"_p_IMP__algebra__NearestNeighborDT_4_t", "IMP::algebra::NearestNeighbor4D *|IMP::algebra::NearestNeighborD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__NearestNeighborDT_5_t = {"_p_IMP__algebra__NearestNeighborDT_5_t", "IMP::algebra::NearestNeighbor5D *|IMP::algebra::NearestNeighborD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__NearestNeighborDT_6_t = {"_p_IMP__algebra__NearestNeighborDT_6_t", "IMP::algebra::NearestNeighbor6D *|IMP::algebra::NearestNeighborD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__NearestNeighborDT__1_t = {"_p_IMP__algebra__NearestNeighborDT__1_t", "IMP::algebra::NearestNeighborKD *|IMP::algebra::NearestNeighborD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__ParabolicFit2D = {"_p_IMP__algebra__ParabolicFit2D", "IMP::algebra::ParabolicFit *|IMP::algebra::ParabolicFit2D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Plane3D = {"_p_IMP__algebra__Plane3D", "IMP::algebra::Plane3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_1_t = {"_p_IMP__algebra__PrincipalComponentAnalysisDT_1_t", "IMP::algebra::PrincipalComponentAnalysis1D *|IMP::algebra::PrincipalComponentAnalysisD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_2_t = {"_p_IMP__algebra__PrincipalComponentAnalysisDT_2_t", "IMP::algebra::PrincipalComponentAnalysis2D *|IMP::algebra::PrincipalComponentAnalysisD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_3_t = {"_p_IMP__algebra__PrincipalComponentAnalysisDT_3_t", "IMP::algebra::PrincipalComponentAnalysis *|IMP::algebra::PrincipalComponentAnalysis3D *|IMP::algebra::PrincipalComponentAnalysisD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_4_t = {"_p_IMP__algebra__PrincipalComponentAnalysisDT_4_t", "IMP::algebra::PrincipalComponentAnalysis4D *|IMP::algebra::PrincipalComponentAnalysisD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_5_t = {"_p_IMP__algebra__PrincipalComponentAnalysisDT_5_t", "IMP::algebra::PrincipalComponentAnalysis5D *|IMP::algebra::PrincipalComponentAnalysisD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_6_t = {"_p_IMP__algebra__PrincipalComponentAnalysisDT_6_t", "IMP::algebra::PrincipalComponentAnalysis6D *|IMP::algebra::PrincipalComponentAnalysisD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__PrincipalComponentAnalysisDT__1_t = {"_p_IMP__algebra__PrincipalComponentAnalysisDT__1_t", "IMP::algebra::PrincipalComponentAnalysisKD *|IMP::algebra::PrincipalComponentAnalysisD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__ReferenceFrame3D = {"_p_IMP__algebra__ReferenceFrame3D", "IMP::algebra::ReferenceFrame3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Reflection3D = {"_p_IMP__algebra__Reflection3D", "IMP::algebra::Reflection3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Rotation2D = {"_p_IMP__algebra__Rotation2D", "IMP::algebra::Rotation2D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Rotation3D = {"_p_IMP__algebra__Rotation3D", "IMP::algebra::Rotation3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Segment3D = {"_p_IMP__algebra__Segment3D", "IMP::algebra::Segment3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__SphereDT_1_t = {"_p_IMP__algebra__SphereDT_1_t", "IMP::algebra::Sphere1D *|IMP::algebra::SphereD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__SphereDT_2_t = {"_p_IMP__algebra__SphereDT_2_t", "IMP::algebra::Sphere2D *|IMP::algebra::SphereD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__SphereDT_3_t = {"_p_IMP__algebra__SphereDT_3_t", "IMP::algebra::Sphere3D *|IMP::algebra::SphereD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__SphereDT_4_t = {"_p_IMP__algebra__SphereDT_4_t", "IMP::algebra::Sphere4D *|IMP::algebra::SphereD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__SphereDT_5_t = {"_p_IMP__algebra__SphereDT_5_t", "IMP::algebra::Sphere5D *|IMP::algebra::SphereD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__SphereDT_6_t = {"_p_IMP__algebra__SphereDT_6_t", "IMP::algebra::Sphere6D *|IMP::algebra::SphereD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__SphereDT__1_t = {"_p_IMP__algebra__SphereDT__1_t", "IMP::algebra::SphereKD *|IMP::algebra::SphereD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__SpherePatch3D = {"_p_IMP__algebra__SpherePatch3D", "IMP::algebra::SpherePatch3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__SphericalVector3D = {"_p_IMP__algebra__SphericalVector3D", "IMP::algebra::SphericalVector3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Transformation2D = {"_p_IMP__algebra__Transformation2D", "IMP::algebra::Transformation2D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Transformation3D = {"_p_IMP__algebra__Transformation3D", "IMP::algebra::Transformation3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__Triangle3D = {"_p_IMP__algebra__Triangle3D", "IMP::algebra::Triangle3D *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnboundedGridRangeDT_1_t = {"_p_IMP__algebra__UnboundedGridRangeDT_1_t", "IMP::algebra::UnboundedGridRange1D *|IMP::algebra::UnboundedGridRangeD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnboundedGridRangeDT_2_t = {"_p_IMP__algebra__UnboundedGridRangeDT_2_t", "IMP::algebra::UnboundedGridRange2D *|IMP::algebra::UnboundedGridRangeD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnboundedGridRangeDT_3_t = {"_p_IMP__algebra__UnboundedGridRangeDT_3_t", "IMP::algebra::UnboundedGridRange3D *|IMP::algebra::UnboundedGridRangeD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnboundedGridRangeDT_4_t = {"_p_IMP__algebra__UnboundedGridRangeDT_4_t", "IMP::algebra::UnboundedGridRange4D *|IMP::algebra::UnboundedGridRangeD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnboundedGridRangeDT_5_t = {"_p_IMP__algebra__UnboundedGridRangeDT_5_t", "IMP::algebra::UnboundedGridRange5D *|IMP::algebra::UnboundedGridRangeD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnboundedGridRangeDT_6_t = {"_p_IMP__algebra__UnboundedGridRangeDT_6_t", "IMP::algebra::UnboundedGridRange6D *|IMP::algebra::UnboundedGridRangeD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnboundedGridRangeDT__1_t = {"_p_IMP__algebra__UnboundedGridRangeDT__1_t", "IMP::algebra::UnboundedGridRangeKD *|IMP::algebra::UnboundedGridRangeD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexDT_1_t = {"_p_IMP__algebra__UnitSimplexDT_1_t", "IMP::algebra::UnitSimplex1D *|IMP::algebra::UnitSimplexD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexDT_2_t = {"_p_IMP__algebra__UnitSimplexDT_2_t", "IMP::algebra::UnitSimplex2D *|IMP::algebra::UnitSimplexD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexDT_3_t = {"_p_IMP__algebra__UnitSimplexDT_3_t", "IMP::algebra::UnitSimplex3D *|IMP::algebra::UnitSimplexD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexDT_4_t = {"_p_IMP__algebra__UnitSimplexDT_4_t", "IMP::algebra::UnitSimplex4D *|IMP::algebra::UnitSimplexD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexDT_5_t = {"_p_IMP__algebra__UnitSimplexDT_5_t", "IMP::algebra::UnitSimplex5D *|IMP::algebra::UnitSimplexD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexDT_6_t = {"_p_IMP__algebra__UnitSimplexDT_6_t", "IMP::algebra::UnitSimplex6D *|IMP::algebra::UnitSimplexD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__UnitSimplexDT__1_t = {"_p_IMP__algebra__UnitSimplexDT__1_t", "IMP::algebra::UnitSimplexKD *|IMP::algebra::UnitSimplexD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorDT_1_t = {"_p_IMP__algebra__VectorDT_1_t", "IMP::algebra::Vector1D *|IMP::algebra::VectorD< 1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorDT_2_t = {"_p_IMP__algebra__VectorDT_2_t", "IMP::algebra::Vector2D *|IMP::algebra::VectorD< 2 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorDT_3_t = {"_p_IMP__algebra__VectorDT_3_t", "IMP::algebra::Vector3D *|IMP::algebra::VectorD< 3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorDT_4_t = {"_p_IMP__algebra__VectorDT_4_t", "IMP::algebra::Rotation3DAdjoint *|IMP::algebra::Vector4D *|IMP::algebra::VectorD< 4 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorDT_5_t = {"_p_IMP__algebra__VectorDT_5_t", "IMP::algebra::Vector5D *|IMP::algebra::VectorD< 5 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorDT_6_t = {"_p_IMP__algebra__VectorDT_6_t", "IMP::algebra::Vector6D *|IMP::algebra::VectorD< 6 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorDT__1_t = {"_p_IMP__algebra__VectorDT__1_t", "IMP::algebra::VectorKD *|IMP::algebra::VectorD< -1 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__algebra__VectorKDMetric = {"_p_IMP__algebra__VectorKDMetric", "IMP::algebra::VectorKDMetric *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__AllBipartitePairContainer = {"_p_IMP__container__AllBipartitePairContainer", "IMP::container::AllBipartitePairContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__AllPairContainer = {"_p_IMP__container__AllPairContainer", "IMP::container::AllPairContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__CloseBipartitePairContainer = {"_p_IMP__container__CloseBipartitePairContainer", "IMP::container::CloseBipartitePairContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__ClosePairContainer = {"_p_IMP__container__ClosePairContainer", "IMP::container::ClosePairContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__ConnectingPairContainer = {"_p_IMP__container__ConnectingPairContainer", "IMP::container::ConnectingPairContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__ConsecutivePairContainer = {"_p_IMP__container__ConsecutivePairContainer", "IMP::container::ConsecutivePairContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__ConsecutivePairFilter = {"_p_IMP__container__ConsecutivePairFilter", "IMP::container::ConsecutivePairFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__DistributePairsScoreState = {"_p_IMP__container__DistributePairsScoreState", "IMP::container::DistributePairsScoreState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__DistributeQuadsScoreState = {"_p_IMP__container__DistributeQuadsScoreState", "IMP::container::DistributeQuadsScoreState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__DistributeSingletonsScoreState = {"_p_IMP__container__DistributeSingletonsScoreState", "IMP::container::DistributeSingletonsScoreState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__DistributeTripletsScoreState = {"_p_IMP__container__DistributeTripletsScoreState", "IMP::container::DistributeTripletsScoreState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__DynamicListPairContainer = {"_p_IMP__container__DynamicListPairContainer", "IMP::container::DynamicListPairContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__DynamicListQuadContainer = {"_p_IMP__container__DynamicListQuadContainer", "IMP::container::DynamicListQuadContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__DynamicListSingletonContainer = {"_p_IMP__container__DynamicListSingletonContainer", "IMP::container::DynamicListSingletonContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__DynamicListTripletContainer = {"_p_IMP__container__DynamicListTripletContainer", "IMP::container::DynamicListTripletContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__EventPairsOptimizerState = {"_p_IMP__container__EventPairsOptimizerState", "IMP::container::EventPairsOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__EventQuadsOptimizerState = {"_p_IMP__container__EventQuadsOptimizerState", "IMP::container::EventQuadsOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__EventSingletonsOptimizerState = {"_p_IMP__container__EventSingletonsOptimizerState", "IMP::container::EventSingletonsOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__EventTripletsOptimizerState = {"_p_IMP__container__EventTripletsOptimizerState", "IMP::container::EventTripletsOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__ExclusiveConsecutivePairContainer = {"_p_IMP__container__ExclusiveConsecutivePairContainer", "IMP::container::ExclusiveConsecutivePairContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__ExclusiveConsecutivePairFilter = {"_p_IMP__container__ExclusiveConsecutivePairFilter", "IMP::container::ExclusiveConsecutivePairFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__InContainerPairFilter = {"_p_IMP__container__InContainerPairFilter", "IMP::container::InContainerPairFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__InContainerQuadFilter = {"_p_IMP__container__InContainerQuadFilter", "IMP::container::InContainerQuadFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__InContainerSingletonFilter = {"_p_IMP__container__InContainerSingletonFilter", "IMP::container::InContainerSingletonFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__InContainerTripletFilter = {"_p_IMP__container__InContainerTripletFilter", "IMP::container::InContainerTripletFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__ListPairContainer = {"_p_IMP__container__ListPairContainer", "IMP::container::ListPairContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__ListQuadContainer = {"_p_IMP__container__ListQuadContainer", "IMP::container::ListQuadContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__ListSingletonContainer = {"_p_IMP__container__ListSingletonContainer", "IMP::container::ListSingletonContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__ListTripletContainer = {"_p_IMP__container__ListTripletContainer", "IMP::container::ListTripletContainer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__MinimumPairRestraint = {"_p_IMP__container__MinimumPairRestraint", "IMP::container::MinimumPairRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__MinimumPairScore = {"_p_IMP__container__MinimumPairScore", "IMP::container::MinimumPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__MinimumQuadRestraint = {"_p_IMP__container__MinimumQuadRestraint", "IMP::container::MinimumQuadRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__MinimumQuadScore = {"_p_IMP__container__MinimumQuadScore", "IMP::container::MinimumQuadScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__MinimumSingletonRestraint = {"_p_IMP__container__MinimumSingletonRestraint", "IMP::container::MinimumSingletonRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__MinimumSingletonScore = {"_p_IMP__container__MinimumSingletonScore", "IMP::container::MinimumSingletonScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__MinimumTripletRestraint = {"_p_IMP__container__MinimumTripletRestraint", "IMP::container::MinimumTripletRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__MinimumTripletScore = {"_p_IMP__container__MinimumTripletScore", "IMP::container::MinimumTripletScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__PairContainerSet = {"_p_IMP__container__PairContainerSet", "IMP::container::PairContainerSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__PairContainerStatistics = {"_p_IMP__container__PairContainerStatistics", "IMP::container::PairContainerStatistics *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__PairsConstraint = {"_p_IMP__container__PairsConstraint", "IMP::container::PairsConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__PairsOptimizerState = {"_p_IMP__container__PairsOptimizerState", "IMP::container::PairsOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__PairsRestraint = {"_p_IMP__container__PairsRestraint", "IMP::container::PairsRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__PredicatePairsRestraint = {"_p_IMP__container__PredicatePairsRestraint", "IMP::container::PredicatePairsRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__PredicateQuadsRestraint = {"_p_IMP__container__PredicateQuadsRestraint", "IMP::container::PredicateQuadsRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__PredicateSingletonsRestraint = {"_p_IMP__container__PredicateSingletonsRestraint", "IMP::container::PredicateSingletonsRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__PredicateTripletsRestraint = {"_p_IMP__container__PredicateTripletsRestraint", "IMP::container::PredicateTripletsRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__QuadContainerSet = {"_p_IMP__container__QuadContainerSet", "IMP::container::QuadContainerSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__QuadContainerStatistics = {"_p_IMP__container__QuadContainerStatistics", "IMP::container::QuadContainerStatistics *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__QuadsConstraint = {"_p_IMP__container__QuadsConstraint", "IMP::container::QuadsConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__QuadsOptimizerState = {"_p_IMP__container__QuadsOptimizerState", "IMP::container::QuadsOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__QuadsRestraint = {"_p_IMP__container__QuadsRestraint", "IMP::container::QuadsRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__SingletonContainerSet = {"_p_IMP__container__SingletonContainerSet", "IMP::container::SingletonContainerSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__SingletonContainerStatistics = {"_p_IMP__container__SingletonContainerStatistics", "IMP::container::SingletonContainerStatistics *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__SingletonsConstraint = {"_p_IMP__container__SingletonsConstraint", "IMP::container::SingletonsConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__SingletonsOptimizerState = {"_p_IMP__container__SingletonsOptimizerState", "IMP::container::SingletonsOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__SingletonsRestraint = {"_p_IMP__container__SingletonsRestraint", "IMP::container::SingletonsRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__TripletContainerSet = {"_p_IMP__container__TripletContainerSet", "IMP::container::TripletContainerSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__TripletContainerStatistics = {"_p_IMP__container__TripletContainerStatistics", "IMP::container::TripletContainerStatistics *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__TripletsConstraint = {"_p_IMP__container__TripletsConstraint", "IMP::container::TripletsConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__TripletsOptimizerState = {"_p_IMP__container__TripletsOptimizerState", "IMP::container::TripletsOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__container__TripletsRestraint = {"_p_IMP__container__TripletsRestraint", "IMP::container::TripletsRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__AllSamePairPredicate = {"_p_IMP__core__AllSamePairPredicate", "IMP::core::AllSamePairPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__AllSameQuadPredicate = {"_p_IMP__core__AllSameQuadPredicate", "IMP::core::AllSameQuadPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__AllSameSingletonPredicate = {"_p_IMP__core__AllSameSingletonPredicate", "IMP::core::AllSameSingletonPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__AllSameTripletPredicate = {"_p_IMP__core__AllSameTripletPredicate", "IMP::core::AllSameTripletPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__AngleRestraint = {"_p_IMP__core__AngleRestraint", "IMP::core::AngleRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__AngleTripletScore = {"_p_IMP__core__AngleTripletScore", "IMP::core::AngleTripletScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__AttributeSingletonPredicate = {"_p_IMP__core__AttributeSingletonPredicate", "IMP::core::AttributeSingletonPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__BallMover = {"_p_IMP__core__BallMover", "IMP::core::BallMover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__BinormalTerm = {"_p_IMP__core__BinormalTerm", "IMP::core::BinormalTerm *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__BoxSweepClosePairsFinder = {"_p_IMP__core__BoxSweepClosePairsFinder", "IMP::core::BoxSweepClosePairsFinder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Centroid = {"_p_IMP__core__Centroid", "IMP::core::Centroid *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__CentroidOfRefined = {"_p_IMP__core__CentroidOfRefined", "IMP::core::CentroidOfRefined *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ChecksScoreState = {"_p_IMP__core__ChecksScoreState", "IMP::core::ChecksScoreState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ChildrenRefiner = {"_p_IMP__core__ChildrenRefiner", "IMP::core::ChildrenRefiner *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ClosePairsFinder = {"_p_IMP__core__ClosePairsFinder", "IMP::core::ClosePairsFinder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ClosePairsPairScore = {"_p_IMP__core__ClosePairsPairScore", "IMP::core::ClosePairsPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ClosedCubicSpline = {"_p_IMP__core__ClosedCubicSpline", "IMP::core::ClosedCubicSpline *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ClusterProvenance = {"_p_IMP__core__ClusterProvenance", "IMP::core::ClusterProvenance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__CoinFlipPairPredicate = {"_p_IMP__core__CoinFlipPairPredicate", "IMP::core::CoinFlipPairPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__CoinFlipQuadPredicate = {"_p_IMP__core__CoinFlipQuadPredicate", "IMP::core::CoinFlipQuadPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__CoinFlipSingletonPredicate = {"_p_IMP__core__CoinFlipSingletonPredicate", "IMP::core::CoinFlipSingletonPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__CoinFlipTripletPredicate = {"_p_IMP__core__CoinFlipTripletPredicate", "IMP::core::CoinFlipTripletPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__CombineProvenance = {"_p_IMP__core__CombineProvenance", "IMP::core::CombineProvenance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ConjugateGradients = {"_p_IMP__core__ConjugateGradients", "IMP::core::ConjugateGradients *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ConnectivityRestraint = {"_p_IMP__core__ConnectivityRestraint", "IMP::core::ConnectivityRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ConstantPairPredicate = {"_p_IMP__core__ConstantPairPredicate", "IMP::core::ConstantPairPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ConstantQuadPredicate = {"_p_IMP__core__ConstantQuadPredicate", "IMP::core::ConstantQuadPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ConstantRestraint = {"_p_IMP__core__ConstantRestraint", "IMP::core::ConstantRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ConstantSingletonPredicate = {"_p_IMP__core__ConstantSingletonPredicate", "IMP::core::ConstantSingletonPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ConstantTripletPredicate = {"_p_IMP__core__ConstantTripletPredicate", "IMP::core::ConstantTripletPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Cosine = {"_p_IMP__core__Cosine", "IMP::core::Cosine *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Cover = {"_p_IMP__core__Cover", "IMP::core::Cover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__CoverRefined = {"_p_IMP__core__CoverRefined", "IMP::core::CoverRefined *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__DerivativesFromRefined = {"_p_IMP__core__DerivativesFromRefined", "IMP::core::DerivativesFromRefined *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__DerivativesToRefined = {"_p_IMP__core__DerivativesToRefined", "IMP::core::DerivativesToRefined *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__DiameterRestraint = {"_p_IMP__core__DiameterRestraint", "IMP::core::DiameterRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__DihedralRestraint = {"_p_IMP__core__DihedralRestraint", "IMP::core::DihedralRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Direction = {"_p_IMP__core__Direction", "IMP::core::Direction *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__DirectionAngle = {"_p_IMP__core__DirectionAngle", "IMP::core::DirectionAngle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__DirectionMover = {"_p_IMP__core__DirectionMover", "IMP::core::DirectionMover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__DistancePairScore = {"_p_IMP__core__DistancePairScore", "IMP::core::DistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__DistanceRestraint = {"_p_IMP__core__DistanceRestraint", "IMP::core::DistanceRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__EdgePairGeometry = {"_p_IMP__core__EdgePairGeometry", "IMP::core::EdgePairGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__EdgePairsGeometry = {"_p_IMP__core__EdgePairsGeometry", "IMP::core::EdgePairsGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ExcludedVolumeRestraint = {"_p_IMP__core__ExcludedVolumeRestraint", "IMP::core::ExcludedVolumeRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__FilterProvenance = {"_p_IMP__core__FilterProvenance", "IMP::core::FilterProvenance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__FixedRefiner = {"_p_IMP__core__FixedRefiner", "IMP::core::FixedRefiner *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Gaussian = {"_p_IMP__core__Gaussian", "IMP::core::Gaussian *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t = {"_p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t", "IMP::core::AttributeSingletonScore *|IMP::core::GenericAttributeSingletonScore< IMP::UnaryFunction > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t = {"_p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t", "IMP::core::BoundingBox3DSingletonScore *|IMP::core::GenericBoundingBox3DSingletonScore< IMP::UnaryFunction > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t = {"_p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t", "IMP::core::BoundingSphere3DSingletonScore *|IMP::core::GenericBoundingSphere3DSingletonScore< IMP::UnaryFunction > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t = {"_p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t", "IMP::core::DistanceToSingletonScore *|IMP::core::GenericDistanceToSingletonScore< IMP::UnaryFunction > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__GridClosePairsFinder = {"_p_IMP__core__GridClosePairsFinder", "IMP::core::GridClosePairsFinder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Harmonic = {"_p_IMP__core__Harmonic", "IMP::core::Harmonic *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HarmonicDistancePairScore = {"_p_IMP__core__HarmonicDistancePairScore", "IMP::core::HarmonicDistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HarmonicLowerBound = {"_p_IMP__core__HarmonicLowerBound", "IMP::core::HarmonicLowerBound *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HarmonicSphereDistancePairScore = {"_p_IMP__core__HarmonicSphereDistancePairScore", "IMP::core::HarmonicSphereDistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HarmonicSurfaceDepthPairScore = {"_p_IMP__core__HarmonicSurfaceDepthPairScore", "IMP::core::HarmonicSurfaceDepthPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HarmonicSurfaceDistancePairScore = {"_p_IMP__core__HarmonicSurfaceDistancePairScore", "IMP::core::HarmonicSurfaceDistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HarmonicSurfaceHeightPairScore = {"_p_IMP__core__HarmonicSurfaceHeightPairScore", "IMP::core::HarmonicSurfaceHeightPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HarmonicUpperBound = {"_p_IMP__core__HarmonicUpperBound", "IMP::core::HarmonicUpperBound *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore = {"_p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore", "IMP::core::HarmonicUpperBoundSphereDiameterPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HarmonicUpperBoundSphereDistancePairScore = {"_p_IMP__core__HarmonicUpperBoundSphereDistancePairScore", "IMP::core::HarmonicUpperBoundSphereDistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HarmonicWell = {"_p_IMP__core__HarmonicWell", "IMP::core::HarmonicWell *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Hierarchy = {"_p_IMP__core__Hierarchy", "IMP::core::Hierarchy *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HierarchyCounter = {"_p_IMP__core__HierarchyCounter", "IMP::core::HierarchyCounter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__HierarchyTraits = {"_p_IMP__core__HierarchyTraits", "IMP::core::HierarchyTraits *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__InBoundingBox3DSingletonPredicate = {"_p_IMP__core__InBoundingBox3DSingletonPredicate", "IMP::core::InBoundingBox3DSingletonPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__IsCollisionPairPredicate = {"_p_IMP__core__IsCollisionPairPredicate", "IMP::core::IsCollisionPairPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__KClosePairsPairScore = {"_p_IMP__core__KClosePairsPairScore", "IMP::core::KClosePairsPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__LateralSurfaceConstraint = {"_p_IMP__core__LateralSurfaceConstraint", "IMP::core::LateralSurfaceConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__LeavesRefiner = {"_p_IMP__core__LeavesRefiner", "IMP::core::LeavesRefiner *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Linear = {"_p_IMP__core__Linear", "IMP::core::Linear *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__LogNormalMover = {"_p_IMP__core__LogNormalMover", "IMP::core::LogNormalMover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__MCCGSampler = {"_p_IMP__core__MCCGSampler", "IMP::core::MCCGSampler *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__MSConnectivityRestraint = {"_p_IMP__core__MSConnectivityRestraint", "IMP::core::MSConnectivityRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__MinimumRestraint = {"_p_IMP__core__MinimumRestraint", "IMP::core::MinimumRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__MonteCarlo = {"_p_IMP__core__MonteCarlo", "IMP::core::MonteCarlo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__MonteCarloMover = {"_p_IMP__core__MonteCarloMover", "IMP::core::MonteCarloMover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__MonteCarloMoverResult = {"_p_IMP__core__MonteCarloMoverResult", "IMP::core::MonteCarloMoverResult *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__MonteCarloWithBasinHopping = {"_p_IMP__core__MonteCarloWithBasinHopping", "IMP::core::MonteCarloWithBasinHopping *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__MonteCarloWithLocalOptimization = {"_p_IMP__core__MonteCarloWithLocalOptimization", "IMP::core::MonteCarloWithLocalOptimization *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__MoveStatisticsScoreState = {"_p_IMP__core__MoveStatisticsScoreState", "IMP::core::MoveStatisticsScoreState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__MultipleBinormalRestraint = {"_p_IMP__core__MultipleBinormalRestraint", "IMP::core::MultipleBinormalRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__NearestNeighborsClosePairsFinder = {"_p_IMP__core__NearestNeighborsClosePairsFinder", "IMP::core::NearestNeighborsClosePairsFinder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__NeighborsTable = {"_p_IMP__core__NeighborsTable", "IMP::core::NeighborsTable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__NonRigidMember = {"_p_IMP__core__NonRigidMember", "IMP::core::NonRigidMember *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__NormalMover = {"_p_IMP__core__NormalMover", "IMP::core::NormalMover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__NormalizedSphereDistancePairScore = {"_p_IMP__core__NormalizedSphereDistancePairScore", "IMP::core::NormalizedSphereDistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__OpenCubicSpline = {"_p_IMP__core__OpenCubicSpline", "IMP::core::OpenCubicSpline *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__OrderedTypePairPredicate = {"_p_IMP__core__OrderedTypePairPredicate", "IMP::core::OrderedTypePairPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__OrderedTypeQuadPredicate = {"_p_IMP__core__OrderedTypeQuadPredicate", "IMP::core::OrderedTypeQuadPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__OrderedTypeSingletonPredicate = {"_p_IMP__core__OrderedTypeSingletonPredicate", "IMP::core::OrderedTypeSingletonPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__OrderedTypeTripletPredicate = {"_p_IMP__core__OrderedTypeTripletPredicate", "IMP::core::OrderedTypeTripletPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__PairConstraint = {"_p_IMP__core__PairConstraint", "IMP::core::PairConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__PairRestraint = {"_p_IMP__core__PairRestraint", "IMP::core::PairRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Provenance = {"_p_IMP__core__Provenance", "IMP::core::Provenance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Provenanced = {"_p_IMP__core__Provenanced", "IMP::core::Provenanced *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__QuadConstraint = {"_p_IMP__core__QuadConstraint", "IMP::core::QuadConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__QuadRestraint = {"_p_IMP__core__QuadRestraint", "IMP::core::QuadRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__QuadraticClosePairsFinder = {"_p_IMP__core__QuadraticClosePairsFinder", "IMP::core::QuadraticClosePairsFinder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Reference = {"_p_IMP__core__Reference", "IMP::core::Reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RefinedPairsPairScore = {"_p_IMP__core__RefinedPairsPairScore", "IMP::core::RefinedPairsPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RestraintsScoringFunction = {"_p_IMP__core__RestraintsScoringFunction", "IMP::core::RestraintsScoringFunction *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBody = {"_p_IMP__core__RigidBody", "IMP::core::RigidBody *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyAnglePairScore = {"_p_IMP__core__RigidBodyAnglePairScore", "IMP::core::RigidBodyAnglePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyDerivativeGeometry = {"_p_IMP__core__RigidBodyDerivativeGeometry", "IMP::core::RigidBodyDerivativeGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyDerivativesGeometry = {"_p_IMP__core__RigidBodyDerivativesGeometry", "IMP::core::RigidBodyDerivativesGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyDistancePairScore = {"_p_IMP__core__RigidBodyDistancePairScore", "IMP::core::RigidBodyDistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyFrameGeometry = {"_p_IMP__core__RigidBodyFrameGeometry", "IMP::core::RigidBodyFrameGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyFramesGeometry = {"_p_IMP__core__RigidBodyFramesGeometry", "IMP::core::RigidBodyFramesGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyHierarchyGeometry = {"_p_IMP__core__RigidBodyHierarchyGeometry", "IMP::core::RigidBodyHierarchyGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyMember = {"_p_IMP__core__RigidBodyMember", "IMP::core::RigidBodyMember *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyMover = {"_p_IMP__core__RigidBodyMover", "IMP::core::RigidBodyMover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyTorque = {"_p_IMP__core__RigidBodyTorque", "IMP::core::RigidBodyTorque *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyTunneler = {"_p_IMP__core__RigidBodyTunneler", "IMP::core::RigidBodyTunneler *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidBodyUmbrella = {"_p_IMP__core__RigidBodyUmbrella", "IMP::core::RigidBodyUmbrella *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidClosePairsFinder = {"_p_IMP__core__RigidClosePairsFinder", "IMP::core::RigidClosePairsFinder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidMember = {"_p_IMP__core__RigidMember", "IMP::core::RigidMember *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__RigidMembersRefiner = {"_p_IMP__core__RigidMembersRefiner", "IMP::core::RigidMembersRefiner *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SampleProvenance = {"_p_IMP__core__SampleProvenance", "IMP::core::SampleProvenance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__ScriptProvenance = {"_p_IMP__core__ScriptProvenance", "IMP::core::ScriptProvenance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SerialMover = {"_p_IMP__core__SerialMover", "IMP::core::SerialMover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SingletonConstraint = {"_p_IMP__core__SingletonConstraint", "IMP::core::SingletonConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SingletonRestraint = {"_p_IMP__core__SingletonRestraint", "IMP::core::SingletonRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SoftSpherePairScore = {"_p_IMP__core__SoftSpherePairScore", "IMP::core::SoftSpherePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SoftSubSurfacePairScore = {"_p_IMP__core__SoftSubSurfacePairScore", "IMP::core::SoftSubSurfacePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SoftSuperSurfacePairScore = {"_p_IMP__core__SoftSuperSurfacePairScore", "IMP::core::SoftSuperSurfacePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SoftwareProvenance = {"_p_IMP__core__SoftwareProvenance", "IMP::core::SoftwareProvenance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SphereDistancePairScore = {"_p_IMP__core__SphereDistancePairScore", "IMP::core::SphereDistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SphereDistanceToSingletonScore = {"_p_IMP__core__SphereDistanceToSingletonScore", "IMP::core::SphereDistanceToSingletonScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SteepestDescent = {"_p_IMP__core__SteepestDescent", "IMP::core::SteepestDescent *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__StructureProvenance = {"_p_IMP__core__StructureProvenance", "IMP::core::StructureProvenance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SubsetMover = {"_p_IMP__core__SubsetMover", "IMP::core::SubsetMover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Surface = {"_p_IMP__core__Surface", "IMP::core::Surface *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SurfaceDepthPairScore = {"_p_IMP__core__SurfaceDepthPairScore", "IMP::core::SurfaceDepthPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SurfaceDistancePairScore = {"_p_IMP__core__SurfaceDistancePairScore", "IMP::core::SurfaceDistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SurfaceGeometry = {"_p_IMP__core__SurfaceGeometry", "IMP::core::SurfaceGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SurfaceGeometryConstraint = {"_p_IMP__core__SurfaceGeometryConstraint", "IMP::core::SurfaceGeometryConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SurfaceHeightPairScore = {"_p_IMP__core__SurfaceHeightPairScore", "IMP::core::SurfaceHeightPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SurfaceMover = {"_p_IMP__core__SurfaceMover", "IMP::core::SurfaceMover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SurfaceSymmetryConstraint = {"_p_IMP__core__SurfaceSymmetryConstraint", "IMP::core::SurfaceSymmetryConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__SurfaceTetheredChain = {"_p_IMP__core__SurfaceTetheredChain", "IMP::core::SurfaceTetheredChain *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TableRefiner = {"_p_IMP__core__TableRefiner", "IMP::core::TableRefiner *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Transform = {"_p_IMP__core__Transform", "IMP::core::Transform *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TransformationAndReflectionSymmetry = {"_p_IMP__core__TransformationAndReflectionSymmetry", "IMP::core::TransformationAndReflectionSymmetry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TransformationSymmetry = {"_p_IMP__core__TransformationSymmetry", "IMP::core::TransformationSymmetry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TransformationSymmetryMover = {"_p_IMP__core__TransformationSymmetryMover", "IMP::core::TransformationSymmetryMover *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TransformedDistancePairScore = {"_p_IMP__core__TransformedDistancePairScore", "IMP::core::TransformedDistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TripletConstraint = {"_p_IMP__core__TripletConstraint", "IMP::core::TripletConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TripletRestraint = {"_p_IMP__core__TripletRestraint", "IMP::core::TripletRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_t = {"_p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_t", "IMP::core::TruncatedHarmonicBound *|IMP::core::TruncatedHarmonic< IMP::core::BOTH > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_t = {"_p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_t", "IMP::core::TruncatedHarmonicLowerBound *|IMP::core::TruncatedHarmonic< IMP::core::LOWER > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_t = {"_p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_t", "IMP::core::TruncatedHarmonicUpperBound *|IMP::core::TruncatedHarmonic< IMP::core::UPPER > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__Typed = {"_p_IMP__core__Typed", "IMP::core::Typed *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__TypedPairScore = {"_p_IMP__core__TypedPairScore", "IMP::core::TypedPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__UnorderedTypePairPredicate = {"_p_IMP__core__UnorderedTypePairPredicate", "IMP::core::UnorderedTypePairPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__UnorderedTypeQuadPredicate = {"_p_IMP__core__UnorderedTypeQuadPredicate", "IMP::core::UnorderedTypeQuadPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__UnorderedTypeSingletonPredicate = {"_p_IMP__core__UnorderedTypeSingletonPredicate", "IMP::core::UnorderedTypeSingletonPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__UnorderedTypeTripletPredicate = {"_p_IMP__core__UnorderedTypeTripletPredicate", "IMP::core::UnorderedTypeTripletPredicate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__VolumeRestraint = {"_p_IMP__core__VolumeRestraint", "IMP::core::VolumeRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__WeightedDerivativesToRefined = {"_p_IMP__core__WeightedDerivativesToRefined", "IMP::core::WeightedDerivativesToRefined *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__WeightedSphereDistancePairScore = {"_p_IMP__core__WeightedSphereDistancePairScore", "IMP::core::WeightedSphereDistancePairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__WeightedSum = {"_p_IMP__core__WeightedSum", "IMP::core::WeightedSum *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__WeightedSumOfExponential = {"_p_IMP__core__WeightedSumOfExponential", "IMP::core::WeightedSumOfExponential *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__WriteRestraintScoresOptimizerState = {"_p_IMP__core__WriteRestraintScoresOptimizerState", "IMP::core::WriteRestraintScoresOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__XYZ = {"_p_IMP__core__XYZ", "IMP::core::XYZ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__XYZDerivativeGeometry = {"_p_IMP__core__XYZDerivativeGeometry", "IMP::core::XYZDerivativeGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__XYZDerivativesGeometry = {"_p_IMP__core__XYZDerivativesGeometry", "IMP::core::XYZDerivativesGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__XYZR = {"_p_IMP__core__XYZR", "IMP::core::XYZR *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__XYZRGeometry = {"_p_IMP__core__XYZRGeometry", "IMP::core::XYZRGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__core__XYZRsGeometry = {"_p_IMP__core__XYZRsGeometry", "IMP::core::XYZRsGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__BoundingBoxGeometry = {"_p_IMP__display__BoundingBoxGeometry", "IMP::display::BoundingBoxGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__Color = {"_p_IMP__display__Color", "IMP::display::Color *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__Colored = {"_p_IMP__display__Colored", "IMP::display::Colored *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__CylinderGeometry = {"_p_IMP__display__CylinderGeometry", "IMP::display::CylinderGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__EllipsoidGeometry = {"_p_IMP__display__EllipsoidGeometry", "IMP::display::EllipsoidGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__FilterGeometry = {"_p_IMP__display__FilterGeometry", "IMP::display::FilterGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__Geometry = {"_p_IMP__display__Geometry", "IMP::display::Geometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__GeometrySet = {"_p_IMP__display__GeometrySet", "IMP::display::GeometrySet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__IsosurfaceGeometry = {"_p_IMP__display__IsosurfaceGeometry", "IMP::display::IsosurfaceGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__LabelGeometry = {"_p_IMP__display__LabelGeometry", "IMP::display::LabelGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__PairGeometry = {"_p_IMP__display__PairGeometry", "IMP::display::PairGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__PairsGeometry = {"_p_IMP__display__PairsGeometry", "IMP::display::PairsGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__PlaneGeometry = {"_p_IMP__display__PlaneGeometry", "IMP::display::PlaneGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__PointGeometry = {"_p_IMP__display__PointGeometry", "IMP::display::PointGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__PolygonGeometry = {"_p_IMP__display__PolygonGeometry", "IMP::display::PolygonGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__PymolWriter = {"_p_IMP__display__PymolWriter", "IMP::display::PymolWriter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__ReferenceFrameGeometry = {"_p_IMP__display__ReferenceFrameGeometry", "IMP::display::ReferenceFrameGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__RestraintGeometry = {"_p_IMP__display__RestraintGeometry", "IMP::display::RestraintGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__RestraintSetGeometry = {"_p_IMP__display__RestraintSetGeometry", "IMP::display::RestraintSetGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__SegmentGeometry = {"_p_IMP__display__SegmentGeometry", "IMP::display::SegmentGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__SingletonGeometry = {"_p_IMP__display__SingletonGeometry", "IMP::display::SingletonGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__SingletonsGeometry = {"_p_IMP__display__SingletonsGeometry", "IMP::display::SingletonsGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__SkinSurfaceGeometry = {"_p_IMP__display__SkinSurfaceGeometry", "IMP::display::SkinSurfaceGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__SphereGeometry = {"_p_IMP__display__SphereGeometry", "IMP::display::SphereGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__SurfaceMeshGeometry = {"_p_IMP__display__SurfaceMeshGeometry", "IMP::display::SurfaceMeshGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__TextWriter = {"_p_IMP__display__TextWriter", "IMP::display::TextWriter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__TriangleGeometry = {"_p_IMP__display__TriangleGeometry", "IMP::display::TriangleGeometry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__WriteOptimizerState = {"_p_IMP__display__WriteOptimizerState", "IMP::display::WriteOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__Writer = {"_p_IMP__display__Writer", "IMP::display::Writer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__display__WriterAdaptor = {"_p_IMP__display__WriterAdaptor", "IMP::display::WriterAdaptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__insulinsecretion__CaChannelOpeningOptimizerState = {"_p_IMP__insulinsecretion__CaChannelOpeningOptimizerState", "IMP::insulinsecretion::CaChannelOpeningOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__insulinsecretion__CaChannelStateDecorator = {"_p_IMP__insulinsecretion__CaChannelStateDecorator", "IMP::insulinsecretion::CaChannelStateDecorator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__insulinsecretion__DockingStateDecorator = {"_p_IMP__insulinsecretion__DockingStateDecorator", "IMP::insulinsecretion::DockingStateDecorator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__insulinsecretion__InsulinSecretionOptimizerState = {"_p_IMP__insulinsecretion__InsulinSecretionOptimizerState", "IMP::insulinsecretion::InsulinSecretionOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__insulinsecretion__MaturationStateDecorator = {"_p_IMP__insulinsecretion__MaturationStateDecorator", "IMP::insulinsecretion::MaturationStateDecorator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore = {"_p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore", "IMP::insulinsecretion::RadialDistributionFunctionSingletonScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__insulinsecretion__SecretionCounterDecorator = {"_p_IMP__insulinsecretion__SecretionCounterDecorator", "IMP::insulinsecretion::SecretionCounterDecorator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__insulinsecretion__VesicleDockingOptimizerState = {"_p_IMP__insulinsecretion__VesicleDockingOptimizerState", "IMP::insulinsecretion::VesicleDockingOptimizerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__insulinsecretion__VesicleTraffickingSingletonScore = {"_p_IMP__insulinsecretion__VesicleTraffickingSingletonScore", "IMP::insulinsecretion::VesicleTraffickingSingletonScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_t = {"_p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_t", "IMP::internal::BoostDigraph< IMP::DependencyGraph,IMP::ModelObject *,IMP::ShowDependencyGraphVertex > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal___ConstOptimizer = {"_p_IMP__internal___ConstOptimizer", "IMP::internal::_ConstOptimizer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal___ConstPairScore = {"_p_IMP__internal___ConstPairScore", "IMP::internal::_ConstPairScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal___ConstRestraint = {"_p_IMP__internal___ConstRestraint", "IMP::internal::_ConstRestraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal___ConstSingletonScore = {"_p_IMP__internal___ConstSingletonScore", "IMP::internal::_ConstSingletonScore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal___Protection = {"_p_IMP__internal___Protection", "IMP::internal::_Protection *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal___TestObject = {"_p_IMP__internal___TestObject", "IMP::internal::_TestObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal___TestValue = {"_p_IMP__internal___TestValue", "IMP::internal::_TestValue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal___TrivialDecorator = {"_p_IMP__internal___TrivialDecorator", "IMP::internal::_TrivialDecorator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal___TrivialDerivedDecorator = {"_p_IMP__internal___TrivialDerivedDecorator", "IMP::internal::_TrivialDerivedDecorator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__internal___TrivialTraitsDecorator = {"_p_IMP__internal___TrivialTraitsDecorator", "IMP::internal::_TrivialTraitsDecorator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__HarmonicLowerBound_t = {"_p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__HarmonicLowerBound_t", "IMP::core::SoftSurfaceDistanceScore *|IMP::score_functor::PointToSphereDistance< IMP::score_functor::HarmonicLowerBound > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t = {"_p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t", "IMP::core::HarmonicSurfaceDistanceScore *|IMP::score_functor::PointToSphereDistance< IMP::score_functor::Shift< IMP::score_functor::Harmonic > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t = {"_p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t", "IMP::core::PointToSphereDistanceScore *|IMP::score_functor::PointToSphereDistance< IMP::score_functor::UnaryFunctionEvaluate > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t = {"_p_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t", "IMP::core::HarmonicDistanceScore *|IMP::score_functor::Shift< IMP::score_functor::Harmonic > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__HarmonicLowerBound_t = {"_p_IMP__score_functor__SphereDistanceT_IMP__score_functor__HarmonicLowerBound_t", "IMP::core::SoftSphereDistanceScore *|IMP::score_functor::SphereDistance< IMP::score_functor::HarmonicLowerBound > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__HarmonicUpperBound_t_t = {"_p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__HarmonicUpperBound_t_t", "IMP::core::HarmonicUpperBoundSphereDistanceScore *|IMP::score_functor::SphereDistance< IMP::score_functor::Shift< IMP::score_functor::HarmonicUpperBound > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t = {"_p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t", "IMP::core::HarmonicSphereDistanceScore *|IMP::score_functor::SphereDistance< IMP::score_functor::Shift< IMP::score_functor::Harmonic > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t = {"_p_IMP__score_functor__SphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t", "IMP::core::SphereDistanceScore *|IMP::score_functor::SphereDistance< IMP::score_functor::UnaryFunctionEvaluate > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Index = {"_p_Index", "Index *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IndexArgument = {"_p_IndexArgument", "IndexArgument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Modifier = {"_p_Modifier", "Modifier *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_P = {"_p_P", "P *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ParentDecorator = {"_p_ParentDecorator", "ParentDecorator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PassContainedIndexType = {"_p_PassContainedIndexType", "PassContainedIndexType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PassIndexArgument = {"_p_PassIndexArgument", "PassIndexArgument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ScoreIsGoodPair = {"_p_ScoreIsGoodPair", "ScoreIsGoodPair *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_VertexDescriptor = {"_p_VertexDescriptor", "VertexDescriptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_VertexDescriptors = {"_p_VertexDescriptors", "VertexDescriptors *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_VertexName = {"_p_VertexName", "VertexName *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "IMP::Float *|double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_first_type = {"_p_first_type", "first_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "IMP::Int *|int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_second_type = {"_p_second_type", "second_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_t = {"_p_size_t", "boost::multi_array_types::difference_type *|boost::multi_array_types::size_type *|size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__invalid_argument = {"_p_std__invalid_argument", "std::invalid_argument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ostream = {"_p_std__ostream", "std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_IMP__algebra__VectorDT_3_t_IMP__algebra__VectorDT_4_t_t = {"_p_std__pairT_IMP__algebra__VectorDT_3_t_IMP__algebra__VectorDT_4_t_t", "IMP::algebra::RotatedVector3DAdjoint *|std::pair< IMP::algebra::VectorD< 3 >,IMP::algebra::VectorD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_IMP__algebra__VectorDT_3_t_double_t = {"_p_std__pairT_IMP__algebra__VectorDT_3_t_double_t", "IMP::algebra::AxisAnglePair *|std::pair< IMP::algebra::VectorD< 3 >,double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_IMP__algebra__VectorDT_3_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t = {"_p_std__pairT_IMP__algebra__VectorDT_3_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t", "IMP::algebra::TransformedVector3DAdjoint *|std::pair< IMP::algebra::VectorD< 3 >,std::pair< IMP::algebra::VectorD< 4 >,IMP::algebra::VectorD< 3 > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t = {"_p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t", "IMP::algebra::Transformation3DAdjoint *|std::pair< IMP::algebra::VectorD< 4 >,IMP::algebra::VectorD< 3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_4_t_t = {"_p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_4_t_t", "IMP::algebra::ComposeRotation3DAdjoint *|std::pair< IMP::algebra::VectorD< 4 >,IMP::algebra::VectorD< 4 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_double_double_t = {"_p_std__pairT_double_double_t", "IMP::DerivativePair *|IMP::FloatPair *|IMP::FloatRange *|std::pair< double,double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_int_int_t = {"_p_std__pairT_int_int_t", "IMP::IntPair *|IMP::IntRange *|std::pair< int,int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t = {"_p_std__pairT_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t", "IMP::algebra::ComposeTransformation3DAdjoint *|std::pair< std::pair< IMP::algebra::VectorD< 4 >,IMP::algebra::VectorD< 3 > >,std::pair< IMP::algebra::VectorD< 4 >,IMP::algebra::VectorD< 3 > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "IMP::String *|std::string *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__IMP_INSULINSECRETION_SwigPyIterator = {"_p_swig__IMP_INSULINSECRETION_SwigPyIterator", "swig::IMP_INSULINSECRETION_SwigPyIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32_t *|unsigned int *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Argument,
  &_swigt__p_ContainedIndexType,
  &_swigt__p_ContainedIndexTypes,
  &_swigt__p_ContainedType,
  &_swigt__p_ContainedTypes,
  &_swigt__p_DecoratorHasTraits,
  &_swigt__p_DecoratorTraits,
  &_swigt__p_Eigen__ArrayXXd,
  &_swigt__p_Eigen__ArrayXXf,
  &_swigt__p_Eigen__Matrix3d,
  &_swigt__p_Eigen__MatrixXd,
  &_swigt__p_Eigen__MatrixXf,
  &_swigt__p_Eigen__Vector3d,
  &_swigt__p_Eigen__VectorXd,
  &_swigt__p_Eigen__VectorXf,
  &_swigt__p_ExtendedIndex,
  &_swigt__p_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t,
  &_swigt__p_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t,
  &_swigt__p_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t,
  &_swigt__p_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t,
  &_swigt__p_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t,
  &_swigt__p_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t,
  &_swigt__p_IMP__AttributeOptimizer,
  &_swigt__p_IMP__CheckLevel,
  &_swigt__p_IMP__Configuration,
  &_swigt__p_IMP__ConfigurationSet,
  &_swigt__p_IMP__Constraint,
  &_swigt__p_IMP__Container,
  &_swigt__p_IMP__CreateLogContext,
  &_swigt__p_IMP__Decorator,
  &_swigt__p_IMP__DerivativeAccumulator,
  &_swigt__p_IMP__EvaluationState,
  &_swigt__p_IMP__FloatIndex,
  &_swigt__p_IMP__IndexT_IMP__ParticleIndexTag_t,
  &_swigt__p_IMP__KeyT_0_t,
  &_swigt__p_IMP__KeyT_10_t,
  &_swigt__p_IMP__KeyT_11_t,
  &_swigt__p_IMP__KeyT_12_t,
  &_swigt__p_IMP__KeyT_13_t,
  &_swigt__p_IMP__KeyT_14_t,
  &_swigt__p_IMP__KeyT_15_t,
  &_swigt__p_IMP__KeyT_1_t,
  &_swigt__p_IMP__KeyT_2_t,
  &_swigt__p_IMP__KeyT_34897493_t,
  &_swigt__p_IMP__KeyT_3_t,
  &_swigt__p_IMP__KeyT_4_t,
  &_swigt__p_IMP__KeyT_5_t,
  &_swigt__p_IMP__KeyT_6_t,
  &_swigt__p_IMP__KeyT_7_t,
  &_swigt__p_IMP__KeyT_8_t,
  &_swigt__p_IMP__KeyT_9_t,
  &_swigt__p_IMP__Model,
  &_swigt__p_IMP__ModelObject,
  &_swigt__p_IMP__NonCopyable,
  &_swigt__p_IMP__Object,
  &_swigt__p_IMP__Optimizer,
  &_swigt__p_IMP__OptimizerState,
  &_swigt__p_IMP__PairContainer,
  &_swigt__p_IMP__PairModifier,
  &_swigt__p_IMP__PairPredicate,
  &_swigt__p_IMP__PairScore,
  &_swigt__p_IMP__Particle,
  &_swigt__p_IMP__ParticleAdaptor,
  &_swigt__p_IMP__ParticleIndexesAdaptor,
  &_swigt__p_IMP__ParticleInputs,
  &_swigt__p_IMP__QuadContainer,
  &_swigt__p_IMP__QuadModifier,
  &_swigt__p_IMP__QuadPredicate,
  &_swigt__p_IMP__QuadScore,
  &_swigt__p_IMP__RAII,
  &_swigt__p_IMP__Refiner,
  &_swigt__p_IMP__Restraint,
  &_swigt__p_IMP__RestraintInfo,
  &_swigt__p_IMP__RestraintSet,
  &_swigt__p_IMP__Sampler,
  &_swigt__p_IMP__SaveToConfigurationSetOptimizerState,
  &_swigt__p_IMP__ScopedSetAttributeT_IMP__KeyT_0_t_double_t,
  &_swigt__p_IMP__ScoreAccumulator,
  &_swigt__p_IMP__ScoreState,
  &_swigt__p_IMP__ScoringFunction,
  &_swigt__p_IMP__SetCheckState,
  &_swigt__p_IMP__SetLogState,
  &_swigt__p_IMP__SetLogTarget,
  &_swigt__p_IMP__SetNumberOfThreads,
  &_swigt__p_IMP__SingletonContainer,
  &_swigt__p_IMP__SingletonContainerAdaptor,
  &_swigt__p_IMP__SingletonModifier,
  &_swigt__p_IMP__SingletonPredicate,
  &_swigt__p_IMP__SingletonScore,
  &_swigt__p_IMP__TripletContainer,
  &_swigt__p_IMP__TripletModifier,
  &_swigt__p_IMP__TripletPredicate,
  &_swigt__p_IMP__TripletScore,
  &_swigt__p_IMP__UnaryFunction,
  &_swigt__p_IMP__Undecorator,
  &_swigt__p_IMP__Value,
  &_swigt__p_IMP__VectorT_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t,
  &_swigt__p_IMP__VectorT_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t,
  &_swigt__p_IMP__VectorT_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t,
  &_swigt__p_IMP__VectorT_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t,
  &_swigt__p_IMP__VectorT_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t,
  &_swigt__p_IMP__VectorT_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t,
  &_swigt__p_IMP__VectorT_IMP__DerivativeAccumulator_t,
  &_swigt__p_IMP__VectorT_IMP__EvaluationState_t,
  &_swigt__p_IMP__VectorT_IMP__FloatIndex_t,
  &_swigt__p_IMP__VectorT_IMP__IndexT_IMP__ParticleIndexTag_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_0_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_10_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_11_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_12_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_13_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_14_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_15_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_34897493_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_7_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_8_t_t,
  &_swigt__p_IMP__VectorT_IMP__KeyT_9_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__AttributeOptimizer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__ConfigurationSet_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Configuration_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Constraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Container_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__ModelObject_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Model_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Object_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__OptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Optimizer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairModifier_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairPredicate_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadModifier_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadPredicate_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Refiner_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__RestraintSet_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Restraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Sampler_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__ScoreState_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__ScoringFunction_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonModifier_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonPredicate_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletModifier_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletPredicate_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__UnaryFunction_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Undecorator_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__algebra__VectorKDMetric_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__AllBipartitePairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__AllPairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ClosePairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ConnectingPairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ConsecutivePairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListPairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListQuadContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListSingletonContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListTripletContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerPairFilter_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerQuadFilter_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerSingletonFilter_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerTripletFilter_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListPairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListQuadContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListSingletonContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListTripletContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumPairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumQuadScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumSingletonScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumTripletScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsConstraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsRestraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsConstraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsRestraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsConstraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsRestraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsConstraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsRestraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__DistancePairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicDistancePairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicWell_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__MonteCarloMover_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometryConstraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometry_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__display__Geometry_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__display__TextWriter_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__display__Writer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstOptimizer_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstPairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstRestraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstSingletonScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__ScoreAccumulator_t,
  &_swigt__p_IMP__VectorT_IMP__SetCheckState_t,
  &_swigt__p_IMP__VectorT_IMP__SetLogState_t,
  &_swigt__p_IMP__VectorT_IMP__TextInput_t,
  &_swigt__p_IMP__VectorT_IMP__TextOutput_t,
  &_swigt__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_double_t_t_t,
  &_swigt__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_int_t_t_t,
  &_swigt__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_std__string_t_t_t,
  &_swigt__p_IMP__VectorT_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t_t,
  &_swigt__p_IMP__VectorT_IMP__VectorT_WeakPointerT_IMP__Particle_t_t_t,
  &_swigt__p_IMP__VectorT_IMP__VectorT_double_t_t,
  &_swigt__p_IMP__VectorT_IMP__VectorT_int_t_t,
  &_swigt__p_IMP__VectorT_IMP__VectorT_std__pairT_double_double_t_t_t,
  &_swigt__p_IMP__VectorT_IMP__VectorT_std__pairT_int_int_t_t_t,
  &_swigt__p_IMP__VectorT_IMP__VectorT_std__string_t_t,
  &_swigt__p_IMP__VectorT_IMP__VersionInfo_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__AttributeOptimizer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ConfigurationSet_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Configuration_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Constraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Container_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Model_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Object_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__OptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Optimizer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairModifier_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairPredicate_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadModifier_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadPredicate_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Refiner_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__RestraintSet_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Restraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Sampler_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoreState_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoringFunction_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonModifier_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonPredicate_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletModifier_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletPredicate_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__UnaryFunction_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Undecorator_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__algebra__VectorKDMetric_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllBipartitePairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllPairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ClosePairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConnectingPairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConsecutivePairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListPairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListQuadContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListSingletonContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListTripletContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerPairFilter_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerQuadFilter_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerSingletonFilter_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerTripletFilter_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListPairContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListQuadContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListSingletonContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListTripletContainer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumPairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumQuadScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumSingletonScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumTripletScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsConstraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsRestraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsConstraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsRestraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsConstraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsRestraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsConstraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsRestraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__DistancePairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicDistancePairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicWell_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__MonteCarloMover_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometryConstraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometry_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Geometry_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__TextWriter_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Writer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstOptimizer_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstPairScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstRestraint_t_t,
  &_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstSingletonScore_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Cone3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__ConnollySurfacePoint_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Cylinder3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Ellipsoid3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__FixedXYZ_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Gaussian3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Line3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__LinearFit2D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__ParabolicFit2D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Plane3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__ReferenceFrame3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Reflection3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Rotation2D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Rotation3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Segment3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__SphereDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__SpherePatch3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__SphericalVector3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Transformation2D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Transformation3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__Triangle3D_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_1_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_2_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_3_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_4_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_5_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_6_t_t,
  &_swigt__p_IMP__VectorT_IMP__algebra__VectorDT__1_t_t,
  &_swigt__p_IMP__VectorT_IMP__core__BinormalTerm_t,
  &_swigt__p_IMP__VectorT_IMP__core__Centroid_t,
  &_swigt__p_IMP__VectorT_IMP__core__Cover_t,
  &_swigt__p_IMP__VectorT_IMP__core__DirectionAngle_t,
  &_swigt__p_IMP__VectorT_IMP__core__Direction_t,
  &_swigt__p_IMP__VectorT_IMP__core__Gaussian_t,
  &_swigt__p_IMP__VectorT_IMP__core__HierarchyCounter_t,
  &_swigt__p_IMP__VectorT_IMP__core__HierarchyTraits_t,
  &_swigt__p_IMP__VectorT_IMP__core__Hierarchy_t,
  &_swigt__p_IMP__VectorT_IMP__core__MonteCarloMoverResult_t,
  &_swigt__p_IMP__VectorT_IMP__core__Reference_t,
  &_swigt__p_IMP__VectorT_IMP__core__RigidBodyMember_t,
  &_swigt__p_IMP__VectorT_IMP__core__RigidBody_t,
  &_swigt__p_IMP__VectorT_IMP__core__RigidMember_t,
  &_swigt__p_IMP__VectorT_IMP__core__Surface_t,
  &_swigt__p_IMP__VectorT_IMP__core__Typed_t,
  &_swigt__p_IMP__VectorT_IMP__core__XYZR_t,
  &_swigt__p_IMP__VectorT_IMP__core__XYZ_t,
  &_swigt__p_IMP__VectorT_IMP__display__Color_t,
  &_swigt__p_IMP__VectorT_IMP__display__Colored_t,
  &_swigt__p_IMP__VectorT_IMP__display__GeometryProcessor_t,
  &_swigt__p_IMP__VectorT_IMP__display__WriterAdaptor_t,
  &_swigt__p_IMP__VectorT_IMP__internal___Protection_t,
  &_swigt__p_IMP__VectorT_IMP__internal___TestValue_t,
  &_swigt__p_IMP__VectorT_IMP__internal___TrivialDecorator_t,
  &_swigt__p_IMP__VectorT_IMP__internal___TrivialDerivedDecorator_t,
  &_swigt__p_IMP__VectorT_IMP__internal___TrivialTraitsDecorator_t,
  &_swigt__p_IMP__VectorT_PointerT_IMP__Particle_t_t,
  &_swigt__p_IMP__VectorT_WeakPointerT_IMP__Particle_t_t,
  &_swigt__p_IMP__VectorT_double_t,
  &_swigt__p_IMP__VectorT_int_t,
  &_swigt__p_IMP__VectorT_std__pairT_IMP__algebra__VectorDT_3_t_double_t_t,
  &_swigt__p_IMP__VectorT_std__pairT_double_double_t_t,
  &_swigt__p_IMP__VectorT_std__pairT_int_int_t_t,
  &_swigt__p_IMP__VectorT_std__string_t,
  &_swigt__p_IMP__VersionInfo,
  &_swigt__p_IMP__WarningContext,
  &_swigt__p_IMP__algebra__BoundedGridRangeDT_1_t,
  &_swigt__p_IMP__algebra__BoundedGridRangeDT_2_t,
  &_swigt__p_IMP__algebra__BoundedGridRangeDT_3_t,
  &_swigt__p_IMP__algebra__BoundedGridRangeDT_4_t,
  &_swigt__p_IMP__algebra__BoundedGridRangeDT_5_t,
  &_swigt__p_IMP__algebra__BoundedGridRangeDT_6_t,
  &_swigt__p_IMP__algebra__BoundedGridRangeDT__1_t,
  &_swigt__p_IMP__algebra__BoundingBoxDT_1_t,
  &_swigt__p_IMP__algebra__BoundingBoxDT_2_t,
  &_swigt__p_IMP__algebra__BoundingBoxDT_3_t,
  &_swigt__p_IMP__algebra__BoundingBoxDT_4_t,
  &_swigt__p_IMP__algebra__BoundingBoxDT_5_t,
  &_swigt__p_IMP__algebra__BoundingBoxDT_6_t,
  &_swigt__p_IMP__algebra__BoundingBoxDT__1_t,
  &_swigt__p_IMP__algebra__Cone3D,
  &_swigt__p_IMP__algebra__ConnollySurfacePoint,
  &_swigt__p_IMP__algebra__Cylinder3D,
  &_swigt__p_IMP__algebra__DefaultEmbeddingDT_1_t,
  &_swigt__p_IMP__algebra__DefaultEmbeddingDT_2_t,
  &_swigt__p_IMP__algebra__DefaultEmbeddingDT_3_t,
  &_swigt__p_IMP__algebra__DefaultEmbeddingDT_4_t,
  &_swigt__p_IMP__algebra__DefaultEmbeddingDT_5_t,
  &_swigt__p_IMP__algebra__DefaultEmbeddingDT_6_t,
  &_swigt__p_IMP__algebra__DefaultEmbeddingDT__1_t,
  &_swigt__p_IMP__algebra__DynamicNearestNeighbor3D,
  &_swigt__p_IMP__algebra__Ellipsoid3D,
  &_swigt__p_IMP__algebra__EuclideanVectorKDMetric,
  &_swigt__p_IMP__algebra__ExtendedGridIndexDT_1_t,
  &_swigt__p_IMP__algebra__ExtendedGridIndexDT_2_t,
  &_swigt__p_IMP__algebra__ExtendedGridIndexDT_3_t,
  &_swigt__p_IMP__algebra__ExtendedGridIndexDT_4_t,
  &_swigt__p_IMP__algebra__ExtendedGridIndexDT_5_t,
  &_swigt__p_IMP__algebra__ExtendedGridIndexDT_6_t,
  &_swigt__p_IMP__algebra__ExtendedGridIndexDT__1_t,
  &_swigt__p_IMP__algebra__FixedXYZ,
  &_swigt__p_IMP__algebra__Gaussian3D,
  &_swigt__p_IMP__algebra__GeometricPrimitiveDT_1_t,
  &_swigt__p_IMP__algebra__GeometricPrimitiveDT_2_t,
  &_swigt__p_IMP__algebra__GeometricPrimitiveDT_3_t,
  &_swigt__p_IMP__algebra__GeometricPrimitiveDT_4_t,
  &_swigt__p_IMP__algebra__GeometricPrimitiveDT_5_t,
  &_swigt__p_IMP__algebra__GeometricPrimitiveDT_6_t,
  &_swigt__p_IMP__algebra__GeometricPrimitiveDT__1_t,
  &_swigt__p_IMP__algebra__GridIndexDT_1_t,
  &_swigt__p_IMP__algebra__GridIndexDT_2_t,
  &_swigt__p_IMP__algebra__GridIndexDT_3_t,
  &_swigt__p_IMP__algebra__GridIndexDT_4_t,
  &_swigt__p_IMP__algebra__GridIndexDT_5_t,
  &_swigt__p_IMP__algebra__GridIndexDT_6_t,
  &_swigt__p_IMP__algebra__GridIndexDT__1_t,
  &_swigt__p_IMP__algebra__Line3D,
  &_swigt__p_IMP__algebra__LinearFit2D,
  &_swigt__p_IMP__algebra__LogEmbeddingDT_1_t,
  &_swigt__p_IMP__algebra__LogEmbeddingDT_2_t,
  &_swigt__p_IMP__algebra__LogEmbeddingDT_3_t,
  &_swigt__p_IMP__algebra__LogEmbeddingDT_4_t,
  &_swigt__p_IMP__algebra__LogEmbeddingDT_5_t,
  &_swigt__p_IMP__algebra__LogEmbeddingDT_6_t,
  &_swigt__p_IMP__algebra__LogEmbeddingDT__1_t,
  &_swigt__p_IMP__algebra__MaxVectorKDMetric,
  &_swigt__p_IMP__algebra__NearestNeighborDT_1_t,
  &_swigt__p_IMP__algebra__NearestNeighborDT_2_t,
  &_swigt__p_IMP__algebra__NearestNeighborDT_3_t,
  &_swigt__p_IMP__algebra__NearestNeighborDT_4_t,
  &_swigt__p_IMP__algebra__NearestNeighborDT_5_t,
  &_swigt__p_IMP__algebra__NearestNeighborDT_6_t,
  &_swigt__p_IMP__algebra__NearestNeighborDT__1_t,
  &_swigt__p_IMP__algebra__ParabolicFit2D,
  &_swigt__p_IMP__algebra__Plane3D,
  &_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_1_t,
  &_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_2_t,
  &_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_3_t,
  &_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_4_t,
  &_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_5_t,
  &_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_6_t,
  &_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT__1_t,
  &_swigt__p_IMP__algebra__ReferenceFrame3D,
  &_swigt__p_IMP__algebra__Reflection3D,
  &_swigt__p_IMP__algebra__Rotation2D,
  &_swigt__p_IMP__algebra__Rotation3D,
  &_swigt__p_IMP__algebra__Segment3D,
  &_swigt__p_IMP__algebra__SphereDT_1_t,
  &_swigt__p_IMP__algebra__SphereDT_2_t,
  &_swigt__p_IMP__algebra__SphereDT_3_t,
  &_swigt__p_IMP__algebra__SphereDT_4_t,
  &_swigt__p_IMP__algebra__SphereDT_5_t,
  &_swigt__p_IMP__algebra__SphereDT_6_t,
  &_swigt__p_IMP__algebra__SphereDT__1_t,
  &_swigt__p_IMP__algebra__SpherePatch3D,
  &_swigt__p_IMP__algebra__SphericalVector3D,
  &_swigt__p_IMP__algebra__Transformation2D,
  &_swigt__p_IMP__algebra__Transformation3D,
  &_swigt__p_IMP__algebra__Triangle3D,
  &_swigt__p_IMP__algebra__UnboundedGridRangeDT_1_t,
  &_swigt__p_IMP__algebra__UnboundedGridRangeDT_2_t,
  &_swigt__p_IMP__algebra__UnboundedGridRangeDT_3_t,
  &_swigt__p_IMP__algebra__UnboundedGridRangeDT_4_t,
  &_swigt__p_IMP__algebra__UnboundedGridRangeDT_5_t,
  &_swigt__p_IMP__algebra__UnboundedGridRangeDT_6_t,
  &_swigt__p_IMP__algebra__UnboundedGridRangeDT__1_t,
  &_swigt__p_IMP__algebra__UnitSimplexBaseDT_1_t,
  &_swigt__p_IMP__algebra__UnitSimplexBaseDT_2_t,
  &_swigt__p_IMP__algebra__UnitSimplexBaseDT_3_t,
  &_swigt__p_IMP__algebra__UnitSimplexBaseDT_4_t,
  &_swigt__p_IMP__algebra__UnitSimplexBaseDT_5_t,
  &_swigt__p_IMP__algebra__UnitSimplexBaseDT_6_t,
  &_swigt__p_IMP__algebra__UnitSimplexBaseDT__1_t,
  &_swigt__p_IMP__algebra__UnitSimplexDT_1_t,
  &_swigt__p_IMP__algebra__UnitSimplexDT_2_t,
  &_swigt__p_IMP__algebra__UnitSimplexDT_3_t,
  &_swigt__p_IMP__algebra__UnitSimplexDT_4_t,
  &_swigt__p_IMP__algebra__UnitSimplexDT_5_t,
  &_swigt__p_IMP__algebra__UnitSimplexDT_6_t,
  &_swigt__p_IMP__algebra__UnitSimplexDT__1_t,
  &_swigt__p_IMP__algebra__VectorBaseDT_1_t,
  &_swigt__p_IMP__algebra__VectorBaseDT_2_t,
  &_swigt__p_IMP__algebra__VectorBaseDT_3_t,
  &_swigt__p_IMP__algebra__VectorBaseDT_4_t,
  &_swigt__p_IMP__algebra__VectorBaseDT_5_t,
  &_swigt__p_IMP__algebra__VectorBaseDT_6_t,
  &_swigt__p_IMP__algebra__VectorBaseDT__1_t,
  &_swigt__p_IMP__algebra__VectorDT_1_t,
  &_swigt__p_IMP__algebra__VectorDT_2_t,
  &_swigt__p_IMP__algebra__VectorDT_3_t,
  &_swigt__p_IMP__algebra__VectorDT_4_t,
  &_swigt__p_IMP__algebra__VectorDT_5_t,
  &_swigt__p_IMP__algebra__VectorDT_6_t,
  &_swigt__p_IMP__algebra__VectorDT__1_t,
  &_swigt__p_IMP__algebra__VectorKDMetric,
  &_swigt__p_IMP__container__AllBipartitePairContainer,
  &_swigt__p_IMP__container__AllPairContainer,
  &_swigt__p_IMP__container__CloseBipartitePairContainer,
  &_swigt__p_IMP__container__ClosePairContainer,
  &_swigt__p_IMP__container__ConnectingPairContainer,
  &_swigt__p_IMP__container__ConsecutivePairContainer,
  &_swigt__p_IMP__container__ConsecutivePairFilter,
  &_swigt__p_IMP__container__DistributePairsScoreState,
  &_swigt__p_IMP__container__DistributeQuadsScoreState,
  &_swigt__p_IMP__container__DistributeSingletonsScoreState,
  &_swigt__p_IMP__container__DistributeTripletsScoreState,
  &_swigt__p_IMP__container__DynamicListPairContainer,
  &_swigt__p_IMP__container__DynamicListQuadContainer,
  &_swigt__p_IMP__container__DynamicListSingletonContainer,
  &_swigt__p_IMP__container__DynamicListTripletContainer,
  &_swigt__p_IMP__container__EventPairsOptimizerState,
  &_swigt__p_IMP__container__EventQuadsOptimizerState,
  &_swigt__p_IMP__container__EventSingletonsOptimizerState,
  &_swigt__p_IMP__container__EventTripletsOptimizerState,
  &_swigt__p_IMP__container__ExclusiveConsecutivePairContainer,
  &_swigt__p_IMP__container__ExclusiveConsecutivePairFilter,
  &_swigt__p_IMP__container__InContainerPairFilter,
  &_swigt__p_IMP__container__InContainerQuadFilter,
  &_swigt__p_IMP__container__InContainerSingletonFilter,
  &_swigt__p_IMP__container__InContainerTripletFilter,
  &_swigt__p_IMP__container__ListPairContainer,
  &_swigt__p_IMP__container__ListQuadContainer,
  &_swigt__p_IMP__container__ListSingletonContainer,
  &_swigt__p_IMP__container__ListTripletContainer,
  &_swigt__p_IMP__container__MinimumPairRestraint,
  &_swigt__p_IMP__container__MinimumPairScore,
  &_swigt__p_IMP__container__MinimumQuadRestraint,
  &_swigt__p_IMP__container__MinimumQuadScore,
  &_swigt__p_IMP__container__MinimumSingletonRestraint,
  &_swigt__p_IMP__container__MinimumSingletonScore,
  &_swigt__p_IMP__container__MinimumTripletRestraint,
  &_swigt__p_IMP__container__MinimumTripletScore,
  &_swigt__p_IMP__container__PairContainerSet,
  &_swigt__p_IMP__container__PairContainerStatistics,
  &_swigt__p_IMP__container__PairsConstraint,
  &_swigt__p_IMP__container__PairsOptimizerState,
  &_swigt__p_IMP__container__PairsRestraint,
  &_swigt__p_IMP__container__PredicatePairsRestraint,
  &_swigt__p_IMP__container__PredicateQuadsRestraint,
  &_swigt__p_IMP__container__PredicateSingletonsRestraint,
  &_swigt__p_IMP__container__PredicateTripletsRestraint,
  &_swigt__p_IMP__container__QuadContainerSet,
  &_swigt__p_IMP__container__QuadContainerStatistics,
  &_swigt__p_IMP__container__QuadsConstraint,
  &_swigt__p_IMP__container__QuadsOptimizerState,
  &_swigt__p_IMP__container__QuadsRestraint,
  &_swigt__p_IMP__container__SingletonContainerSet,
  &_swigt__p_IMP__container__SingletonContainerStatistics,
  &_swigt__p_IMP__container__SingletonsConstraint,
  &_swigt__p_IMP__container__SingletonsOptimizerState,
  &_swigt__p_IMP__container__SingletonsRestraint,
  &_swigt__p_IMP__container__TripletContainerSet,
  &_swigt__p_IMP__container__TripletContainerStatistics,
  &_swigt__p_IMP__container__TripletsConstraint,
  &_swigt__p_IMP__container__TripletsOptimizerState,
  &_swigt__p_IMP__container__TripletsRestraint,
  &_swigt__p_IMP__core__AllSamePairPredicate,
  &_swigt__p_IMP__core__AllSameQuadPredicate,
  &_swigt__p_IMP__core__AllSameSingletonPredicate,
  &_swigt__p_IMP__core__AllSameTripletPredicate,
  &_swigt__p_IMP__core__AngleRestraint,
  &_swigt__p_IMP__core__AngleTripletScore,
  &_swigt__p_IMP__core__AttributeSingletonPredicate,
  &_swigt__p_IMP__core__BallMover,
  &_swigt__p_IMP__core__BinormalTerm,
  &_swigt__p_IMP__core__BoxSweepClosePairsFinder,
  &_swigt__p_IMP__core__Centroid,
  &_swigt__p_IMP__core__CentroidOfRefined,
  &_swigt__p_IMP__core__ChecksScoreState,
  &_swigt__p_IMP__core__ChildrenRefiner,
  &_swigt__p_IMP__core__ClosePairsFinder,
  &_swigt__p_IMP__core__ClosePairsPairScore,
  &_swigt__p_IMP__core__ClosedCubicSpline,
  &_swigt__p_IMP__core__ClusterProvenance,
  &_swigt__p_IMP__core__CoinFlipPairPredicate,
  &_swigt__p_IMP__core__CoinFlipQuadPredicate,
  &_swigt__p_IMP__core__CoinFlipSingletonPredicate,
  &_swigt__p_IMP__core__CoinFlipTripletPredicate,
  &_swigt__p_IMP__core__CombineProvenance,
  &_swigt__p_IMP__core__ConjugateGradients,
  &_swigt__p_IMP__core__ConnectivityRestraint,
  &_swigt__p_IMP__core__ConstantPairPredicate,
  &_swigt__p_IMP__core__ConstantQuadPredicate,
  &_swigt__p_IMP__core__ConstantRestraint,
  &_swigt__p_IMP__core__ConstantSingletonPredicate,
  &_swigt__p_IMP__core__ConstantTripletPredicate,
  &_swigt__p_IMP__core__Cosine,
  &_swigt__p_IMP__core__Cover,
  &_swigt__p_IMP__core__CoverRefined,
  &_swigt__p_IMP__core__DerivativesFromRefined,
  &_swigt__p_IMP__core__DerivativesToRefined,
  &_swigt__p_IMP__core__DiameterRestraint,
  &_swigt__p_IMP__core__DihedralRestraint,
  &_swigt__p_IMP__core__Direction,
  &_swigt__p_IMP__core__DirectionAngle,
  &_swigt__p_IMP__core__DirectionMover,
  &_swigt__p_IMP__core__DistancePairScore,
  &_swigt__p_IMP__core__DistanceRestraint,
  &_swigt__p_IMP__core__EdgePairGeometry,
  &_swigt__p_IMP__core__EdgePairsGeometry,
  &_swigt__p_IMP__core__ExcludedVolumeRestraint,
  &_swigt__p_IMP__core__FilterProvenance,
  &_swigt__p_IMP__core__FixedRefiner,
  &_swigt__p_IMP__core__Gaussian,
  &_swigt__p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t,
  &_swigt__p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t,
  &_swigt__p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t,
  &_swigt__p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t,
  &_swigt__p_IMP__core__GridClosePairsFinder,
  &_swigt__p_IMP__core__Harmonic,
  &_swigt__p_IMP__core__HarmonicDistancePairScore,
  &_swigt__p_IMP__core__HarmonicLowerBound,
  &_swigt__p_IMP__core__HarmonicSphereDistancePairScore,
  &_swigt__p_IMP__core__HarmonicSurfaceDepthPairScore,
  &_swigt__p_IMP__core__HarmonicSurfaceDistancePairScore,
  &_swigt__p_IMP__core__HarmonicSurfaceHeightPairScore,
  &_swigt__p_IMP__core__HarmonicUpperBound,
  &_swigt__p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore,
  &_swigt__p_IMP__core__HarmonicUpperBoundSphereDistancePairScore,
  &_swigt__p_IMP__core__HarmonicWell,
  &_swigt__p_IMP__core__Hierarchy,
  &_swigt__p_IMP__core__HierarchyCounter,
  &_swigt__p_IMP__core__HierarchyTraits,
  &_swigt__p_IMP__core__InBoundingBox3DSingletonPredicate,
  &_swigt__p_IMP__core__IsCollisionPairPredicate,
  &_swigt__p_IMP__core__KClosePairsPairScore,
  &_swigt__p_IMP__core__LateralSurfaceConstraint,
  &_swigt__p_IMP__core__LeavesRefiner,
  &_swigt__p_IMP__core__Linear,
  &_swigt__p_IMP__core__LogNormalMover,
  &_swigt__p_IMP__core__MCCGSampler,
  &_swigt__p_IMP__core__MSConnectivityRestraint,
  &_swigt__p_IMP__core__MinimumRestraint,
  &_swigt__p_IMP__core__MonteCarlo,
  &_swigt__p_IMP__core__MonteCarloMover,
  &_swigt__p_IMP__core__MonteCarloMoverResult,
  &_swigt__p_IMP__core__MonteCarloWithBasinHopping,
  &_swigt__p_IMP__core__MonteCarloWithLocalOptimization,
  &_swigt__p_IMP__core__MoveStatisticsScoreState,
  &_swigt__p_IMP__core__MultipleBinormalRestraint,
  &_swigt__p_IMP__core__NearestNeighborsClosePairsFinder,
  &_swigt__p_IMP__core__NeighborsTable,
  &_swigt__p_IMP__core__NonRigidMember,
  &_swigt__p_IMP__core__NormalMover,
  &_swigt__p_IMP__core__NormalizedSphereDistancePairScore,
  &_swigt__p_IMP__core__OpenCubicSpline,
  &_swigt__p_IMP__core__OrderedTypePairPredicate,
  &_swigt__p_IMP__core__OrderedTypeQuadPredicate,
  &_swigt__p_IMP__core__OrderedTypeSingletonPredicate,
  &_swigt__p_IMP__core__OrderedTypeTripletPredicate,
  &_swigt__p_IMP__core__PairConstraint,
  &_swigt__p_IMP__core__PairRestraint,
  &_swigt__p_IMP__core__Provenance,
  &_swigt__p_IMP__core__Provenanced,
  &_swigt__p_IMP__core__QuadConstraint,
  &_swigt__p_IMP__core__QuadRestraint,
  &_swigt__p_IMP__core__QuadraticClosePairsFinder,
  &_swigt__p_IMP__core__Reference,
  &_swigt__p_IMP__core__RefinedPairsPairScore,
  &_swigt__p_IMP__core__RestraintsScoringFunction,
  &_swigt__p_IMP__core__RigidBody,
  &_swigt__p_IMP__core__RigidBodyAnglePairScore,
  &_swigt__p_IMP__core__RigidBodyDerivativeGeometry,
  &_swigt__p_IMP__core__RigidBodyDerivativesGeometry,
  &_swigt__p_IMP__core__RigidBodyDistancePairScore,
  &_swigt__p_IMP__core__RigidBodyFrameGeometry,
  &_swigt__p_IMP__core__RigidBodyFramesGeometry,
  &_swigt__p_IMP__core__RigidBodyHierarchyGeometry,
  &_swigt__p_IMP__core__RigidBodyMember,
  &_swigt__p_IMP__core__RigidBodyMover,
  &_swigt__p_IMP__core__RigidBodyTorque,
  &_swigt__p_IMP__core__RigidBodyTunneler,
  &_swigt__p_IMP__core__RigidBodyUmbrella,
  &_swigt__p_IMP__core__RigidClosePairsFinder,
  &_swigt__p_IMP__core__RigidMember,
  &_swigt__p_IMP__core__RigidMembersRefiner,
  &_swigt__p_IMP__core__SampleProvenance,
  &_swigt__p_IMP__core__ScriptProvenance,
  &_swigt__p_IMP__core__SerialMover,
  &_swigt__p_IMP__core__SingletonConstraint,
  &_swigt__p_IMP__core__SingletonRestraint,
  &_swigt__p_IMP__core__SoftSpherePairScore,
  &_swigt__p_IMP__core__SoftSubSurfacePairScore,
  &_swigt__p_IMP__core__SoftSuperSurfacePairScore,
  &_swigt__p_IMP__core__SoftwareProvenance,
  &_swigt__p_IMP__core__SphereDistancePairScore,
  &_swigt__p_IMP__core__SphereDistanceToSingletonScore,
  &_swigt__p_IMP__core__SteepestDescent,
  &_swigt__p_IMP__core__StructureProvenance,
  &_swigt__p_IMP__core__SubsetMover,
  &_swigt__p_IMP__core__Surface,
  &_swigt__p_IMP__core__SurfaceDepthPairScore,
  &_swigt__p_IMP__core__SurfaceDistancePairScore,
  &_swigt__p_IMP__core__SurfaceGeometry,
  &_swigt__p_IMP__core__SurfaceGeometryConstraint,
  &_swigt__p_IMP__core__SurfaceHeightPairScore,
  &_swigt__p_IMP__core__SurfaceMover,
  &_swigt__p_IMP__core__SurfaceSymmetryConstraint,
  &_swigt__p_IMP__core__SurfaceTetheredChain,
  &_swigt__p_IMP__core__TableRefiner,
  &_swigt__p_IMP__core__Transform,
  &_swigt__p_IMP__core__TransformationAndReflectionSymmetry,
  &_swigt__p_IMP__core__TransformationSymmetry,
  &_swigt__p_IMP__core__TransformationSymmetryMover,
  &_swigt__p_IMP__core__TransformedDistancePairScore,
  &_swigt__p_IMP__core__TripletConstraint,
  &_swigt__p_IMP__core__TripletRestraint,
  &_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_t,
  &_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_t,
  &_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_t,
  &_swigt__p_IMP__core__Typed,
  &_swigt__p_IMP__core__TypedPairScore,
  &_swigt__p_IMP__core__UnorderedTypePairPredicate,
  &_swigt__p_IMP__core__UnorderedTypeQuadPredicate,
  &_swigt__p_IMP__core__UnorderedTypeSingletonPredicate,
  &_swigt__p_IMP__core__UnorderedTypeTripletPredicate,
  &_swigt__p_IMP__core__VolumeRestraint,
  &_swigt__p_IMP__core__WeightedDerivativesToRefined,
  &_swigt__p_IMP__core__WeightedSphereDistancePairScore,
  &_swigt__p_IMP__core__WeightedSum,
  &_swigt__p_IMP__core__WeightedSumOfExponential,
  &_swigt__p_IMP__core__WriteRestraintScoresOptimizerState,
  &_swigt__p_IMP__core__XYZ,
  &_swigt__p_IMP__core__XYZDerivativeGeometry,
  &_swigt__p_IMP__core__XYZDerivativesGeometry,
  &_swigt__p_IMP__core__XYZR,
  &_swigt__p_IMP__core__XYZRGeometry,
  &_swigt__p_IMP__core__XYZRsGeometry,
  &_swigt__p_IMP__display__BoundingBoxGeometry,
  &_swigt__p_IMP__display__Color,
  &_swigt__p_IMP__display__Colored,
  &_swigt__p_IMP__display__CylinderGeometry,
  &_swigt__p_IMP__display__EllipsoidGeometry,
  &_swigt__p_IMP__display__FilterGeometry,
  &_swigt__p_IMP__display__Geometry,
  &_swigt__p_IMP__display__GeometrySet,
  &_swigt__p_IMP__display__IsosurfaceGeometry,
  &_swigt__p_IMP__display__LabelGeometry,
  &_swigt__p_IMP__display__PairGeometry,
  &_swigt__p_IMP__display__PairsGeometry,
  &_swigt__p_IMP__display__PlaneGeometry,
  &_swigt__p_IMP__display__PointGeometry,
  &_swigt__p_IMP__display__PolygonGeometry,
  &_swigt__p_IMP__display__PymolWriter,
  &_swigt__p_IMP__display__ReferenceFrameGeometry,
  &_swigt__p_IMP__display__RestraintGeometry,
  &_swigt__p_IMP__display__RestraintSetGeometry,
  &_swigt__p_IMP__display__SegmentGeometry,
  &_swigt__p_IMP__display__SingletonGeometry,
  &_swigt__p_IMP__display__SingletonsGeometry,
  &_swigt__p_IMP__display__SkinSurfaceGeometry,
  &_swigt__p_IMP__display__SphereGeometry,
  &_swigt__p_IMP__display__SurfaceMeshGeometry,
  &_swigt__p_IMP__display__TextWriter,
  &_swigt__p_IMP__display__TriangleGeometry,
  &_swigt__p_IMP__display__WriteOptimizerState,
  &_swigt__p_IMP__display__Writer,
  &_swigt__p_IMP__display__WriterAdaptor,
  &_swigt__p_IMP__insulinsecretion__CaChannelOpeningOptimizerState,
  &_swigt__p_IMP__insulinsecretion__CaChannelStateDecorator,
  &_swigt__p_IMP__insulinsecretion__DockingStateDecorator,
  &_swigt__p_IMP__insulinsecretion__InsulinSecretionOptimizerState,
  &_swigt__p_IMP__insulinsecretion__MaturationStateDecorator,
  &_swigt__p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore,
  &_swigt__p_IMP__insulinsecretion__SecretionCounterDecorator,
  &_swigt__p_IMP__insulinsecretion__VesicleDockingOptimizerState,
  &_swigt__p_IMP__insulinsecretion__VesicleTraffickingSingletonScore,
  &_swigt__p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_t,
  &_swigt__p_IMP__internal___ConstOptimizer,
  &_swigt__p_IMP__internal___ConstPairScore,
  &_swigt__p_IMP__internal___ConstRestraint,
  &_swigt__p_IMP__internal___ConstSingletonScore,
  &_swigt__p_IMP__internal___LogPairScore,
  &_swigt__p_IMP__internal___Protection,
  &_swigt__p_IMP__internal___TestObject,
  &_swigt__p_IMP__internal___TestValue,
  &_swigt__p_IMP__internal___TrivialDecorator,
  &_swigt__p_IMP__internal___TrivialDerivedDecorator,
  &_swigt__p_IMP__internal___TrivialTraitsDecorator,
  &_swigt__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__HarmonicLowerBound_t,
  &_swigt__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t,
  &_swigt__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t,
  &_swigt__p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_t,
  &_swigt__p_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t,
  &_swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__HarmonicLowerBound_t,
  &_swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__HarmonicUpperBound_t_t,
  &_swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t,
  &_swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t,
  &_swigt__p_Index,
  &_swigt__p_IndexArgument,
  &_swigt__p_Modifier,
  &_swigt__p_P,
  &_swigt__p_ParentDecorator,
  &_swigt__p_PassContainedIndexType,
  &_swigt__p_PassIndexArgument,
  &_swigt__p_ScoreIsGoodPair,
  &_swigt__p_VertexDescriptor,
  &_swigt__p_VertexDescriptors,
  &_swigt__p_VertexName,
  &_swigt__p_char,
  &_swigt__p_double,
  &_swigt__p_first_type,
  &_swigt__p_float,
  &_swigt__p_int,
  &_swigt__p_second_type,
  &_swigt__p_size_t,
  &_swigt__p_std__invalid_argument,
  &_swigt__p_std__ostream,
  &_swigt__p_std__pairT_IMP__algebra__VectorDT_3_t_IMP__algebra__VectorDT_4_t_t,
  &_swigt__p_std__pairT_IMP__algebra__VectorDT_3_t_double_t,
  &_swigt__p_std__pairT_IMP__algebra__VectorDT_3_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t,
  &_swigt__p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t,
  &_swigt__p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_4_t_t,
  &_swigt__p_std__pairT_double_double_t,
  &_swigt__p_std__pairT_int_int_t,
  &_swigt__p_std__pairT_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t,
  &_swigt__p_std__string,
  &_swigt__p_swig__IMP_INSULINSECRETION_SwigPyIterator,
  &_swigt__p_unsigned_int,
};

static swig_cast_info _swigc__p_Argument[] = {  {&_swigt__p_Argument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ContainedIndexType[] = {  {&_swigt__p_ContainedIndexType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ContainedIndexTypes[] = {  {&_swigt__p_ContainedIndexTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ContainedType[] = {  {&_swigt__p_ContainedType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ContainedTypes[] = {  {&_swigt__p_ContainedTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DecoratorHasTraits[] = {  {&_swigt__p_DecoratorHasTraits, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DecoratorTraits[] = {  {&_swigt__p_DecoratorTraits, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Eigen__ArrayXXd[] = {  {&_swigt__p_Eigen__ArrayXXd, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Eigen__ArrayXXf[] = {  {&_swigt__p_Eigen__ArrayXXf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Eigen__Matrix3d[] = {  {&_swigt__p_Eigen__Matrix3d, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Eigen__MatrixXd[] = {  {&_swigt__p_Eigen__MatrixXd, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Eigen__MatrixXf[] = {  {&_swigt__p_Eigen__MatrixXf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Eigen__Vector3d[] = {  {&_swigt__p_Eigen__Vector3d, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Eigen__VectorXd[] = {  {&_swigt__p_Eigen__VectorXd, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Eigen__VectorXf[] = {  {&_swigt__p_Eigen__VectorXf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExtendedIndex[] = {  {&_swigt__p_ExtendedIndex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t[] = {  {&_swigt__p_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t[] = {  {&_swigt__p_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t[] = {  {&_swigt__p_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t[] = {  {&_swigt__p_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t[] = {  {&_swigt__p_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t[] = {  {&_swigt__p_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__AttributeOptimizer[] = {  {&_swigt__p_IMP__AttributeOptimizer, 0, 0, 0},  {&_swigt__p_IMP__core__ConjugateGradients, _p_IMP__core__ConjugateGradientsTo_p_IMP__AttributeOptimizer, 0, 0},  {&_swigt__p_IMP__core__SteepestDescent, _p_IMP__core__SteepestDescentTo_p_IMP__AttributeOptimizer, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__CheckLevel[] = {  {&_swigt__p_IMP__CheckLevel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Configuration[] = {  {&_swigt__p_IMP__Configuration, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ConfigurationSet[] = {  {&_swigt__p_IMP__ConfigurationSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Constraint[] = {  {&_swigt__p_IMP__Constraint, 0, 0, 0},  {&_swigt__p_IMP__container__PairsConstraint, _p_IMP__container__PairsConstraintTo_p_IMP__Constraint, 0, 0},  {&_swigt__p_IMP__container__QuadsConstraint, _p_IMP__container__QuadsConstraintTo_p_IMP__Constraint, 0, 0},  {&_swigt__p_IMP__container__SingletonsConstraint, _p_IMP__container__SingletonsConstraintTo_p_IMP__Constraint, 0, 0},  {&_swigt__p_IMP__container__TripletsConstraint, _p_IMP__container__TripletsConstraintTo_p_IMP__Constraint, 0, 0},  {&_swigt__p_IMP__core__LateralSurfaceConstraint, _p_IMP__core__LateralSurfaceConstraintTo_p_IMP__Constraint, 0, 0},  {&_swigt__p_IMP__core__PairConstraint, _p_IMP__core__PairConstraintTo_p_IMP__Constraint, 0, 0},  {&_swigt__p_IMP__core__QuadConstraint, _p_IMP__core__QuadConstraintTo_p_IMP__Constraint, 0, 0},  {&_swigt__p_IMP__core__SingletonConstraint, _p_IMP__core__SingletonConstraintTo_p_IMP__Constraint, 0, 0},  {&_swigt__p_IMP__core__SurfaceGeometryConstraint, _p_IMP__core__SurfaceGeometryConstraintTo_p_IMP__Constraint, 0, 0},  {&_swigt__p_IMP__core__SurfaceSymmetryConstraint, _p_IMP__core__SurfaceSymmetryConstraintTo_p_IMP__Constraint, 0, 0},  {&_swigt__p_IMP__core__TripletConstraint, _p_IMP__core__TripletConstraintTo_p_IMP__Constraint, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Container[] = {  {&_swigt__p_IMP__Container, 0, 0, 0},  {&_swigt__p_IMP__PairContainer, _p_IMP__PairContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__QuadContainer, _p_IMP__QuadContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__SingletonContainer, _p_IMP__SingletonContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__TripletContainer, _p_IMP__TripletContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__AllBipartitePairContainer, _p_IMP__container__AllBipartitePairContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__AllPairContainer, _p_IMP__container__AllPairContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__CloseBipartitePairContainer, _p_IMP__container__CloseBipartitePairContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__ClosePairContainer, _p_IMP__container__ClosePairContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__ConnectingPairContainer, _p_IMP__container__ConnectingPairContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__ConsecutivePairContainer, _p_IMP__container__ConsecutivePairContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__DynamicListPairContainer, _p_IMP__container__DynamicListPairContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__DynamicListQuadContainer, _p_IMP__container__DynamicListQuadContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__DynamicListSingletonContainer, _p_IMP__container__DynamicListSingletonContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__DynamicListTripletContainer, _p_IMP__container__DynamicListTripletContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__ExclusiveConsecutivePairContainer, _p_IMP__container__ExclusiveConsecutivePairContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__ListPairContainer, _p_IMP__container__ListPairContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__ListQuadContainer, _p_IMP__container__ListQuadContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__ListSingletonContainer, _p_IMP__container__ListSingletonContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__ListTripletContainer, _p_IMP__container__ListTripletContainerTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__PairContainerSet, _p_IMP__container__PairContainerSetTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__QuadContainerSet, _p_IMP__container__QuadContainerSetTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__SingletonContainerSet, _p_IMP__container__SingletonContainerSetTo_p_IMP__Container, 0, 0},  {&_swigt__p_IMP__container__TripletContainerSet, _p_IMP__container__TripletContainerSetTo_p_IMP__Container, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__CreateLogContext[] = {  {&_swigt__p_IMP__CreateLogContext, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Decorator[] = {  {&_swigt__p_IMP__Decorator, 0, 0, 0},  {&_swigt__p_IMP__core__Centroid, _p_IMP__core__CentroidTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__ClusterProvenance, _p_IMP__core__ClusterProvenanceTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__CombineProvenance, _p_IMP__core__CombineProvenanceTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__Cover, _p_IMP__core__CoverTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__Direction, _p_IMP__core__DirectionTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__DirectionAngle, _p_IMP__core__DirectionAngleTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__FilterProvenance, _p_IMP__core__FilterProvenanceTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__Gaussian, _p_IMP__core__GaussianTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__Hierarchy, _p_IMP__core__HierarchyTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__NonRigidMember, _p_IMP__core__NonRigidMemberTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__Provenance, _p_IMP__core__ProvenanceTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__Provenanced, _p_IMP__core__ProvenancedTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__Reference, _p_IMP__core__ReferenceTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__RigidBody, _p_IMP__core__RigidBodyTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__RigidBodyMember, _p_IMP__core__RigidBodyMemberTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__RigidMember, _p_IMP__core__RigidMemberTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__SampleProvenance, _p_IMP__core__SampleProvenanceTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__ScriptProvenance, _p_IMP__core__ScriptProvenanceTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__SoftwareProvenance, _p_IMP__core__SoftwareProvenanceTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__StructureProvenance, _p_IMP__core__StructureProvenanceTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__Surface, _p_IMP__core__SurfaceTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__Typed, _p_IMP__core__TypedTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__XYZ, _p_IMP__core__XYZTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__core__XYZR, _p_IMP__core__XYZRTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__display__Colored, _p_IMP__display__ColoredTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__insulinsecretion__CaChannelStateDecorator, _p_IMP__insulinsecretion__CaChannelStateDecoratorTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__insulinsecretion__DockingStateDecorator, _p_IMP__insulinsecretion__DockingStateDecoratorTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__insulinsecretion__MaturationStateDecorator, _p_IMP__insulinsecretion__MaturationStateDecoratorTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__insulinsecretion__SecretionCounterDecorator, _p_IMP__insulinsecretion__SecretionCounterDecoratorTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__internal___TrivialDecorator, _p_IMP__internal___TrivialDecoratorTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__internal___TrivialDerivedDecorator, _p_IMP__internal___TrivialDerivedDecoratorTo_p_IMP__Decorator, 0, 0},  {&_swigt__p_IMP__internal___TrivialTraitsDecorator, _p_IMP__internal___TrivialTraitsDecoratorTo_p_IMP__Decorator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__DerivativeAccumulator[] = {  {&_swigt__p_IMP__DerivativeAccumulator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__EvaluationState[] = {  {&_swigt__p_IMP__EvaluationState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__FloatIndex[] = {  {&_swigt__p_IMP__FloatIndex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__IndexT_IMP__ParticleIndexTag_t[] = {  {&_swigt__p_IMP__IndexT_IMP__ParticleIndexTag_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_0_t[] = {  {&_swigt__p_IMP__KeyT_0_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_10_t[] = {  {&_swigt__p_IMP__KeyT_10_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_11_t[] = {  {&_swigt__p_IMP__KeyT_11_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_12_t[] = {  {&_swigt__p_IMP__KeyT_12_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_13_t[] = {  {&_swigt__p_IMP__KeyT_13_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_14_t[] = {  {&_swigt__p_IMP__KeyT_14_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_15_t[] = {  {&_swigt__p_IMP__KeyT_15_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_1_t[] = {  {&_swigt__p_IMP__KeyT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_2_t[] = {  {&_swigt__p_IMP__KeyT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_34897493_t[] = {  {&_swigt__p_IMP__KeyT_34897493_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_3_t[] = {  {&_swigt__p_IMP__KeyT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_4_t[] = {  {&_swigt__p_IMP__KeyT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_5_t[] = {  {&_swigt__p_IMP__KeyT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_6_t[] = {  {&_swigt__p_IMP__KeyT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_7_t[] = {  {&_swigt__p_IMP__KeyT_7_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_8_t[] = {  {&_swigt__p_IMP__KeyT_8_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__KeyT_9_t[] = {  {&_swigt__p_IMP__KeyT_9_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Model[] = {  {&_swigt__p_IMP__Model, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ModelObject[] = {  {&_swigt__p_IMP__ModelObject, 0, 0, 0},  {&_swigt__p_IMP__AttributeOptimizer, _p_IMP__AttributeOptimizerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__Constraint, _p_IMP__ConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__Container, _p_IMP__ContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__Optimizer, _p_IMP__OptimizerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__OptimizerState, _p_IMP__OptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__PairContainer, _p_IMP__PairContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__Particle, _p_IMP__ParticleTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__QuadContainer, _p_IMP__QuadContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__Restraint, _p_IMP__RestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__RestraintSet, _p_IMP__RestraintSetTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__SaveToConfigurationSetOptimizerState, _p_IMP__SaveToConfigurationSetOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__ScoreState, _p_IMP__ScoreStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__ScoringFunction, _p_IMP__ScoringFunctionTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__SingletonContainer, _p_IMP__SingletonContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__TripletContainer, _p_IMP__TripletContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__AllBipartitePairContainer, _p_IMP__container__AllBipartitePairContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__AllPairContainer, _p_IMP__container__AllPairContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__CloseBipartitePairContainer, _p_IMP__container__CloseBipartitePairContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__ClosePairContainer, _p_IMP__container__ClosePairContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__ConnectingPairContainer, _p_IMP__container__ConnectingPairContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__ConsecutivePairContainer, _p_IMP__container__ConsecutivePairContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__DistributePairsScoreState, _p_IMP__container__DistributePairsScoreStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__DistributeQuadsScoreState, _p_IMP__container__DistributeQuadsScoreStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__DistributeSingletonsScoreState, _p_IMP__container__DistributeSingletonsScoreStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__DistributeTripletsScoreState, _p_IMP__container__DistributeTripletsScoreStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__DynamicListPairContainer, _p_IMP__container__DynamicListPairContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__DynamicListQuadContainer, _p_IMP__container__DynamicListQuadContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__DynamicListSingletonContainer, _p_IMP__container__DynamicListSingletonContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__DynamicListTripletContainer, _p_IMP__container__DynamicListTripletContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__EventPairsOptimizerState, _p_IMP__container__EventPairsOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__EventQuadsOptimizerState, _p_IMP__container__EventQuadsOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__EventSingletonsOptimizerState, _p_IMP__container__EventSingletonsOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__EventTripletsOptimizerState, _p_IMP__container__EventTripletsOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__ExclusiveConsecutivePairContainer, _p_IMP__container__ExclusiveConsecutivePairContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__ListPairContainer, _p_IMP__container__ListPairContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__ListQuadContainer, _p_IMP__container__ListQuadContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__ListSingletonContainer, _p_IMP__container__ListSingletonContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__ListTripletContainer, _p_IMP__container__ListTripletContainerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__MinimumPairRestraint, _p_IMP__container__MinimumPairRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__MinimumQuadRestraint, _p_IMP__container__MinimumQuadRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__MinimumSingletonRestraint, _p_IMP__container__MinimumSingletonRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__MinimumTripletRestraint, _p_IMP__container__MinimumTripletRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__PairContainerSet, _p_IMP__container__PairContainerSetTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__PairContainerStatistics, _p_IMP__container__PairContainerStatisticsTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__PairsConstraint, _p_IMP__container__PairsConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__PairsOptimizerState, _p_IMP__container__PairsOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__PairsRestraint, _p_IMP__container__PairsRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__PredicatePairsRestraint, _p_IMP__container__PredicatePairsRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__PredicateQuadsRestraint, _p_IMP__container__PredicateQuadsRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__PredicateSingletonsRestraint, _p_IMP__container__PredicateSingletonsRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__PredicateTripletsRestraint, _p_IMP__container__PredicateTripletsRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__QuadContainerSet, _p_IMP__container__QuadContainerSetTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__QuadContainerStatistics, _p_IMP__container__QuadContainerStatisticsTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__QuadsConstraint, _p_IMP__container__QuadsConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__QuadsOptimizerState, _p_IMP__container__QuadsOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__QuadsRestraint, _p_IMP__container__QuadsRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__SingletonContainerSet, _p_IMP__container__SingletonContainerSetTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__SingletonContainerStatistics, _p_IMP__container__SingletonContainerStatisticsTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__SingletonsConstraint, _p_IMP__container__SingletonsConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__SingletonsOptimizerState, _p_IMP__container__SingletonsOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__SingletonsRestraint, _p_IMP__container__SingletonsRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__TripletContainerSet, _p_IMP__container__TripletContainerSetTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__TripletContainerStatistics, _p_IMP__container__TripletContainerStatisticsTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__TripletsConstraint, _p_IMP__container__TripletsConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__TripletsOptimizerState, _p_IMP__container__TripletsOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__container__TripletsRestraint, _p_IMP__container__TripletsRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__AngleRestraint, _p_IMP__core__AngleRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__BallMover, _p_IMP__core__BallMoverTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__ChecksScoreState, _p_IMP__core__ChecksScoreStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__ConjugateGradients, _p_IMP__core__ConjugateGradientsTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__ConnectivityRestraint, _p_IMP__core__ConnectivityRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__ConstantRestraint, _p_IMP__core__ConstantRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__DiameterRestraint, _p_IMP__core__DiameterRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__DihedralRestraint, _p_IMP__core__DihedralRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__DirectionMover, _p_IMP__core__DirectionMoverTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__DistanceRestraint, _p_IMP__core__DistanceRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__ExcludedVolumeRestraint, _p_IMP__core__ExcludedVolumeRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__LateralSurfaceConstraint, _p_IMP__core__LateralSurfaceConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__LogNormalMover, _p_IMP__core__LogNormalMoverTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__MSConnectivityRestraint, _p_IMP__core__MSConnectivityRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__MinimumRestraint, _p_IMP__core__MinimumRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__MonteCarlo, _p_IMP__core__MonteCarloTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__MonteCarloMover, _p_IMP__core__MonteCarloMoverTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithBasinHopping, _p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithLocalOptimization, _p_IMP__core__MonteCarloWithLocalOptimizationTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__MoveStatisticsScoreState, _p_IMP__core__MoveStatisticsScoreStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__MultipleBinormalRestraint, _p_IMP__core__MultipleBinormalRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__NeighborsTable, _p_IMP__core__NeighborsTableTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__NormalMover, _p_IMP__core__NormalMoverTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__PairConstraint, _p_IMP__core__PairConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__PairRestraint, _p_IMP__core__PairRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__QuadConstraint, _p_IMP__core__QuadConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__QuadRestraint, _p_IMP__core__QuadRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__RestraintsScoringFunction, _p_IMP__core__RestraintsScoringFunctionTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__RigidBodyMover, _p_IMP__core__RigidBodyMoverTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__RigidBodyTunneler, _p_IMP__core__RigidBodyTunnelerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__RigidBodyUmbrella, _p_IMP__core__RigidBodyUmbrellaTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__SerialMover, _p_IMP__core__SerialMoverTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__SingletonConstraint, _p_IMP__core__SingletonConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__SingletonRestraint, _p_IMP__core__SingletonRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__SteepestDescent, _p_IMP__core__SteepestDescentTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__SubsetMover, _p_IMP__core__SubsetMoverTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__SurfaceGeometryConstraint, _p_IMP__core__SurfaceGeometryConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__SurfaceMover, _p_IMP__core__SurfaceMoverTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__SurfaceSymmetryConstraint, _p_IMP__core__SurfaceSymmetryConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__TransformationSymmetryMover, _p_IMP__core__TransformationSymmetryMoverTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__TripletConstraint, _p_IMP__core__TripletConstraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__TripletRestraint, _p_IMP__core__TripletRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__VolumeRestraint, _p_IMP__core__VolumeRestraintTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__core__WriteRestraintScoresOptimizerState, _p_IMP__core__WriteRestraintScoresOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__display__WriteOptimizerState, _p_IMP__display__WriteOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, _p_IMP__insulinsecretion__CaChannelOpeningOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__insulinsecretion__InsulinSecretionOptimizerState, _p_IMP__insulinsecretion__InsulinSecretionOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__insulinsecretion__VesicleDockingOptimizerState, _p_IMP__insulinsecretion__VesicleDockingOptimizerStateTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__internal___ConstOptimizer, _p_IMP__internal___ConstOptimizerTo_p_IMP__ModelObject, 0, 0},  {&_swigt__p_IMP__internal___ConstRestraint, _p_IMP__internal___ConstRestraintTo_p_IMP__ModelObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__RAII[] = {{&_swigt__p_IMP__RAII, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___LogPairScore[] = {{&_swigt__p_IMP__internal___LogPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_t[] = {{&_swigt__p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__NonCopyable[] = {  {&_swigt__p_IMP__NonCopyable, 0, 0, 0},  {&_swigt__p_IMP__AttributeOptimizer, _p_IMP__AttributeOptimizerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Configuration, _p_IMP__ConfigurationTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__ConfigurationSet, _p_IMP__ConfigurationSetTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Constraint, _p_IMP__ConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Container, _p_IMP__ContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__CreateLogContext, _p_IMP__CreateLogContextTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Model, _p_IMP__ModelTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__ModelObject, _p_IMP__ModelObjectTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Object, _p_IMP__ObjectTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Optimizer, _p_IMP__OptimizerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__OptimizerState, _p_IMP__OptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__PairContainer, _p_IMP__PairContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__PairModifier, _p_IMP__PairModifierTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__PairPredicate, _p_IMP__PairPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__PairScore, _p_IMP__PairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Particle, _p_IMP__ParticleTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__QuadContainer, _p_IMP__QuadContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__QuadModifier, _p_IMP__QuadModifierTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__QuadPredicate, _p_IMP__QuadPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__QuadScore, _p_IMP__QuadScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__RAII, _p_IMP__RAIITo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Refiner, _p_IMP__RefinerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Restraint, _p_IMP__RestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__RestraintInfo, _p_IMP__RestraintInfoTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__RestraintSet, _p_IMP__RestraintSetTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Sampler, _p_IMP__SamplerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__SaveToConfigurationSetOptimizerState, _p_IMP__SaveToConfigurationSetOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__ScopedSetAttributeT_IMP__KeyT_0_t_double_t, _p_IMP__ScopedSetAttributeT_IMP__KeyT_0_t_double_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__ScoreState, _p_IMP__ScoreStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__ScoringFunction, _p_IMP__ScoringFunctionTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__SetCheckState, _p_IMP__SetCheckStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__SetLogState, _p_IMP__SetLogStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__SetLogTarget, _p_IMP__SetLogTargetTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__SetNumberOfThreads, _p_IMP__SetNumberOfThreadsTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__SingletonContainer, _p_IMP__SingletonContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__SingletonModifier, _p_IMP__SingletonModifierTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__SingletonPredicate, _p_IMP__SingletonPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__SingletonScore, _p_IMP__SingletonScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__TripletContainer, _p_IMP__TripletContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__TripletModifier, _p_IMP__TripletModifierTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__TripletPredicate, _p_IMP__TripletPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__TripletScore, _p_IMP__TripletScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__UnaryFunction, _p_IMP__UnaryFunctionTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__Undecorator, _p_IMP__UndecoratorTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__DynamicNearestNeighbor3D, _p_IMP__algebra__DynamicNearestNeighbor3DTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__EuclideanVectorKDMetric, _p_IMP__algebra__EuclideanVectorKDMetricTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__MaxVectorKDMetric, _p_IMP__algebra__MaxVectorKDMetricTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_1_t, _p_IMP__algebra__NearestNeighborDT_1_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_2_t, _p_IMP__algebra__NearestNeighborDT_2_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_3_t, _p_IMP__algebra__NearestNeighborDT_3_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_4_t, _p_IMP__algebra__NearestNeighborDT_4_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_5_t, _p_IMP__algebra__NearestNeighborDT_5_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_6_t, _p_IMP__algebra__NearestNeighborDT_6_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT__1_t, _p_IMP__algebra__NearestNeighborDT__1_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__algebra__VectorKDMetric, _p_IMP__algebra__VectorKDMetricTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__AllBipartitePairContainer, _p_IMP__container__AllBipartitePairContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__AllPairContainer, _p_IMP__container__AllPairContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__CloseBipartitePairContainer, _p_IMP__container__CloseBipartitePairContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__ClosePairContainer, _p_IMP__container__ClosePairContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__ConnectingPairContainer, _p_IMP__container__ConnectingPairContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__ConsecutivePairContainer, _p_IMP__container__ConsecutivePairContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__ConsecutivePairFilter, _p_IMP__container__ConsecutivePairFilterTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__DistributePairsScoreState, _p_IMP__container__DistributePairsScoreStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__DistributeQuadsScoreState, _p_IMP__container__DistributeQuadsScoreStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__DistributeSingletonsScoreState, _p_IMP__container__DistributeSingletonsScoreStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__DistributeTripletsScoreState, _p_IMP__container__DistributeTripletsScoreStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__DynamicListPairContainer, _p_IMP__container__DynamicListPairContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__DynamicListQuadContainer, _p_IMP__container__DynamicListQuadContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__DynamicListSingletonContainer, _p_IMP__container__DynamicListSingletonContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__DynamicListTripletContainer, _p_IMP__container__DynamicListTripletContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__EventPairsOptimizerState, _p_IMP__container__EventPairsOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__EventQuadsOptimizerState, _p_IMP__container__EventQuadsOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__EventSingletonsOptimizerState, _p_IMP__container__EventSingletonsOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__EventTripletsOptimizerState, _p_IMP__container__EventTripletsOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__ExclusiveConsecutivePairContainer, _p_IMP__container__ExclusiveConsecutivePairContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__ExclusiveConsecutivePairFilter, _p_IMP__container__ExclusiveConsecutivePairFilterTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__InContainerPairFilter, _p_IMP__container__InContainerPairFilterTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__InContainerQuadFilter, _p_IMP__container__InContainerQuadFilterTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__InContainerSingletonFilter, _p_IMP__container__InContainerSingletonFilterTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__InContainerTripletFilter, _p_IMP__container__InContainerTripletFilterTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__ListPairContainer, _p_IMP__container__ListPairContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__ListQuadContainer, _p_IMP__container__ListQuadContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__ListSingletonContainer, _p_IMP__container__ListSingletonContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__ListTripletContainer, _p_IMP__container__ListTripletContainerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__MinimumPairRestraint, _p_IMP__container__MinimumPairRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__MinimumPairScore, _p_IMP__container__MinimumPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__MinimumQuadRestraint, _p_IMP__container__MinimumQuadRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__MinimumQuadScore, _p_IMP__container__MinimumQuadScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__MinimumSingletonRestraint, _p_IMP__container__MinimumSingletonRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__MinimumSingletonScore, _p_IMP__container__MinimumSingletonScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__MinimumTripletRestraint, _p_IMP__container__MinimumTripletRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__MinimumTripletScore, _p_IMP__container__MinimumTripletScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__PairContainerSet, _p_IMP__container__PairContainerSetTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__PairContainerStatistics, _p_IMP__container__PairContainerStatisticsTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__PairsConstraint, _p_IMP__container__PairsConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__PairsOptimizerState, _p_IMP__container__PairsOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__PairsRestraint, _p_IMP__container__PairsRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__PredicatePairsRestraint, _p_IMP__container__PredicatePairsRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__PredicateQuadsRestraint, _p_IMP__container__PredicateQuadsRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__PredicateSingletonsRestraint, _p_IMP__container__PredicateSingletonsRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__PredicateTripletsRestraint, _p_IMP__container__PredicateTripletsRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__QuadContainerSet, _p_IMP__container__QuadContainerSetTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__QuadContainerStatistics, _p_IMP__container__QuadContainerStatisticsTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__QuadsConstraint, _p_IMP__container__QuadsConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__QuadsOptimizerState, _p_IMP__container__QuadsOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__QuadsRestraint, _p_IMP__container__QuadsRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__SingletonContainerSet, _p_IMP__container__SingletonContainerSetTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__SingletonContainerStatistics, _p_IMP__container__SingletonContainerStatisticsTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__SingletonsConstraint, _p_IMP__container__SingletonsConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__SingletonsOptimizerState, _p_IMP__container__SingletonsOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__SingletonsRestraint, _p_IMP__container__SingletonsRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__TripletContainerSet, _p_IMP__container__TripletContainerSetTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__TripletContainerStatistics, _p_IMP__container__TripletContainerStatisticsTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__TripletsConstraint, _p_IMP__container__TripletsConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__TripletsOptimizerState, _p_IMP__container__TripletsOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__container__TripletsRestraint, _p_IMP__container__TripletsRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__AllSamePairPredicate, _p_IMP__core__AllSamePairPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__AllSameQuadPredicate, _p_IMP__core__AllSameQuadPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__AllSameSingletonPredicate, _p_IMP__core__AllSameSingletonPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__AllSameTripletPredicate, _p_IMP__core__AllSameTripletPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__AngleRestraint, _p_IMP__core__AngleRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__AngleTripletScore, _p_IMP__core__AngleTripletScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__AttributeSingletonPredicate, _p_IMP__core__AttributeSingletonPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__BallMover, _p_IMP__core__BallMoverTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__BoxSweepClosePairsFinder, _p_IMP__core__BoxSweepClosePairsFinderTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__CentroidOfRefined, _p_IMP__core__CentroidOfRefinedTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ChecksScoreState, _p_IMP__core__ChecksScoreStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ChildrenRefiner, _p_IMP__core__ChildrenRefinerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ClosePairsFinder, _p_IMP__core__ClosePairsFinderTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ClosePairsPairScore, _p_IMP__core__ClosePairsPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ClosedCubicSpline, _p_IMP__core__ClosedCubicSplineTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__CoinFlipPairPredicate, _p_IMP__core__CoinFlipPairPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__CoinFlipQuadPredicate, _p_IMP__core__CoinFlipQuadPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__CoinFlipSingletonPredicate, _p_IMP__core__CoinFlipSingletonPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__CoinFlipTripletPredicate, _p_IMP__core__CoinFlipTripletPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ConjugateGradients, _p_IMP__core__ConjugateGradientsTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ConnectivityRestraint, _p_IMP__core__ConnectivityRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ConstantPairPredicate, _p_IMP__core__ConstantPairPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ConstantQuadPredicate, _p_IMP__core__ConstantQuadPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ConstantRestraint, _p_IMP__core__ConstantRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ConstantSingletonPredicate, _p_IMP__core__ConstantSingletonPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ConstantTripletPredicate, _p_IMP__core__ConstantTripletPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__Cosine, _p_IMP__core__CosineTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__CoverRefined, _p_IMP__core__CoverRefinedTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__DerivativesFromRefined, _p_IMP__core__DerivativesFromRefinedTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__DerivativesToRefined, _p_IMP__core__DerivativesToRefinedTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__DiameterRestraint, _p_IMP__core__DiameterRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__DihedralRestraint, _p_IMP__core__DihedralRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__DirectionMover, _p_IMP__core__DirectionMoverTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__DistancePairScore, _p_IMP__core__DistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__DistanceRestraint, _p_IMP__core__DistanceRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__EdgePairGeometry, _p_IMP__core__EdgePairGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__EdgePairsGeometry, _p_IMP__core__EdgePairsGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__ExcludedVolumeRestraint, _p_IMP__core__ExcludedVolumeRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__FixedRefiner, _p_IMP__core__FixedRefinerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__GridClosePairsFinder, _p_IMP__core__GridClosePairsFinderTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__Harmonic, _p_IMP__core__HarmonicTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__HarmonicDistancePairScore, _p_IMP__core__HarmonicDistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__HarmonicLowerBound, _p_IMP__core__HarmonicLowerBoundTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__HarmonicSphereDistancePairScore, _p_IMP__core__HarmonicSphereDistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceDepthPairScore, _p_IMP__core__HarmonicSurfaceDepthPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceDistancePairScore, _p_IMP__core__HarmonicSurfaceDistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceHeightPairScore, _p_IMP__core__HarmonicSurfaceHeightPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBound, _p_IMP__core__HarmonicUpperBoundTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore, _p_IMP__core__HarmonicUpperBoundSphereDiameterPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBoundSphereDistancePairScore, _p_IMP__core__HarmonicUpperBoundSphereDistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__HarmonicWell, _p_IMP__core__HarmonicWellTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__InBoundingBox3DSingletonPredicate, _p_IMP__core__InBoundingBox3DSingletonPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__IsCollisionPairPredicate, _p_IMP__core__IsCollisionPairPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__KClosePairsPairScore, _p_IMP__core__KClosePairsPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__LateralSurfaceConstraint, _p_IMP__core__LateralSurfaceConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__LeavesRefiner, _p_IMP__core__LeavesRefinerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__Linear, _p_IMP__core__LinearTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__LogNormalMover, _p_IMP__core__LogNormalMoverTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__MCCGSampler, _p_IMP__core__MCCGSamplerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__MSConnectivityRestraint, _p_IMP__core__MSConnectivityRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__MinimumRestraint, _p_IMP__core__MinimumRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__MonteCarlo, _p_IMP__core__MonteCarloTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__MonteCarloMover, _p_IMP__core__MonteCarloMoverTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithBasinHopping, _p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithLocalOptimization, _p_IMP__core__MonteCarloWithLocalOptimizationTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__MoveStatisticsScoreState, _p_IMP__core__MoveStatisticsScoreStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__MultipleBinormalRestraint, _p_IMP__core__MultipleBinormalRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__NearestNeighborsClosePairsFinder, _p_IMP__core__NearestNeighborsClosePairsFinderTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__NeighborsTable, _p_IMP__core__NeighborsTableTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__NormalMover, _p_IMP__core__NormalMoverTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__NormalizedSphereDistancePairScore, _p_IMP__core__NormalizedSphereDistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__OpenCubicSpline, _p_IMP__core__OpenCubicSplineTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__OrderedTypePairPredicate, _p_IMP__core__OrderedTypePairPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeQuadPredicate, _p_IMP__core__OrderedTypeQuadPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeSingletonPredicate, _p_IMP__core__OrderedTypeSingletonPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeTripletPredicate, _p_IMP__core__OrderedTypeTripletPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__PairConstraint, _p_IMP__core__PairConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__PairRestraint, _p_IMP__core__PairRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__QuadConstraint, _p_IMP__core__QuadConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__QuadRestraint, _p_IMP__core__QuadRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__QuadraticClosePairsFinder, _p_IMP__core__QuadraticClosePairsFinderTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RefinedPairsPairScore, _p_IMP__core__RefinedPairsPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RestraintsScoringFunction, _p_IMP__core__RestraintsScoringFunctionTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyAnglePairScore, _p_IMP__core__RigidBodyAnglePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDerivativeGeometry, _p_IMP__core__RigidBodyDerivativeGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDerivativesGeometry, _p_IMP__core__RigidBodyDerivativesGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDistancePairScore, _p_IMP__core__RigidBodyDistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyFrameGeometry, _p_IMP__core__RigidBodyFrameGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyFramesGeometry, _p_IMP__core__RigidBodyFramesGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyHierarchyGeometry, _p_IMP__core__RigidBodyHierarchyGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyMover, _p_IMP__core__RigidBodyMoverTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyTorque, _p_IMP__core__RigidBodyTorqueTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyTunneler, _p_IMP__core__RigidBodyTunnelerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidBodyUmbrella, _p_IMP__core__RigidBodyUmbrellaTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidClosePairsFinder, _p_IMP__core__RigidClosePairsFinderTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__RigidMembersRefiner, _p_IMP__core__RigidMembersRefinerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SerialMover, _p_IMP__core__SerialMoverTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SingletonConstraint, _p_IMP__core__SingletonConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SingletonRestraint, _p_IMP__core__SingletonRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SoftSpherePairScore, _p_IMP__core__SoftSpherePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SoftSubSurfacePairScore, _p_IMP__core__SoftSubSurfacePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SoftSuperSurfacePairScore, _p_IMP__core__SoftSuperSurfacePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SphereDistancePairScore, _p_IMP__core__SphereDistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SphereDistanceToSingletonScore, _p_IMP__core__SphereDistanceToSingletonScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SteepestDescent, _p_IMP__core__SteepestDescentTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SubsetMover, _p_IMP__core__SubsetMoverTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SurfaceDepthPairScore, _p_IMP__core__SurfaceDepthPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SurfaceDistancePairScore, _p_IMP__core__SurfaceDistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SurfaceGeometry, _p_IMP__core__SurfaceGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SurfaceGeometryConstraint, _p_IMP__core__SurfaceGeometryConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SurfaceHeightPairScore, _p_IMP__core__SurfaceHeightPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SurfaceMover, _p_IMP__core__SurfaceMoverTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SurfaceSymmetryConstraint, _p_IMP__core__SurfaceSymmetryConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__SurfaceTetheredChain, _p_IMP__core__SurfaceTetheredChainTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TableRefiner, _p_IMP__core__TableRefinerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__Transform, _p_IMP__core__TransformTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TransformationAndReflectionSymmetry, _p_IMP__core__TransformationAndReflectionSymmetryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TransformationSymmetry, _p_IMP__core__TransformationSymmetryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TransformationSymmetryMover, _p_IMP__core__TransformationSymmetryMoverTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TransformedDistancePairScore, _p_IMP__core__TransformedDistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TripletConstraint, _p_IMP__core__TripletConstraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TripletRestraint, _p_IMP__core__TripletRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_t, _p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_t, _p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_t, _p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__TypedPairScore, _p_IMP__core__TypedPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypePairPredicate, _p_IMP__core__UnorderedTypePairPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeQuadPredicate, _p_IMP__core__UnorderedTypeQuadPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeSingletonPredicate, _p_IMP__core__UnorderedTypeSingletonPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeTripletPredicate, _p_IMP__core__UnorderedTypeTripletPredicateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__VolumeRestraint, _p_IMP__core__VolumeRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__WeightedSphereDistancePairScore, _p_IMP__core__WeightedSphereDistancePairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__WeightedSum, _p_IMP__core__WeightedSumTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__WeightedSumOfExponential, _p_IMP__core__WeightedSumOfExponentialTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__WriteRestraintScoresOptimizerState, _p_IMP__core__WriteRestraintScoresOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__XYZDerivativeGeometry, _p_IMP__core__XYZDerivativeGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__XYZDerivativesGeometry, _p_IMP__core__XYZDerivativesGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__XYZRGeometry, _p_IMP__core__XYZRGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__core__XYZRsGeometry, _p_IMP__core__XYZRsGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__BoundingBoxGeometry, _p_IMP__display__BoundingBoxGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__CylinderGeometry, _p_IMP__display__CylinderGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__EllipsoidGeometry, _p_IMP__display__EllipsoidGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__FilterGeometry, _p_IMP__display__FilterGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__Geometry, _p_IMP__display__GeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__GeometrySet, _p_IMP__display__GeometrySetTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__IsosurfaceGeometry, _p_IMP__display__IsosurfaceGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__LabelGeometry, _p_IMP__display__LabelGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__PairGeometry, _p_IMP__display__PairGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__PairsGeometry, _p_IMP__display__PairsGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__PlaneGeometry, _p_IMP__display__PlaneGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__PointGeometry, _p_IMP__display__PointGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__PolygonGeometry, _p_IMP__display__PolygonGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__PymolWriter, _p_IMP__display__PymolWriterTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__ReferenceFrameGeometry, _p_IMP__display__ReferenceFrameGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__RestraintGeometry, _p_IMP__display__RestraintGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__RestraintSetGeometry, _p_IMP__display__RestraintSetGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__SegmentGeometry, _p_IMP__display__SegmentGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__SingletonGeometry, _p_IMP__display__SingletonGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__SingletonsGeometry, _p_IMP__display__SingletonsGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__SkinSurfaceGeometry, _p_IMP__display__SkinSurfaceGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__SphereGeometry, _p_IMP__display__SphereGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__SurfaceMeshGeometry, _p_IMP__display__SurfaceMeshGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__TextWriter, _p_IMP__display__TextWriterTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__TriangleGeometry, _p_IMP__display__TriangleGeometryTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__WriteOptimizerState, _p_IMP__display__WriteOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__display__Writer, _p_IMP__display__WriterTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, _p_IMP__insulinsecretion__CaChannelOpeningOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__insulinsecretion__InsulinSecretionOptimizerState, _p_IMP__insulinsecretion__InsulinSecretionOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, _p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__insulinsecretion__VesicleDockingOptimizerState, _p_IMP__insulinsecretion__VesicleDockingOptimizerStateTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, _p_IMP__insulinsecretion__VesicleTraffickingSingletonScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_t, _p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_tTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__internal___ConstOptimizer, _p_IMP__internal___ConstOptimizerTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__internal___ConstPairScore, _p_IMP__internal___ConstPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__internal___ConstRestraint, _p_IMP__internal___ConstRestraintTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__internal___ConstSingletonScore, _p_IMP__internal___ConstSingletonScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__internal___LogPairScore, _p_IMP__internal___LogPairScoreTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__internal___TestObject, _p_IMP__internal___TestObjectTo_p_IMP__NonCopyable, 0, 0},  {&_swigt__p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_t, _p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_tTo_p_IMP__NonCopyable, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Object[] = {  {&_swigt__p_IMP__Object, 0, 0, 0},  {&_swigt__p_IMP__AttributeOptimizer, _p_IMP__AttributeOptimizerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__Configuration, _p_IMP__ConfigurationTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__ConfigurationSet, _p_IMP__ConfigurationSetTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__Constraint, _p_IMP__ConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__Container, _p_IMP__ContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__Model, _p_IMP__ModelTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__ModelObject, _p_IMP__ModelObjectTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__Optimizer, _p_IMP__OptimizerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__OptimizerState, _p_IMP__OptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__PairContainer, _p_IMP__PairContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__PairModifier, _p_IMP__PairModifierTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__PairPredicate, _p_IMP__PairPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__PairScore, _p_IMP__PairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__Particle, _p_IMP__ParticleTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__QuadContainer, _p_IMP__QuadContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__QuadModifier, _p_IMP__QuadModifierTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__QuadPredicate, _p_IMP__QuadPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__QuadScore, _p_IMP__QuadScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__Refiner, _p_IMP__RefinerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__Restraint, _p_IMP__RestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__RestraintInfo, _p_IMP__RestraintInfoTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__RestraintSet, _p_IMP__RestraintSetTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__Sampler, _p_IMP__SamplerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__SaveToConfigurationSetOptimizerState, _p_IMP__SaveToConfigurationSetOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__ScoreState, _p_IMP__ScoreStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__ScoringFunction, _p_IMP__ScoringFunctionTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__SingletonContainer, _p_IMP__SingletonContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__SingletonModifier, _p_IMP__SingletonModifierTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__SingletonPredicate, _p_IMP__SingletonPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__SingletonScore, _p_IMP__SingletonScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__TripletContainer, _p_IMP__TripletContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__TripletModifier, _p_IMP__TripletModifierTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__TripletPredicate, _p_IMP__TripletPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__TripletScore, _p_IMP__TripletScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__UnaryFunction, _p_IMP__UnaryFunctionTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__Undecorator, _p_IMP__UndecoratorTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__DynamicNearestNeighbor3D, _p_IMP__algebra__DynamicNearestNeighbor3DTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__EuclideanVectorKDMetric, _p_IMP__algebra__EuclideanVectorKDMetricTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__MaxVectorKDMetric, _p_IMP__algebra__MaxVectorKDMetricTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_1_t, _p_IMP__algebra__NearestNeighborDT_1_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_2_t, _p_IMP__algebra__NearestNeighborDT_2_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_3_t, _p_IMP__algebra__NearestNeighborDT_3_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_4_t, _p_IMP__algebra__NearestNeighborDT_4_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_5_t, _p_IMP__algebra__NearestNeighborDT_5_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT_6_t, _p_IMP__algebra__NearestNeighborDT_6_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__NearestNeighborDT__1_t, _p_IMP__algebra__NearestNeighborDT__1_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__algebra__VectorKDMetric, _p_IMP__algebra__VectorKDMetricTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__AllBipartitePairContainer, _p_IMP__container__AllBipartitePairContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__AllPairContainer, _p_IMP__container__AllPairContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__CloseBipartitePairContainer, _p_IMP__container__CloseBipartitePairContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__ClosePairContainer, _p_IMP__container__ClosePairContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__ConnectingPairContainer, _p_IMP__container__ConnectingPairContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__ConsecutivePairContainer, _p_IMP__container__ConsecutivePairContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__ConsecutivePairFilter, _p_IMP__container__ConsecutivePairFilterTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__DistributePairsScoreState, _p_IMP__container__DistributePairsScoreStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__DistributeQuadsScoreState, _p_IMP__container__DistributeQuadsScoreStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__DistributeSingletonsScoreState, _p_IMP__container__DistributeSingletonsScoreStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__DistributeTripletsScoreState, _p_IMP__container__DistributeTripletsScoreStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__DynamicListPairContainer, _p_IMP__container__DynamicListPairContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__DynamicListQuadContainer, _p_IMP__container__DynamicListQuadContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__DynamicListSingletonContainer, _p_IMP__container__DynamicListSingletonContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__DynamicListTripletContainer, _p_IMP__container__DynamicListTripletContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__EventPairsOptimizerState, _p_IMP__container__EventPairsOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__EventQuadsOptimizerState, _p_IMP__container__EventQuadsOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__EventSingletonsOptimizerState, _p_IMP__container__EventSingletonsOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__EventTripletsOptimizerState, _p_IMP__container__EventTripletsOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__ExclusiveConsecutivePairContainer, _p_IMP__container__ExclusiveConsecutivePairContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__ExclusiveConsecutivePairFilter, _p_IMP__container__ExclusiveConsecutivePairFilterTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__InContainerPairFilter, _p_IMP__container__InContainerPairFilterTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__InContainerQuadFilter, _p_IMP__container__InContainerQuadFilterTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__InContainerSingletonFilter, _p_IMP__container__InContainerSingletonFilterTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__InContainerTripletFilter, _p_IMP__container__InContainerTripletFilterTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__ListPairContainer, _p_IMP__container__ListPairContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__ListQuadContainer, _p_IMP__container__ListQuadContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__ListSingletonContainer, _p_IMP__container__ListSingletonContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__ListTripletContainer, _p_IMP__container__ListTripletContainerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__MinimumPairRestraint, _p_IMP__container__MinimumPairRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__MinimumPairScore, _p_IMP__container__MinimumPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__MinimumQuadRestraint, _p_IMP__container__MinimumQuadRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__MinimumQuadScore, _p_IMP__container__MinimumQuadScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__MinimumSingletonRestraint, _p_IMP__container__MinimumSingletonRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__MinimumSingletonScore, _p_IMP__container__MinimumSingletonScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__MinimumTripletRestraint, _p_IMP__container__MinimumTripletRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__MinimumTripletScore, _p_IMP__container__MinimumTripletScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__PairContainerSet, _p_IMP__container__PairContainerSetTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__PairContainerStatistics, _p_IMP__container__PairContainerStatisticsTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__PairsConstraint, _p_IMP__container__PairsConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__PairsOptimizerState, _p_IMP__container__PairsOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__PairsRestraint, _p_IMP__container__PairsRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__PredicatePairsRestraint, _p_IMP__container__PredicatePairsRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__PredicateQuadsRestraint, _p_IMP__container__PredicateQuadsRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__PredicateSingletonsRestraint, _p_IMP__container__PredicateSingletonsRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__PredicateTripletsRestraint, _p_IMP__container__PredicateTripletsRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__QuadContainerSet, _p_IMP__container__QuadContainerSetTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__QuadContainerStatistics, _p_IMP__container__QuadContainerStatisticsTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__QuadsConstraint, _p_IMP__container__QuadsConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__QuadsOptimizerState, _p_IMP__container__QuadsOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__QuadsRestraint, _p_IMP__container__QuadsRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__SingletonContainerSet, _p_IMP__container__SingletonContainerSetTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__SingletonContainerStatistics, _p_IMP__container__SingletonContainerStatisticsTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__SingletonsConstraint, _p_IMP__container__SingletonsConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__SingletonsOptimizerState, _p_IMP__container__SingletonsOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__SingletonsRestraint, _p_IMP__container__SingletonsRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__TripletContainerSet, _p_IMP__container__TripletContainerSetTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__TripletContainerStatistics, _p_IMP__container__TripletContainerStatisticsTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__TripletsConstraint, _p_IMP__container__TripletsConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__TripletsOptimizerState, _p_IMP__container__TripletsOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__container__TripletsRestraint, _p_IMP__container__TripletsRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__AllSamePairPredicate, _p_IMP__core__AllSamePairPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__AllSameQuadPredicate, _p_IMP__core__AllSameQuadPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__AllSameSingletonPredicate, _p_IMP__core__AllSameSingletonPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__AllSameTripletPredicate, _p_IMP__core__AllSameTripletPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__AngleRestraint, _p_IMP__core__AngleRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__AngleTripletScore, _p_IMP__core__AngleTripletScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__AttributeSingletonPredicate, _p_IMP__core__AttributeSingletonPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__BallMover, _p_IMP__core__BallMoverTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__BoxSweepClosePairsFinder, _p_IMP__core__BoxSweepClosePairsFinderTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__CentroidOfRefined, _p_IMP__core__CentroidOfRefinedTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ChecksScoreState, _p_IMP__core__ChecksScoreStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ChildrenRefiner, _p_IMP__core__ChildrenRefinerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ClosePairsFinder, _p_IMP__core__ClosePairsFinderTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ClosePairsPairScore, _p_IMP__core__ClosePairsPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ClosedCubicSpline, _p_IMP__core__ClosedCubicSplineTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__CoinFlipPairPredicate, _p_IMP__core__CoinFlipPairPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__CoinFlipQuadPredicate, _p_IMP__core__CoinFlipQuadPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__CoinFlipSingletonPredicate, _p_IMP__core__CoinFlipSingletonPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__CoinFlipTripletPredicate, _p_IMP__core__CoinFlipTripletPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ConjugateGradients, _p_IMP__core__ConjugateGradientsTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ConnectivityRestraint, _p_IMP__core__ConnectivityRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ConstantPairPredicate, _p_IMP__core__ConstantPairPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ConstantQuadPredicate, _p_IMP__core__ConstantQuadPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ConstantRestraint, _p_IMP__core__ConstantRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ConstantSingletonPredicate, _p_IMP__core__ConstantSingletonPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ConstantTripletPredicate, _p_IMP__core__ConstantTripletPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__Cosine, _p_IMP__core__CosineTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__CoverRefined, _p_IMP__core__CoverRefinedTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__DerivativesFromRefined, _p_IMP__core__DerivativesFromRefinedTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__DerivativesToRefined, _p_IMP__core__DerivativesToRefinedTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__DiameterRestraint, _p_IMP__core__DiameterRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__DihedralRestraint, _p_IMP__core__DihedralRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__DirectionMover, _p_IMP__core__DirectionMoverTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__DistancePairScore, _p_IMP__core__DistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__DistanceRestraint, _p_IMP__core__DistanceRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__EdgePairGeometry, _p_IMP__core__EdgePairGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__EdgePairsGeometry, _p_IMP__core__EdgePairsGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__ExcludedVolumeRestraint, _p_IMP__core__ExcludedVolumeRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__FixedRefiner, _p_IMP__core__FixedRefinerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__GridClosePairsFinder, _p_IMP__core__GridClosePairsFinderTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__Harmonic, _p_IMP__core__HarmonicTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__HarmonicDistancePairScore, _p_IMP__core__HarmonicDistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__HarmonicLowerBound, _p_IMP__core__HarmonicLowerBoundTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__HarmonicSphereDistancePairScore, _p_IMP__core__HarmonicSphereDistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceDepthPairScore, _p_IMP__core__HarmonicSurfaceDepthPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceDistancePairScore, _p_IMP__core__HarmonicSurfaceDistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceHeightPairScore, _p_IMP__core__HarmonicSurfaceHeightPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBound, _p_IMP__core__HarmonicUpperBoundTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore, _p_IMP__core__HarmonicUpperBoundSphereDiameterPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBoundSphereDistancePairScore, _p_IMP__core__HarmonicUpperBoundSphereDistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__HarmonicWell, _p_IMP__core__HarmonicWellTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__InBoundingBox3DSingletonPredicate, _p_IMP__core__InBoundingBox3DSingletonPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__IsCollisionPairPredicate, _p_IMP__core__IsCollisionPairPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__KClosePairsPairScore, _p_IMP__core__KClosePairsPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__LateralSurfaceConstraint, _p_IMP__core__LateralSurfaceConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__LeavesRefiner, _p_IMP__core__LeavesRefinerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__Linear, _p_IMP__core__LinearTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__LogNormalMover, _p_IMP__core__LogNormalMoverTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__MCCGSampler, _p_IMP__core__MCCGSamplerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__MSConnectivityRestraint, _p_IMP__core__MSConnectivityRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__MinimumRestraint, _p_IMP__core__MinimumRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__MonteCarlo, _p_IMP__core__MonteCarloTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__MonteCarloMover, _p_IMP__core__MonteCarloMoverTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithBasinHopping, _p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithLocalOptimization, _p_IMP__core__MonteCarloWithLocalOptimizationTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__MoveStatisticsScoreState, _p_IMP__core__MoveStatisticsScoreStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__MultipleBinormalRestraint, _p_IMP__core__MultipleBinormalRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__NearestNeighborsClosePairsFinder, _p_IMP__core__NearestNeighborsClosePairsFinderTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__NeighborsTable, _p_IMP__core__NeighborsTableTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__NormalMover, _p_IMP__core__NormalMoverTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__NormalizedSphereDistancePairScore, _p_IMP__core__NormalizedSphereDistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__OpenCubicSpline, _p_IMP__core__OpenCubicSplineTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__OrderedTypePairPredicate, _p_IMP__core__OrderedTypePairPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeQuadPredicate, _p_IMP__core__OrderedTypeQuadPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeSingletonPredicate, _p_IMP__core__OrderedTypeSingletonPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeTripletPredicate, _p_IMP__core__OrderedTypeTripletPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__PairConstraint, _p_IMP__core__PairConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__PairRestraint, _p_IMP__core__PairRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__QuadConstraint, _p_IMP__core__QuadConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__QuadRestraint, _p_IMP__core__QuadRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__QuadraticClosePairsFinder, _p_IMP__core__QuadraticClosePairsFinderTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RefinedPairsPairScore, _p_IMP__core__RefinedPairsPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RestraintsScoringFunction, _p_IMP__core__RestraintsScoringFunctionTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyAnglePairScore, _p_IMP__core__RigidBodyAnglePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDerivativeGeometry, _p_IMP__core__RigidBodyDerivativeGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDerivativesGeometry, _p_IMP__core__RigidBodyDerivativesGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDistancePairScore, _p_IMP__core__RigidBodyDistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyFrameGeometry, _p_IMP__core__RigidBodyFrameGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyFramesGeometry, _p_IMP__core__RigidBodyFramesGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyHierarchyGeometry, _p_IMP__core__RigidBodyHierarchyGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyMover, _p_IMP__core__RigidBodyMoverTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyTorque, _p_IMP__core__RigidBodyTorqueTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyTunneler, _p_IMP__core__RigidBodyTunnelerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidBodyUmbrella, _p_IMP__core__RigidBodyUmbrellaTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidClosePairsFinder, _p_IMP__core__RigidClosePairsFinderTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__RigidMembersRefiner, _p_IMP__core__RigidMembersRefinerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SerialMover, _p_IMP__core__SerialMoverTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SingletonConstraint, _p_IMP__core__SingletonConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SingletonRestraint, _p_IMP__core__SingletonRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SoftSpherePairScore, _p_IMP__core__SoftSpherePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SoftSubSurfacePairScore, _p_IMP__core__SoftSubSurfacePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SoftSuperSurfacePairScore, _p_IMP__core__SoftSuperSurfacePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SphereDistancePairScore, _p_IMP__core__SphereDistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SphereDistanceToSingletonScore, _p_IMP__core__SphereDistanceToSingletonScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SteepestDescent, _p_IMP__core__SteepestDescentTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SubsetMover, _p_IMP__core__SubsetMoverTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SurfaceDepthPairScore, _p_IMP__core__SurfaceDepthPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SurfaceDistancePairScore, _p_IMP__core__SurfaceDistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SurfaceGeometry, _p_IMP__core__SurfaceGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SurfaceGeometryConstraint, _p_IMP__core__SurfaceGeometryConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SurfaceHeightPairScore, _p_IMP__core__SurfaceHeightPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SurfaceMover, _p_IMP__core__SurfaceMoverTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SurfaceSymmetryConstraint, _p_IMP__core__SurfaceSymmetryConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__SurfaceTetheredChain, _p_IMP__core__SurfaceTetheredChainTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TableRefiner, _p_IMP__core__TableRefinerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__Transform, _p_IMP__core__TransformTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TransformationAndReflectionSymmetry, _p_IMP__core__TransformationAndReflectionSymmetryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TransformationSymmetry, _p_IMP__core__TransformationSymmetryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TransformationSymmetryMover, _p_IMP__core__TransformationSymmetryMoverTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TransformedDistancePairScore, _p_IMP__core__TransformedDistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TripletConstraint, _p_IMP__core__TripletConstraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TripletRestraint, _p_IMP__core__TripletRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_t, _p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_t, _p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_t, _p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__TypedPairScore, _p_IMP__core__TypedPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypePairPredicate, _p_IMP__core__UnorderedTypePairPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeQuadPredicate, _p_IMP__core__UnorderedTypeQuadPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeSingletonPredicate, _p_IMP__core__UnorderedTypeSingletonPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeTripletPredicate, _p_IMP__core__UnorderedTypeTripletPredicateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__VolumeRestraint, _p_IMP__core__VolumeRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__WeightedSphereDistancePairScore, _p_IMP__core__WeightedSphereDistancePairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__WeightedSum, _p_IMP__core__WeightedSumTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__WeightedSumOfExponential, _p_IMP__core__WeightedSumOfExponentialTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__WriteRestraintScoresOptimizerState, _p_IMP__core__WriteRestraintScoresOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__XYZDerivativeGeometry, _p_IMP__core__XYZDerivativeGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__XYZDerivativesGeometry, _p_IMP__core__XYZDerivativesGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__XYZRGeometry, _p_IMP__core__XYZRGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__core__XYZRsGeometry, _p_IMP__core__XYZRsGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__BoundingBoxGeometry, _p_IMP__display__BoundingBoxGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__CylinderGeometry, _p_IMP__display__CylinderGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__EllipsoidGeometry, _p_IMP__display__EllipsoidGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__FilterGeometry, _p_IMP__display__FilterGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__Geometry, _p_IMP__display__GeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__GeometrySet, _p_IMP__display__GeometrySetTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__IsosurfaceGeometry, _p_IMP__display__IsosurfaceGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__LabelGeometry, _p_IMP__display__LabelGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__PairGeometry, _p_IMP__display__PairGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__PairsGeometry, _p_IMP__display__PairsGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__PlaneGeometry, _p_IMP__display__PlaneGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__PointGeometry, _p_IMP__display__PointGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__PolygonGeometry, _p_IMP__display__PolygonGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__PymolWriter, _p_IMP__display__PymolWriterTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__ReferenceFrameGeometry, _p_IMP__display__ReferenceFrameGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__RestraintGeometry, _p_IMP__display__RestraintGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__RestraintSetGeometry, _p_IMP__display__RestraintSetGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__SegmentGeometry, _p_IMP__display__SegmentGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__SingletonGeometry, _p_IMP__display__SingletonGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__SingletonsGeometry, _p_IMP__display__SingletonsGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__SkinSurfaceGeometry, _p_IMP__display__SkinSurfaceGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__SphereGeometry, _p_IMP__display__SphereGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__SurfaceMeshGeometry, _p_IMP__display__SurfaceMeshGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__TextWriter, _p_IMP__display__TextWriterTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__TriangleGeometry, _p_IMP__display__TriangleGeometryTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__WriteOptimizerState, _p_IMP__display__WriteOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__display__Writer, _p_IMP__display__WriterTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, _p_IMP__insulinsecretion__CaChannelOpeningOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__insulinsecretion__InsulinSecretionOptimizerState, _p_IMP__insulinsecretion__InsulinSecretionOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, _p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__insulinsecretion__VesicleDockingOptimizerState, _p_IMP__insulinsecretion__VesicleDockingOptimizerStateTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, _p_IMP__insulinsecretion__VesicleTraffickingSingletonScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_t, _p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_tTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__internal___ConstOptimizer, _p_IMP__internal___ConstOptimizerTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__internal___ConstPairScore, _p_IMP__internal___ConstPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__internal___ConstRestraint, _p_IMP__internal___ConstRestraintTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__internal___ConstSingletonScore, _p_IMP__internal___ConstSingletonScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__internal___LogPairScore, _p_IMP__internal___LogPairScoreTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__internal___TestObject, _p_IMP__internal___TestObjectTo_p_IMP__Object, 0, 0},  {&_swigt__p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_t, _p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_tTo_p_IMP__Object, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Optimizer[] = {  {&_swigt__p_IMP__Optimizer, 0, 0, 0},  {&_swigt__p_IMP__AttributeOptimizer, _p_IMP__AttributeOptimizerTo_p_IMP__Optimizer, 0, 0},  {&_swigt__p_IMP__core__ConjugateGradients, _p_IMP__core__ConjugateGradientsTo_p_IMP__Optimizer, 0, 0},  {&_swigt__p_IMP__core__MonteCarlo, _p_IMP__core__MonteCarloTo_p_IMP__Optimizer, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithBasinHopping, _p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__Optimizer, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithLocalOptimization, _p_IMP__core__MonteCarloWithLocalOptimizationTo_p_IMP__Optimizer, 0, 0},  {&_swigt__p_IMP__core__SteepestDescent, _p_IMP__core__SteepestDescentTo_p_IMP__Optimizer, 0, 0},  {&_swigt__p_IMP__internal___ConstOptimizer, _p_IMP__internal___ConstOptimizerTo_p_IMP__Optimizer, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__OptimizerState[] = {  {&_swigt__p_IMP__OptimizerState, 0, 0, 0},  {&_swigt__p_IMP__SaveToConfigurationSetOptimizerState, _p_IMP__SaveToConfigurationSetOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__container__EventPairsOptimizerState, _p_IMP__container__EventPairsOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__container__EventQuadsOptimizerState, _p_IMP__container__EventQuadsOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__container__EventSingletonsOptimizerState, _p_IMP__container__EventSingletonsOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__container__EventTripletsOptimizerState, _p_IMP__container__EventTripletsOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__container__PairsOptimizerState, _p_IMP__container__PairsOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__container__QuadsOptimizerState, _p_IMP__container__QuadsOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__container__SingletonsOptimizerState, _p_IMP__container__SingletonsOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__container__TripletsOptimizerState, _p_IMP__container__TripletsOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__core__WriteRestraintScoresOptimizerState, _p_IMP__core__WriteRestraintScoresOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__display__WriteOptimizerState, _p_IMP__display__WriteOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, _p_IMP__insulinsecretion__CaChannelOpeningOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__insulinsecretion__InsulinSecretionOptimizerState, _p_IMP__insulinsecretion__InsulinSecretionOptimizerStateTo_p_IMP__OptimizerState, 0, 0},  {&_swigt__p_IMP__insulinsecretion__VesicleDockingOptimizerState, _p_IMP__insulinsecretion__VesicleDockingOptimizerStateTo_p_IMP__OptimizerState, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__PairContainer[] = {  {&_swigt__p_IMP__PairContainer, 0, 0, 0},  {&_swigt__p_IMP__container__AllBipartitePairContainer, _p_IMP__container__AllBipartitePairContainerTo_p_IMP__PairContainer, 0, 0},  {&_swigt__p_IMP__container__AllPairContainer, _p_IMP__container__AllPairContainerTo_p_IMP__PairContainer, 0, 0},  {&_swigt__p_IMP__container__CloseBipartitePairContainer, _p_IMP__container__CloseBipartitePairContainerTo_p_IMP__PairContainer, 0, 0},  {&_swigt__p_IMP__container__ClosePairContainer, _p_IMP__container__ClosePairContainerTo_p_IMP__PairContainer, 0, 0},  {&_swigt__p_IMP__container__ConnectingPairContainer, _p_IMP__container__ConnectingPairContainerTo_p_IMP__PairContainer, 0, 0},  {&_swigt__p_IMP__container__ConsecutivePairContainer, _p_IMP__container__ConsecutivePairContainerTo_p_IMP__PairContainer, 0, 0},  {&_swigt__p_IMP__container__DynamicListPairContainer, _p_IMP__container__DynamicListPairContainerTo_p_IMP__PairContainer, 0, 0},  {&_swigt__p_IMP__container__ExclusiveConsecutivePairContainer, _p_IMP__container__ExclusiveConsecutivePairContainerTo_p_IMP__PairContainer, 0, 0},  {&_swigt__p_IMP__container__ListPairContainer, _p_IMP__container__ListPairContainerTo_p_IMP__PairContainer, 0, 0},  {&_swigt__p_IMP__container__PairContainerSet, _p_IMP__container__PairContainerSetTo_p_IMP__PairContainer, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__PairModifier[] = {  {&_swigt__p_IMP__PairModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__PairPredicate[] = {  {&_swigt__p_IMP__PairPredicate, 0, 0, 0},  {&_swigt__p_IMP__container__ConsecutivePairFilter, _p_IMP__container__ConsecutivePairFilterTo_p_IMP__PairPredicate, 0, 0},  {&_swigt__p_IMP__container__ExclusiveConsecutivePairFilter, _p_IMP__container__ExclusiveConsecutivePairFilterTo_p_IMP__PairPredicate, 0, 0},  {&_swigt__p_IMP__container__InContainerPairFilter, _p_IMP__container__InContainerPairFilterTo_p_IMP__PairPredicate, 0, 0},  {&_swigt__p_IMP__core__AllSamePairPredicate, _p_IMP__core__AllSamePairPredicateTo_p_IMP__PairPredicate, 0, 0},  {&_swigt__p_IMP__core__CoinFlipPairPredicate, _p_IMP__core__CoinFlipPairPredicateTo_p_IMP__PairPredicate, 0, 0},  {&_swigt__p_IMP__core__ConstantPairPredicate, _p_IMP__core__ConstantPairPredicateTo_p_IMP__PairPredicate, 0, 0},  {&_swigt__p_IMP__core__IsCollisionPairPredicate, _p_IMP__core__IsCollisionPairPredicateTo_p_IMP__PairPredicate, 0, 0},  {&_swigt__p_IMP__core__OrderedTypePairPredicate, _p_IMP__core__OrderedTypePairPredicateTo_p_IMP__PairPredicate, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypePairPredicate, _p_IMP__core__UnorderedTypePairPredicateTo_p_IMP__PairPredicate, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__PairScore[] = {  {&_swigt__p_IMP__PairScore, 0, 0, 0},  {&_swigt__p_IMP__container__MinimumPairScore, _p_IMP__container__MinimumPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__ClosePairsPairScore, _p_IMP__core__ClosePairsPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__DistancePairScore, _p_IMP__core__DistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__HarmonicDistancePairScore, _p_IMP__core__HarmonicDistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__HarmonicSphereDistancePairScore, _p_IMP__core__HarmonicSphereDistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceDepthPairScore, _p_IMP__core__HarmonicSurfaceDepthPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceDistancePairScore, _p_IMP__core__HarmonicSurfaceDistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceHeightPairScore, _p_IMP__core__HarmonicSurfaceHeightPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore, _p_IMP__core__HarmonicUpperBoundSphereDiameterPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBoundSphereDistancePairScore, _p_IMP__core__HarmonicUpperBoundSphereDistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__KClosePairsPairScore, _p_IMP__core__KClosePairsPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__NormalizedSphereDistancePairScore, _p_IMP__core__NormalizedSphereDistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__RefinedPairsPairScore, _p_IMP__core__RefinedPairsPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__RigidBodyAnglePairScore, _p_IMP__core__RigidBodyAnglePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDistancePairScore, _p_IMP__core__RigidBodyDistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__SoftSpherePairScore, _p_IMP__core__SoftSpherePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__SoftSubSurfacePairScore, _p_IMP__core__SoftSubSurfacePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__SoftSuperSurfacePairScore, _p_IMP__core__SoftSuperSurfacePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__SphereDistancePairScore, _p_IMP__core__SphereDistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__SurfaceDepthPairScore, _p_IMP__core__SurfaceDepthPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__SurfaceDistancePairScore, _p_IMP__core__SurfaceDistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__SurfaceHeightPairScore, _p_IMP__core__SurfaceHeightPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__TransformedDistancePairScore, _p_IMP__core__TransformedDistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__TypedPairScore, _p_IMP__core__TypedPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__core__WeightedSphereDistancePairScore, _p_IMP__core__WeightedSphereDistancePairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__internal___ConstPairScore, _p_IMP__internal___ConstPairScoreTo_p_IMP__PairScore, 0, 0},  {&_swigt__p_IMP__internal___LogPairScore, _p_IMP__internal___LogPairScoreTo_p_IMP__PairScore, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Particle[] = {  {&_swigt__p_IMP__Particle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ParticleAdaptor[] = {  {&_swigt__p_IMP__ParticleAdaptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ParticleIndexesAdaptor[] = {  {&_swigt__p_IMP__ParticleIndexesAdaptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ParticleInputs[] = {  {&_swigt__p_IMP__ParticleInputs, 0, 0, 0},  {&_swigt__p_IMP__PairModifier, _p_IMP__PairModifierTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__PairPredicate, _p_IMP__PairPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__PairScore, _p_IMP__PairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__QuadModifier, _p_IMP__QuadModifierTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__QuadPredicate, _p_IMP__QuadPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__QuadScore, _p_IMP__QuadScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__Refiner, _p_IMP__RefinerTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__SingletonModifier, _p_IMP__SingletonModifierTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__SingletonPredicate, _p_IMP__SingletonPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__SingletonScore, _p_IMP__SingletonScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__TripletModifier, _p_IMP__TripletModifierTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__TripletPredicate, _p_IMP__TripletPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__TripletScore, _p_IMP__TripletScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__container__ConsecutivePairFilter, _p_IMP__container__ConsecutivePairFilterTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__container__ExclusiveConsecutivePairFilter, _p_IMP__container__ExclusiveConsecutivePairFilterTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__container__InContainerPairFilter, _p_IMP__container__InContainerPairFilterTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__container__InContainerQuadFilter, _p_IMP__container__InContainerQuadFilterTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__container__InContainerSingletonFilter, _p_IMP__container__InContainerSingletonFilterTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__container__InContainerTripletFilter, _p_IMP__container__InContainerTripletFilterTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__container__MinimumPairScore, _p_IMP__container__MinimumPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__container__MinimumQuadScore, _p_IMP__container__MinimumQuadScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__container__MinimumSingletonScore, _p_IMP__container__MinimumSingletonScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__container__MinimumTripletScore, _p_IMP__container__MinimumTripletScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__AllSamePairPredicate, _p_IMP__core__AllSamePairPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__AllSameQuadPredicate, _p_IMP__core__AllSameQuadPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__AllSameSingletonPredicate, _p_IMP__core__AllSameSingletonPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__AllSameTripletPredicate, _p_IMP__core__AllSameTripletPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__AngleTripletScore, _p_IMP__core__AngleTripletScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__AttributeSingletonPredicate, _p_IMP__core__AttributeSingletonPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__BoxSweepClosePairsFinder, _p_IMP__core__BoxSweepClosePairsFinderTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__CentroidOfRefined, _p_IMP__core__CentroidOfRefinedTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__ChildrenRefiner, _p_IMP__core__ChildrenRefinerTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__ClosePairsFinder, _p_IMP__core__ClosePairsFinderTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__ClosePairsPairScore, _p_IMP__core__ClosePairsPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__CoinFlipPairPredicate, _p_IMP__core__CoinFlipPairPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__CoinFlipQuadPredicate, _p_IMP__core__CoinFlipQuadPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__CoinFlipSingletonPredicate, _p_IMP__core__CoinFlipSingletonPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__CoinFlipTripletPredicate, _p_IMP__core__CoinFlipTripletPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__ConstantPairPredicate, _p_IMP__core__ConstantPairPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__ConstantQuadPredicate, _p_IMP__core__ConstantQuadPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__ConstantSingletonPredicate, _p_IMP__core__ConstantSingletonPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__ConstantTripletPredicate, _p_IMP__core__ConstantTripletPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__CoverRefined, _p_IMP__core__CoverRefinedTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__DerivativesFromRefined, _p_IMP__core__DerivativesFromRefinedTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__DerivativesToRefined, _p_IMP__core__DerivativesToRefinedTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__DistancePairScore, _p_IMP__core__DistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__FixedRefiner, _p_IMP__core__FixedRefinerTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__GridClosePairsFinder, _p_IMP__core__GridClosePairsFinderTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__HarmonicDistancePairScore, _p_IMP__core__HarmonicDistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__HarmonicSphereDistancePairScore, _p_IMP__core__HarmonicSphereDistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceDepthPairScore, _p_IMP__core__HarmonicSurfaceDepthPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceDistancePairScore, _p_IMP__core__HarmonicSurfaceDistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__HarmonicSurfaceHeightPairScore, _p_IMP__core__HarmonicSurfaceHeightPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore, _p_IMP__core__HarmonicUpperBoundSphereDiameterPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBoundSphereDistancePairScore, _p_IMP__core__HarmonicUpperBoundSphereDistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__InBoundingBox3DSingletonPredicate, _p_IMP__core__InBoundingBox3DSingletonPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__IsCollisionPairPredicate, _p_IMP__core__IsCollisionPairPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__KClosePairsPairScore, _p_IMP__core__KClosePairsPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__LeavesRefiner, _p_IMP__core__LeavesRefinerTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__NearestNeighborsClosePairsFinder, _p_IMP__core__NearestNeighborsClosePairsFinderTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__NormalizedSphereDistancePairScore, _p_IMP__core__NormalizedSphereDistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__OrderedTypePairPredicate, _p_IMP__core__OrderedTypePairPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeQuadPredicate, _p_IMP__core__OrderedTypeQuadPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeSingletonPredicate, _p_IMP__core__OrderedTypeSingletonPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeTripletPredicate, _p_IMP__core__OrderedTypeTripletPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__QuadraticClosePairsFinder, _p_IMP__core__QuadraticClosePairsFinderTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__RefinedPairsPairScore, _p_IMP__core__RefinedPairsPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__RigidBodyAnglePairScore, _p_IMP__core__RigidBodyAnglePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDistancePairScore, _p_IMP__core__RigidBodyDistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__RigidClosePairsFinder, _p_IMP__core__RigidClosePairsFinderTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__RigidMembersRefiner, _p_IMP__core__RigidMembersRefinerTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__SoftSpherePairScore, _p_IMP__core__SoftSpherePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__SoftSubSurfacePairScore, _p_IMP__core__SoftSubSurfacePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__SoftSuperSurfacePairScore, _p_IMP__core__SoftSuperSurfacePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__SphereDistancePairScore, _p_IMP__core__SphereDistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__SphereDistanceToSingletonScore, _p_IMP__core__SphereDistanceToSingletonScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__SurfaceDepthPairScore, _p_IMP__core__SurfaceDepthPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__SurfaceDistancePairScore, _p_IMP__core__SurfaceDistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__SurfaceHeightPairScore, _p_IMP__core__SurfaceHeightPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__TableRefiner, _p_IMP__core__TableRefinerTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__Transform, _p_IMP__core__TransformTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__TransformationAndReflectionSymmetry, _p_IMP__core__TransformationAndReflectionSymmetryTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__TransformationSymmetry, _p_IMP__core__TransformationSymmetryTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__TransformedDistancePairScore, _p_IMP__core__TransformedDistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__TypedPairScore, _p_IMP__core__TypedPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypePairPredicate, _p_IMP__core__UnorderedTypePairPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeQuadPredicate, _p_IMP__core__UnorderedTypeQuadPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeSingletonPredicate, _p_IMP__core__UnorderedTypeSingletonPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeTripletPredicate, _p_IMP__core__UnorderedTypeTripletPredicateTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__core__WeightedSphereDistancePairScore, _p_IMP__core__WeightedSphereDistancePairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, _p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, _p_IMP__insulinsecretion__VesicleTraffickingSingletonScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__internal___ConstPairScore, _p_IMP__internal___ConstPairScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__internal___ConstSingletonScore, _p_IMP__internal___ConstSingletonScoreTo_p_IMP__ParticleInputs, 0, 0},  {&_swigt__p_IMP__internal___LogPairScore, _p_IMP__internal___LogPairScoreTo_p_IMP__ParticleInputs, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__QuadContainer[] = {  {&_swigt__p_IMP__QuadContainer, 0, 0, 0},  {&_swigt__p_IMP__container__DynamicListQuadContainer, _p_IMP__container__DynamicListQuadContainerTo_p_IMP__QuadContainer, 0, 0},  {&_swigt__p_IMP__container__ListQuadContainer, _p_IMP__container__ListQuadContainerTo_p_IMP__QuadContainer, 0, 0},  {&_swigt__p_IMP__container__QuadContainerSet, _p_IMP__container__QuadContainerSetTo_p_IMP__QuadContainer, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__QuadModifier[] = {  {&_swigt__p_IMP__QuadModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__QuadPredicate[] = {  {&_swigt__p_IMP__QuadPredicate, 0, 0, 0},  {&_swigt__p_IMP__container__InContainerQuadFilter, _p_IMP__container__InContainerQuadFilterTo_p_IMP__QuadPredicate, 0, 0},  {&_swigt__p_IMP__core__AllSameQuadPredicate, _p_IMP__core__AllSameQuadPredicateTo_p_IMP__QuadPredicate, 0, 0},  {&_swigt__p_IMP__core__CoinFlipQuadPredicate, _p_IMP__core__CoinFlipQuadPredicateTo_p_IMP__QuadPredicate, 0, 0},  {&_swigt__p_IMP__core__ConstantQuadPredicate, _p_IMP__core__ConstantQuadPredicateTo_p_IMP__QuadPredicate, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeQuadPredicate, _p_IMP__core__OrderedTypeQuadPredicateTo_p_IMP__QuadPredicate, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeQuadPredicate, _p_IMP__core__UnorderedTypeQuadPredicateTo_p_IMP__QuadPredicate, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__QuadScore[] = {  {&_swigt__p_IMP__QuadScore, 0, 0, 0},  {&_swigt__p_IMP__container__MinimumQuadScore, _p_IMP__container__MinimumQuadScoreTo_p_IMP__QuadScore, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Refiner[] = {  {&_swigt__p_IMP__Refiner, 0, 0, 0},  {&_swigt__p_IMP__core__ChildrenRefiner, _p_IMP__core__ChildrenRefinerTo_p_IMP__Refiner, 0, 0},  {&_swigt__p_IMP__core__FixedRefiner, _p_IMP__core__FixedRefinerTo_p_IMP__Refiner, 0, 0},  {&_swigt__p_IMP__core__LeavesRefiner, _p_IMP__core__LeavesRefinerTo_p_IMP__Refiner, 0, 0},  {&_swigt__p_IMP__core__RigidMembersRefiner, _p_IMP__core__RigidMembersRefinerTo_p_IMP__Refiner, 0, 0},  {&_swigt__p_IMP__core__TableRefiner, _p_IMP__core__TableRefinerTo_p_IMP__Refiner, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Restraint[] = {  {&_swigt__p_IMP__Restraint, 0, 0, 0},  {&_swigt__p_IMP__RestraintSet, _p_IMP__RestraintSetTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__MinimumPairRestraint, _p_IMP__container__MinimumPairRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__MinimumQuadRestraint, _p_IMP__container__MinimumQuadRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__MinimumSingletonRestraint, _p_IMP__container__MinimumSingletonRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__MinimumTripletRestraint, _p_IMP__container__MinimumTripletRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__PairsRestraint, _p_IMP__container__PairsRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__PredicatePairsRestraint, _p_IMP__container__PredicatePairsRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__PredicateQuadsRestraint, _p_IMP__container__PredicateQuadsRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__PredicateSingletonsRestraint, _p_IMP__container__PredicateSingletonsRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__PredicateTripletsRestraint, _p_IMP__container__PredicateTripletsRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__QuadsRestraint, _p_IMP__container__QuadsRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__SingletonsRestraint, _p_IMP__container__SingletonsRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__container__TripletsRestraint, _p_IMP__container__TripletsRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__AngleRestraint, _p_IMP__core__AngleRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__ConnectivityRestraint, _p_IMP__core__ConnectivityRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__ConstantRestraint, _p_IMP__core__ConstantRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__DiameterRestraint, _p_IMP__core__DiameterRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__DihedralRestraint, _p_IMP__core__DihedralRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__DistanceRestraint, _p_IMP__core__DistanceRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__ExcludedVolumeRestraint, _p_IMP__core__ExcludedVolumeRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__MSConnectivityRestraint, _p_IMP__core__MSConnectivityRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__MinimumRestraint, _p_IMP__core__MinimumRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__MultipleBinormalRestraint, _p_IMP__core__MultipleBinormalRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__PairRestraint, _p_IMP__core__PairRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__QuadRestraint, _p_IMP__core__QuadRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__RigidBodyUmbrella, _p_IMP__core__RigidBodyUmbrellaTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__SingletonRestraint, _p_IMP__core__SingletonRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__TripletRestraint, _p_IMP__core__TripletRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__core__VolumeRestraint, _p_IMP__core__VolumeRestraintTo_p_IMP__Restraint, 0, 0},  {&_swigt__p_IMP__internal___ConstRestraint, _p_IMP__internal___ConstRestraintTo_p_IMP__Restraint, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__RestraintInfo[] = {  {&_swigt__p_IMP__RestraintInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__RestraintSet[] = {  {&_swigt__p_IMP__RestraintSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Sampler[] = {  {&_swigt__p_IMP__Sampler, 0, 0, 0},  {&_swigt__p_IMP__core__MCCGSampler, _p_IMP__core__MCCGSamplerTo_p_IMP__Sampler, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__SaveToConfigurationSetOptimizerState[] = {  {&_swigt__p_IMP__SaveToConfigurationSetOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ScopedSetAttributeT_IMP__KeyT_0_t_double_t[] = {  {&_swigt__p_IMP__ScopedSetAttributeT_IMP__KeyT_0_t_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ScoreAccumulator[] = {  {&_swigt__p_IMP__ScoreAccumulator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ScoreState[] = {  {&_swigt__p_IMP__ScoreState, 0, 0, 0},  {&_swigt__p_IMP__Constraint, _p_IMP__ConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__DistributePairsScoreState, _p_IMP__container__DistributePairsScoreStateTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__DistributeQuadsScoreState, _p_IMP__container__DistributeQuadsScoreStateTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__DistributeSingletonsScoreState, _p_IMP__container__DistributeSingletonsScoreStateTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__DistributeTripletsScoreState, _p_IMP__container__DistributeTripletsScoreStateTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__PairContainerStatistics, _p_IMP__container__PairContainerStatisticsTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__PairsConstraint, _p_IMP__container__PairsConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__QuadContainerStatistics, _p_IMP__container__QuadContainerStatisticsTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__QuadsConstraint, _p_IMP__container__QuadsConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__SingletonContainerStatistics, _p_IMP__container__SingletonContainerStatisticsTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__SingletonsConstraint, _p_IMP__container__SingletonsConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__TripletContainerStatistics, _p_IMP__container__TripletContainerStatisticsTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__container__TripletsConstraint, _p_IMP__container__TripletsConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__core__ChecksScoreState, _p_IMP__core__ChecksScoreStateTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__core__LateralSurfaceConstraint, _p_IMP__core__LateralSurfaceConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__core__MoveStatisticsScoreState, _p_IMP__core__MoveStatisticsScoreStateTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__core__NeighborsTable, _p_IMP__core__NeighborsTableTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__core__PairConstraint, _p_IMP__core__PairConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__core__QuadConstraint, _p_IMP__core__QuadConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__core__SingletonConstraint, _p_IMP__core__SingletonConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__core__SurfaceGeometryConstraint, _p_IMP__core__SurfaceGeometryConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__core__SurfaceSymmetryConstraint, _p_IMP__core__SurfaceSymmetryConstraintTo_p_IMP__ScoreState, 0, 0},  {&_swigt__p_IMP__core__TripletConstraint, _p_IMP__core__TripletConstraintTo_p_IMP__ScoreState, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__ScoringFunction[] = {  {&_swigt__p_IMP__ScoringFunction, 0, 0, 0},  {&_swigt__p_IMP__core__RestraintsScoringFunction, _p_IMP__core__RestraintsScoringFunctionTo_p_IMP__ScoringFunction, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__SetCheckState[] = {  {&_swigt__p_IMP__SetCheckState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__SetLogState[] = {  {&_swigt__p_IMP__SetLogState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__SetLogTarget[] = {  {&_swigt__p_IMP__SetLogTarget, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__SetNumberOfThreads[] = {  {&_swigt__p_IMP__SetNumberOfThreads, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__SingletonContainer[] = {  {&_swigt__p_IMP__SingletonContainer, 0, 0, 0},  {&_swigt__p_IMP__container__DynamicListSingletonContainer, _p_IMP__container__DynamicListSingletonContainerTo_p_IMP__SingletonContainer, 0, 0},  {&_swigt__p_IMP__container__ListSingletonContainer, _p_IMP__container__ListSingletonContainerTo_p_IMP__SingletonContainer, 0, 0},  {&_swigt__p_IMP__container__SingletonContainerSet, _p_IMP__container__SingletonContainerSetTo_p_IMP__SingletonContainer, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__SingletonContainerAdaptor[] = {  {&_swigt__p_IMP__SingletonContainerAdaptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__SingletonModifier[] = {  {&_swigt__p_IMP__SingletonModifier, 0, 0, 0},  {&_swigt__p_IMP__core__CentroidOfRefined, _p_IMP__core__CentroidOfRefinedTo_p_IMP__SingletonModifier, 0, 0},  {&_swigt__p_IMP__core__CoverRefined, _p_IMP__core__CoverRefinedTo_p_IMP__SingletonModifier, 0, 0},  {&_swigt__p_IMP__core__DerivativesFromRefined, _p_IMP__core__DerivativesFromRefinedTo_p_IMP__SingletonModifier, 0, 0},  {&_swigt__p_IMP__core__DerivativesToRefined, _p_IMP__core__DerivativesToRefinedTo_p_IMP__SingletonModifier, 0, 0},  {&_swigt__p_IMP__core__Transform, _p_IMP__core__TransformTo_p_IMP__SingletonModifier, 0, 0},  {&_swigt__p_IMP__core__TransformationAndReflectionSymmetry, _p_IMP__core__TransformationAndReflectionSymmetryTo_p_IMP__SingletonModifier, 0, 0},  {&_swigt__p_IMP__core__TransformationSymmetry, _p_IMP__core__TransformationSymmetryTo_p_IMP__SingletonModifier, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__SingletonPredicate[] = {  {&_swigt__p_IMP__SingletonPredicate, 0, 0, 0},  {&_swigt__p_IMP__container__InContainerSingletonFilter, _p_IMP__container__InContainerSingletonFilterTo_p_IMP__SingletonPredicate, 0, 0},  {&_swigt__p_IMP__core__AllSameSingletonPredicate, _p_IMP__core__AllSameSingletonPredicateTo_p_IMP__SingletonPredicate, 0, 0},  {&_swigt__p_IMP__core__AttributeSingletonPredicate, _p_IMP__core__AttributeSingletonPredicateTo_p_IMP__SingletonPredicate, 0, 0},  {&_swigt__p_IMP__core__CoinFlipSingletonPredicate, _p_IMP__core__CoinFlipSingletonPredicateTo_p_IMP__SingletonPredicate, 0, 0},  {&_swigt__p_IMP__core__ConstantSingletonPredicate, _p_IMP__core__ConstantSingletonPredicateTo_p_IMP__SingletonPredicate, 0, 0},  {&_swigt__p_IMP__core__InBoundingBox3DSingletonPredicate, _p_IMP__core__InBoundingBox3DSingletonPredicateTo_p_IMP__SingletonPredicate, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeSingletonPredicate, _p_IMP__core__OrderedTypeSingletonPredicateTo_p_IMP__SingletonPredicate, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeSingletonPredicate, _p_IMP__core__UnorderedTypeSingletonPredicateTo_p_IMP__SingletonPredicate, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__SingletonScore[] = {  {&_swigt__p_IMP__SingletonScore, 0, 0, 0},  {&_swigt__p_IMP__container__MinimumSingletonScore, _p_IMP__container__MinimumSingletonScoreTo_p_IMP__SingletonScore, 0, 0},  {&_swigt__p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__SingletonScore, 0, 0},  {&_swigt__p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__SingletonScore, 0, 0},  {&_swigt__p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__SingletonScore, 0, 0},  {&_swigt__p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t, _p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_tTo_p_IMP__SingletonScore, 0, 0},  {&_swigt__p_IMP__core__SphereDistanceToSingletonScore, _p_IMP__core__SphereDistanceToSingletonScoreTo_p_IMP__SingletonScore, 0, 0},  {&_swigt__p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, _p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScoreTo_p_IMP__SingletonScore, 0, 0},  {&_swigt__p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, _p_IMP__insulinsecretion__VesicleTraffickingSingletonScoreTo_p_IMP__SingletonScore, 0, 0},  {&_swigt__p_IMP__internal___ConstSingletonScore, _p_IMP__internal___ConstSingletonScoreTo_p_IMP__SingletonScore, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__TripletContainer[] = {  {&_swigt__p_IMP__TripletContainer, 0, 0, 0},  {&_swigt__p_IMP__container__DynamicListTripletContainer, _p_IMP__container__DynamicListTripletContainerTo_p_IMP__TripletContainer, 0, 0},  {&_swigt__p_IMP__container__ListTripletContainer, _p_IMP__container__ListTripletContainerTo_p_IMP__TripletContainer, 0, 0},  {&_swigt__p_IMP__container__TripletContainerSet, _p_IMP__container__TripletContainerSetTo_p_IMP__TripletContainer, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__TripletModifier[] = {  {&_swigt__p_IMP__TripletModifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__TripletPredicate[] = {  {&_swigt__p_IMP__TripletPredicate, 0, 0, 0},  {&_swigt__p_IMP__container__InContainerTripletFilter, _p_IMP__container__InContainerTripletFilterTo_p_IMP__TripletPredicate, 0, 0},  {&_swigt__p_IMP__core__AllSameTripletPredicate, _p_IMP__core__AllSameTripletPredicateTo_p_IMP__TripletPredicate, 0, 0},  {&_swigt__p_IMP__core__CoinFlipTripletPredicate, _p_IMP__core__CoinFlipTripletPredicateTo_p_IMP__TripletPredicate, 0, 0},  {&_swigt__p_IMP__core__ConstantTripletPredicate, _p_IMP__core__ConstantTripletPredicateTo_p_IMP__TripletPredicate, 0, 0},  {&_swigt__p_IMP__core__OrderedTypeTripletPredicate, _p_IMP__core__OrderedTypeTripletPredicateTo_p_IMP__TripletPredicate, 0, 0},  {&_swigt__p_IMP__core__UnorderedTypeTripletPredicate, _p_IMP__core__UnorderedTypeTripletPredicateTo_p_IMP__TripletPredicate, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__TripletScore[] = {  {&_swigt__p_IMP__TripletScore, 0, 0, 0},  {&_swigt__p_IMP__container__MinimumTripletScore, _p_IMP__container__MinimumTripletScoreTo_p_IMP__TripletScore, 0, 0},  {&_swigt__p_IMP__core__AngleTripletScore, _p_IMP__core__AngleTripletScoreTo_p_IMP__TripletScore, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__UnaryFunction[] = {  {&_swigt__p_IMP__UnaryFunction, 0, 0, 0},  {&_swigt__p_IMP__core__ClosedCubicSpline, _p_IMP__core__ClosedCubicSplineTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__Cosine, _p_IMP__core__CosineTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__Harmonic, _p_IMP__core__HarmonicTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__HarmonicLowerBound, _p_IMP__core__HarmonicLowerBoundTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBound, _p_IMP__core__HarmonicUpperBoundTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__HarmonicWell, _p_IMP__core__HarmonicWellTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__Linear, _p_IMP__core__LinearTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__OpenCubicSpline, _p_IMP__core__OpenCubicSplineTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__SurfaceTetheredChain, _p_IMP__core__SurfaceTetheredChainTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_t, _p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_tTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_t, _p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_tTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_t, _p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_tTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__WeightedSum, _p_IMP__core__WeightedSumTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__core__WeightedSumOfExponential, _p_IMP__core__WeightedSumOfExponentialTo_p_IMP__UnaryFunction, 0, 0},  {&_swigt__p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_t, _p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_tTo_p_IMP__UnaryFunction, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Undecorator[] = {  {&_swigt__p_IMP__Undecorator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__Value[] = {  {&_swigt__p_IMP__Value, 0, 0, 0},  {&_swigt__p_IMP__Decorator, _p_IMP__DecoratorTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__FloatIndex, _p_IMP__FloatIndexTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__IndexT_IMP__ParticleIndexTag_t, _p_IMP__IndexT_IMP__ParticleIndexTag_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_0_t, _p_IMP__KeyT_0_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_10_t, _p_IMP__KeyT_10_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_11_t, _p_IMP__KeyT_11_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_12_t, _p_IMP__KeyT_12_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_13_t, _p_IMP__KeyT_13_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_14_t, _p_IMP__KeyT_14_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_15_t, _p_IMP__KeyT_15_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_1_t, _p_IMP__KeyT_1_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_2_t, _p_IMP__KeyT_2_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_34897493_t, _p_IMP__KeyT_34897493_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_3_t, _p_IMP__KeyT_3_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_4_t, _p_IMP__KeyT_4_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_5_t, _p_IMP__KeyT_5_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_6_t, _p_IMP__KeyT_6_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__KeyT_8_t, _p_IMP__KeyT_8_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__ScoreAccumulator, _p_IMP__ScoreAccumulatorTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__VersionInfo, _p_IMP__VersionInfoTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_1_t, _p_IMP__algebra__ExtendedGridIndexDT_1_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_2_t, _p_IMP__algebra__ExtendedGridIndexDT_2_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_3_t, _p_IMP__algebra__ExtendedGridIndexDT_3_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_4_t, _p_IMP__algebra__ExtendedGridIndexDT_4_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_5_t, _p_IMP__algebra__ExtendedGridIndexDT_5_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_6_t, _p_IMP__algebra__ExtendedGridIndexDT_6_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT__1_t, _p_IMP__algebra__ExtendedGridIndexDT__1_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__GridIndexDT_1_t, _p_IMP__algebra__GridIndexDT_1_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__GridIndexDT_2_t, _p_IMP__algebra__GridIndexDT_2_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__GridIndexDT_3_t, _p_IMP__algebra__GridIndexDT_3_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__GridIndexDT_4_t, _p_IMP__algebra__GridIndexDT_4_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__GridIndexDT_5_t, _p_IMP__algebra__GridIndexDT_5_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__GridIndexDT_6_t, _p_IMP__algebra__GridIndexDT_6_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__algebra__GridIndexDT__1_t, _p_IMP__algebra__GridIndexDT__1_tTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__Centroid, _p_IMP__core__CentroidTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__ClusterProvenance, _p_IMP__core__ClusterProvenanceTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__CombineProvenance, _p_IMP__core__CombineProvenanceTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__Cover, _p_IMP__core__CoverTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__Direction, _p_IMP__core__DirectionTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__DirectionAngle, _p_IMP__core__DirectionAngleTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__FilterProvenance, _p_IMP__core__FilterProvenanceTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__Gaussian, _p_IMP__core__GaussianTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__Hierarchy, _p_IMP__core__HierarchyTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__MonteCarloMoverResult, _p_IMP__core__MonteCarloMoverResultTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__NonRigidMember, _p_IMP__core__NonRigidMemberTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__Provenance, _p_IMP__core__ProvenanceTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__Provenanced, _p_IMP__core__ProvenancedTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__Reference, _p_IMP__core__ReferenceTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__RigidBody, _p_IMP__core__RigidBodyTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__RigidBodyMember, _p_IMP__core__RigidBodyMemberTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__RigidMember, _p_IMP__core__RigidMemberTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__SampleProvenance, _p_IMP__core__SampleProvenanceTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__ScriptProvenance, _p_IMP__core__ScriptProvenanceTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__SoftwareProvenance, _p_IMP__core__SoftwareProvenanceTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__StructureProvenance, _p_IMP__core__StructureProvenanceTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__Surface, _p_IMP__core__SurfaceTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__Typed, _p_IMP__core__TypedTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__XYZ, _p_IMP__core__XYZTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__core__XYZR, _p_IMP__core__XYZRTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__display__Color, _p_IMP__display__ColorTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__display__Colored, _p_IMP__display__ColoredTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__insulinsecretion__CaChannelStateDecorator, _p_IMP__insulinsecretion__CaChannelStateDecoratorTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__insulinsecretion__DockingStateDecorator, _p_IMP__insulinsecretion__DockingStateDecoratorTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__insulinsecretion__MaturationStateDecorator, _p_IMP__insulinsecretion__MaturationStateDecoratorTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__insulinsecretion__SecretionCounterDecorator, _p_IMP__insulinsecretion__SecretionCounterDecoratorTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__internal___TrivialDecorator, _p_IMP__internal___TrivialDecoratorTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__internal___TrivialDerivedDecorator, _p_IMP__internal___TrivialDerivedDecoratorTo_p_IMP__Value, 0, 0},  {&_swigt__p_IMP__internal___TrivialTraitsDecorator, _p_IMP__internal___TrivialTraitsDecoratorTo_p_IMP__Value, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__DerivativeAccumulator_t[] = {  {&_swigt__p_IMP__VectorT_IMP__DerivativeAccumulator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__EvaluationState_t[] = {  {&_swigt__p_IMP__VectorT_IMP__EvaluationState_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__FloatIndex_t[] = {  {&_swigt__p_IMP__VectorT_IMP__FloatIndex_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__IndexT_IMP__ParticleIndexTag_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__IndexT_IMP__ParticleIndexTag_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_0_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_0_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_10_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_10_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_11_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_11_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_12_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_12_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_13_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_13_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_14_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_14_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_15_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_15_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_34897493_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_34897493_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_7_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_7_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_8_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_8_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__KeyT_9_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__KeyT_9_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__AttributeOptimizer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__AttributeOptimizer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__ConfigurationSet_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__ConfigurationSet_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Configuration_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Configuration_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Constraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Constraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Container_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Container_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__ModelObject_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__ModelObject_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Model_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Model_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Object_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Object_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__OptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__OptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Optimizer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Optimizer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__PairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__PairModifier_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairModifier_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__PairPredicate_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairPredicate_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__PairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__PairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__QuadContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__QuadModifier_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadModifier_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__QuadPredicate_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadPredicate_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__QuadScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__QuadScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Refiner_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Refiner_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__RestraintSet_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__RestraintSet_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Restraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Restraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Sampler_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Sampler_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__ScoreState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__ScoreState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__ScoringFunction_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__ScoringFunction_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__SingletonContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__SingletonModifier_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonModifier_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__SingletonPredicate_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonPredicate_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__SingletonScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__SingletonScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__TripletContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__TripletModifier_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletModifier_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__TripletPredicate_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletPredicate_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__TripletScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__TripletScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__UnaryFunction_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__UnaryFunction_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Undecorator_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__Undecorator_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__algebra__VectorKDMetric_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__algebra__VectorKDMetric_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__AllBipartitePairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__AllBipartitePairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__AllPairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__AllPairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ClosePairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ClosePairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ConnectingPairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ConnectingPairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ConsecutivePairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ConsecutivePairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListPairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListPairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListQuadContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListQuadContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListSingletonContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListSingletonContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListTripletContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListTripletContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerPairFilter_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerPairFilter_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerQuadFilter_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerQuadFilter_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerSingletonFilter_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerSingletonFilter_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerTripletFilter_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerTripletFilter_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ListPairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListPairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ListQuadContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListQuadContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ListSingletonContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListSingletonContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ListTripletContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__ListTripletContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumPairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumPairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumQuadScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumQuadScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumSingletonScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumSingletonScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumTripletScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumTripletScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsConstraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsConstraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsRestraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsRestraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsConstraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsConstraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsRestraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsRestraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsConstraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsConstraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsRestraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsRestraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsConstraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsConstraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsRestraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsRestraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__DistancePairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__DistancePairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicDistancePairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicDistancePairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicWell_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicWell_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__MonteCarloMover_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__MonteCarloMover_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometryConstraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometryConstraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometry_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometry_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__display__Geometry_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__display__Geometry_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__display__TextWriter_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__display__TextWriter_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__display__Writer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__display__Writer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstOptimizer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstOptimizer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstPairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstPairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstRestraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstRestraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstSingletonScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstSingletonScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__ScoreAccumulator_t[] = {  {&_swigt__p_IMP__VectorT_IMP__ScoreAccumulator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__SetCheckState_t[] = {  {&_swigt__p_IMP__VectorT_IMP__SetCheckState_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__SetLogState_t[] = {  {&_swigt__p_IMP__VectorT_IMP__SetLogState_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__TextInput_t[] = {  {&_swigt__p_IMP__VectorT_IMP__TextInput_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__TextOutput_t[] = {  {&_swigt__p_IMP__VectorT_IMP__TextOutput_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_double_t_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_double_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_int_t_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_int_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_std__string_t_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_std__string_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VectorT_WeakPointerT_IMP__Particle_t_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VectorT_WeakPointerT_IMP__Particle_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VectorT_double_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VectorT_double_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VectorT_int_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VectorT_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VectorT_std__pairT_double_double_t_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VectorT_std__pairT_double_double_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VectorT_std__pairT_int_int_t_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VectorT_std__pairT_int_int_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VectorT_std__string_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VectorT_std__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__VersionInfo_t[] = {  {&_swigt__p_IMP__VectorT_IMP__VersionInfo_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__AttributeOptimizer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__AttributeOptimizer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__ConfigurationSet_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ConfigurationSet_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Configuration_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Configuration_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Constraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Constraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Container_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Container_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Model_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Model_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Object_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Object_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__OptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__OptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Optimizer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Optimizer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairModifier_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairModifier_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairPredicate_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairPredicate_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadModifier_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadModifier_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadPredicate_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadPredicate_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Refiner_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Refiner_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__RestraintSet_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__RestraintSet_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Restraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Restraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Sampler_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Sampler_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoreState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoreState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoringFunction_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoringFunction_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonModifier_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonModifier_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonPredicate_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonPredicate_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletModifier_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletModifier_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletPredicate_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletPredicate_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__UnaryFunction_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__UnaryFunction_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Undecorator_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__Undecorator_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__algebra__VectorKDMetric_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__algebra__VectorKDMetric_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllBipartitePairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllBipartitePairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllPairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllPairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ClosePairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ClosePairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConnectingPairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConnectingPairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConsecutivePairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConsecutivePairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListPairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListPairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListQuadContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListQuadContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListSingletonContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListSingletonContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListTripletContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListTripletContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerPairFilter_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerPairFilter_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerQuadFilter_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerQuadFilter_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerSingletonFilter_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerSingletonFilter_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerTripletFilter_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerTripletFilter_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListPairContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListPairContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListQuadContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListQuadContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListSingletonContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListSingletonContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListTripletContainer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListTripletContainer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumPairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumPairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumQuadScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumQuadScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumSingletonScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumSingletonScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumTripletScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumTripletScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsConstraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsConstraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsRestraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsRestraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsConstraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsConstraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsRestraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsRestraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsConstraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsConstraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsRestraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsRestraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsConstraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsConstraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsRestraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsRestraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__DistancePairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__DistancePairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicDistancePairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicDistancePairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicWell_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicWell_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__MonteCarloMover_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__MonteCarloMover_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometryConstraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometryConstraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometry_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometry_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Geometry_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Geometry_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__TextWriter_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__TextWriter_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Writer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Writer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstOptimizer_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstOptimizer_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstPairScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstPairScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstRestraint_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstRestraint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstSingletonScore_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstSingletonScore_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__BoundingBoxDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Cone3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Cone3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__ConnollySurfacePoint_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__ConnollySurfacePoint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Cylinder3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Cylinder3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Ellipsoid3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Ellipsoid3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__FixedXYZ_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__FixedXYZ_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Gaussian3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Gaussian3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__GridIndexDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Line3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Line3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__LinearFit2D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__LinearFit2D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__ParabolicFit2D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__ParabolicFit2D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Plane3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Plane3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__ReferenceFrame3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__ReferenceFrame3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Reflection3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Reflection3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Rotation2D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Rotation2D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Rotation3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Rotation3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Segment3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Segment3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__SphereDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__SphereDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__SphereDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__SpherePatch3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__SpherePatch3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__SphericalVector3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__SphericalVector3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Transformation2D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Transformation2D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Transformation3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Transformation3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__Triangle3D_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__Triangle3D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__UnitSimplexDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_2_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_3_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_4_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_5_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_5_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_6_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__VectorDT_6_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__algebra__VectorDT__1_t_t[] = {  {&_swigt__p_IMP__VectorT_IMP__algebra__VectorDT__1_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__BinormalTerm_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__BinormalTerm_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__Centroid_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__Centroid_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__Cover_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__Cover_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__DirectionAngle_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__DirectionAngle_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__Direction_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__Direction_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__Gaussian_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__Gaussian_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__HierarchyCounter_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__HierarchyCounter_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__HierarchyTraits_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__HierarchyTraits_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__Hierarchy_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__Hierarchy_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__MonteCarloMoverResult_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__MonteCarloMoverResult_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__Reference_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__Reference_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__RigidBodyMember_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__RigidBodyMember_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__RigidBody_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__RigidBody_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__RigidMember_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__RigidMember_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__Surface_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__Surface_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__Typed_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__Typed_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__XYZR_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__XYZR_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__core__XYZ_t[] = {  {&_swigt__p_IMP__VectorT_IMP__core__XYZ_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__display__Color_t[] = {  {&_swigt__p_IMP__VectorT_IMP__display__Color_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__display__Colored_t[] = {  {&_swigt__p_IMP__VectorT_IMP__display__Colored_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__display__GeometryProcessor_t[] = {  {&_swigt__p_IMP__VectorT_IMP__display__GeometryProcessor_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__display__WriterAdaptor_t[] = {  {&_swigt__p_IMP__VectorT_IMP__display__WriterAdaptor_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__internal___Protection_t[] = {  {&_swigt__p_IMP__VectorT_IMP__internal___Protection_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__internal___TestValue_t[] = {  {&_swigt__p_IMP__VectorT_IMP__internal___TestValue_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__internal___TrivialDecorator_t[] = {  {&_swigt__p_IMP__VectorT_IMP__internal___TrivialDecorator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__internal___TrivialDerivedDecorator_t[] = {  {&_swigt__p_IMP__VectorT_IMP__internal___TrivialDerivedDecorator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_IMP__internal___TrivialTraitsDecorator_t[] = {  {&_swigt__p_IMP__VectorT_IMP__internal___TrivialTraitsDecorator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_PointerT_IMP__Particle_t_t[] = {  {&_swigt__p_IMP__VectorT_PointerT_IMP__Particle_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_WeakPointerT_IMP__Particle_t_t[] = {  {&_swigt__p_IMP__VectorT_WeakPointerT_IMP__Particle_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_double_t[] = {  {&_swigt__p_IMP__VectorT_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_int_t[] = {  {&_swigt__p_IMP__VectorT_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_std__pairT_IMP__algebra__VectorDT_3_t_double_t_t[] = {  {&_swigt__p_IMP__VectorT_std__pairT_IMP__algebra__VectorDT_3_t_double_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_std__pairT_double_double_t_t[] = {  {&_swigt__p_IMP__VectorT_std__pairT_double_double_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_std__pairT_int_int_t_t[] = {  {&_swigt__p_IMP__VectorT_std__pairT_int_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VectorT_std__string_t[] = {  {&_swigt__p_IMP__VectorT_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__VersionInfo[] = {  {&_swigt__p_IMP__VersionInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__WarningContext[] = {  {&_swigt__p_IMP__WarningContext, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundedGridRangeDT_1_t[] = {  {&_swigt__p_IMP__algebra__BoundedGridRangeDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundedGridRangeDT_2_t[] = {  {&_swigt__p_IMP__algebra__BoundedGridRangeDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundedGridRangeDT_3_t[] = {  {&_swigt__p_IMP__algebra__BoundedGridRangeDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundedGridRangeDT_4_t[] = {  {&_swigt__p_IMP__algebra__BoundedGridRangeDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundedGridRangeDT_5_t[] = {  {&_swigt__p_IMP__algebra__BoundedGridRangeDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundedGridRangeDT_6_t[] = {  {&_swigt__p_IMP__algebra__BoundedGridRangeDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundedGridRangeDT__1_t[] = {  {&_swigt__p_IMP__algebra__BoundedGridRangeDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundingBoxDT_1_t[] = {  {&_swigt__p_IMP__algebra__BoundingBoxDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundingBoxDT_2_t[] = {  {&_swigt__p_IMP__algebra__BoundingBoxDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundingBoxDT_3_t[] = {  {&_swigt__p_IMP__algebra__BoundingBoxDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundingBoxDT_4_t[] = {  {&_swigt__p_IMP__algebra__BoundingBoxDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundingBoxDT_5_t[] = {  {&_swigt__p_IMP__algebra__BoundingBoxDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundingBoxDT_6_t[] = {  {&_swigt__p_IMP__algebra__BoundingBoxDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__BoundingBoxDT__1_t[] = {  {&_swigt__p_IMP__algebra__BoundingBoxDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Cone3D[] = {  {&_swigt__p_IMP__algebra__Cone3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__ConnollySurfacePoint[] = {  {&_swigt__p_IMP__algebra__ConnollySurfacePoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Cylinder3D[] = {  {&_swigt__p_IMP__algebra__Cylinder3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__DefaultEmbeddingDT_1_t[] = {  {&_swigt__p_IMP__algebra__DefaultEmbeddingDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__DefaultEmbeddingDT_2_t[] = {  {&_swigt__p_IMP__algebra__DefaultEmbeddingDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__DefaultEmbeddingDT_3_t[] = {  {&_swigt__p_IMP__algebra__DefaultEmbeddingDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__DefaultEmbeddingDT_4_t[] = {  {&_swigt__p_IMP__algebra__DefaultEmbeddingDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__DefaultEmbeddingDT_5_t[] = {  {&_swigt__p_IMP__algebra__DefaultEmbeddingDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__DefaultEmbeddingDT_6_t[] = {  {&_swigt__p_IMP__algebra__DefaultEmbeddingDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__DefaultEmbeddingDT__1_t[] = {  {&_swigt__p_IMP__algebra__DefaultEmbeddingDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__DynamicNearestNeighbor3D[] = {  {&_swigt__p_IMP__algebra__DynamicNearestNeighbor3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Ellipsoid3D[] = {  {&_swigt__p_IMP__algebra__Ellipsoid3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__EuclideanVectorKDMetric[] = {  {&_swigt__p_IMP__algebra__EuclideanVectorKDMetric, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__ExtendedGridIndexDT_1_t[] = {  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__ExtendedGridIndexDT_2_t[] = {  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__ExtendedGridIndexDT_3_t[] = {  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__ExtendedGridIndexDT_4_t[] = {  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__ExtendedGridIndexDT_5_t[] = {  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__ExtendedGridIndexDT_6_t[] = {  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__ExtendedGridIndexDT__1_t[] = {  {&_swigt__p_IMP__algebra__ExtendedGridIndexDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__FixedXYZ[] = {  {&_swigt__p_IMP__algebra__FixedXYZ, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Gaussian3D[] = {  {&_swigt__p_IMP__algebra__Gaussian3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexBaseDT_1_t[] = {{&_swigt__p_IMP__algebra__UnitSimplexBaseDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorBaseDT_1_t[] = {{&_swigt__p_IMP__algebra__VectorBaseDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GeometricPrimitiveDT_1_t[] = {  {&_swigt__p_IMP__algebra__GeometricPrimitiveDT_1_t, 0, 0, 0},  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_1_t, _p_IMP__algebra__PrincipalComponentAnalysisDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t, 0, 0},  {&_swigt__p_IMP__algebra__SphereDT_1_t, _p_IMP__algebra__SphereDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexBaseDT_1_t, _p_IMP__algebra__UnitSimplexBaseDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexDT_1_t, _p_IMP__algebra__UnitSimplexDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorBaseDT_1_t, _p_IMP__algebra__VectorBaseDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorDT_1_t, _p_IMP__algebra__VectorDT_1_tTo_p_IMP__algebra__GeometricPrimitiveDT_1_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexBaseDT_2_t[] = {{&_swigt__p_IMP__algebra__UnitSimplexBaseDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorBaseDT_2_t[] = {{&_swigt__p_IMP__algebra__VectorBaseDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GeometricPrimitiveDT_2_t[] = {  {&_swigt__p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0, 0},  {&_swigt__p_IMP__algebra__LinearFit2D, _p_IMP__algebra__LinearFit2DTo_p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0},  {&_swigt__p_IMP__algebra__ParabolicFit2D, _p_IMP__algebra__ParabolicFit2DTo_p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0},  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_2_t, _p_IMP__algebra__PrincipalComponentAnalysisDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0},  {&_swigt__p_IMP__algebra__Rotation2D, _p_IMP__algebra__Rotation2DTo_p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0},  {&_swigt__p_IMP__algebra__SphereDT_2_t, _p_IMP__algebra__SphereDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0},  {&_swigt__p_IMP__algebra__Transformation2D, _p_IMP__algebra__Transformation2DTo_p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexBaseDT_2_t, _p_IMP__algebra__UnitSimplexBaseDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexDT_2_t, _p_IMP__algebra__UnitSimplexDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorBaseDT_2_t, _p_IMP__algebra__VectorBaseDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorDT_2_t, _p_IMP__algebra__VectorDT_2_tTo_p_IMP__algebra__GeometricPrimitiveDT_2_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexBaseDT_3_t[] = {{&_swigt__p_IMP__algebra__UnitSimplexBaseDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorBaseDT_3_t[] = {{&_swigt__p_IMP__algebra__VectorBaseDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GeometricPrimitiveDT_3_t[] = {  {&_swigt__p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0, 0},  {&_swigt__p_IMP__algebra__Cone3D, _p_IMP__algebra__Cone3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__Cylinder3D, _p_IMP__algebra__Cylinder3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__Ellipsoid3D, _p_IMP__algebra__Ellipsoid3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__FixedXYZ, _p_IMP__algebra__FixedXYZTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__Gaussian3D, _p_IMP__algebra__Gaussian3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__Line3D, _p_IMP__algebra__Line3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__Plane3D, _p_IMP__algebra__Plane3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_3_t, _p_IMP__algebra__PrincipalComponentAnalysisDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__Reflection3D, _p_IMP__algebra__Reflection3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__Rotation3D, _p_IMP__algebra__Rotation3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__Segment3D, _p_IMP__algebra__Segment3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__SphereDT_3_t, _p_IMP__algebra__SphereDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__SpherePatch3D, _p_IMP__algebra__SpherePatch3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__SphericalVector3D, _p_IMP__algebra__SphericalVector3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__Transformation3D, _p_IMP__algebra__Transformation3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__Triangle3D, _p_IMP__algebra__Triangle3DTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexBaseDT_3_t, _p_IMP__algebra__UnitSimplexBaseDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexDT_3_t, _p_IMP__algebra__UnitSimplexDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorBaseDT_3_t, _p_IMP__algebra__VectorBaseDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorDT_3_t, _p_IMP__algebra__VectorDT_3_tTo_p_IMP__algebra__GeometricPrimitiveDT_3_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexBaseDT_4_t[] = {{&_swigt__p_IMP__algebra__UnitSimplexBaseDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorBaseDT_4_t[] = {{&_swigt__p_IMP__algebra__VectorBaseDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GeometricPrimitiveDT_4_t[] = {  {&_swigt__p_IMP__algebra__GeometricPrimitiveDT_4_t, 0, 0, 0},  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_4_t, _p_IMP__algebra__PrincipalComponentAnalysisDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t, 0, 0},  {&_swigt__p_IMP__algebra__SphereDT_4_t, _p_IMP__algebra__SphereDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexBaseDT_4_t, _p_IMP__algebra__UnitSimplexBaseDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexDT_4_t, _p_IMP__algebra__UnitSimplexDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorBaseDT_4_t, _p_IMP__algebra__VectorBaseDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorDT_4_t, _p_IMP__algebra__VectorDT_4_tTo_p_IMP__algebra__GeometricPrimitiveDT_4_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexBaseDT_5_t[] = {{&_swigt__p_IMP__algebra__UnitSimplexBaseDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorBaseDT_5_t[] = {{&_swigt__p_IMP__algebra__VectorBaseDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GeometricPrimitiveDT_5_t[] = {  {&_swigt__p_IMP__algebra__GeometricPrimitiveDT_5_t, 0, 0, 0},  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_5_t, _p_IMP__algebra__PrincipalComponentAnalysisDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t, 0, 0},  {&_swigt__p_IMP__algebra__SphereDT_5_t, _p_IMP__algebra__SphereDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexBaseDT_5_t, _p_IMP__algebra__UnitSimplexBaseDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexDT_5_t, _p_IMP__algebra__UnitSimplexDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorBaseDT_5_t, _p_IMP__algebra__VectorBaseDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorDT_5_t, _p_IMP__algebra__VectorDT_5_tTo_p_IMP__algebra__GeometricPrimitiveDT_5_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexBaseDT_6_t[] = {{&_swigt__p_IMP__algebra__UnitSimplexBaseDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorBaseDT_6_t[] = {{&_swigt__p_IMP__algebra__VectorBaseDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GeometricPrimitiveDT_6_t[] = {  {&_swigt__p_IMP__algebra__GeometricPrimitiveDT_6_t, 0, 0, 0},  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_6_t, _p_IMP__algebra__PrincipalComponentAnalysisDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t, 0, 0},  {&_swigt__p_IMP__algebra__SphereDT_6_t, _p_IMP__algebra__SphereDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexBaseDT_6_t, _p_IMP__algebra__UnitSimplexBaseDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexDT_6_t, _p_IMP__algebra__UnitSimplexDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorBaseDT_6_t, _p_IMP__algebra__VectorBaseDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorDT_6_t, _p_IMP__algebra__VectorDT_6_tTo_p_IMP__algebra__GeometricPrimitiveDT_6_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexBaseDT__1_t[] = {{&_swigt__p_IMP__algebra__UnitSimplexBaseDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorBaseDT__1_t[] = {{&_swigt__p_IMP__algebra__VectorBaseDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GeometricPrimitiveDT__1_t[] = {  {&_swigt__p_IMP__algebra__GeometricPrimitiveDT__1_t, 0, 0, 0},  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT__1_t, _p_IMP__algebra__PrincipalComponentAnalysisDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t, 0, 0},  {&_swigt__p_IMP__algebra__SphereDT__1_t, _p_IMP__algebra__SphereDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexBaseDT__1_t, _p_IMP__algebra__UnitSimplexBaseDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t, 0, 0},  {&_swigt__p_IMP__algebra__UnitSimplexDT__1_t, _p_IMP__algebra__UnitSimplexDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorBaseDT__1_t, _p_IMP__algebra__VectorBaseDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t, 0, 0},  {&_swigt__p_IMP__algebra__VectorDT__1_t, _p_IMP__algebra__VectorDT__1_tTo_p_IMP__algebra__GeometricPrimitiveDT__1_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GridIndexDT_1_t[] = {  {&_swigt__p_IMP__algebra__GridIndexDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GridIndexDT_2_t[] = {  {&_swigt__p_IMP__algebra__GridIndexDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GridIndexDT_3_t[] = {  {&_swigt__p_IMP__algebra__GridIndexDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GridIndexDT_4_t[] = {  {&_swigt__p_IMP__algebra__GridIndexDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GridIndexDT_5_t[] = {  {&_swigt__p_IMP__algebra__GridIndexDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GridIndexDT_6_t[] = {  {&_swigt__p_IMP__algebra__GridIndexDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__GridIndexDT__1_t[] = {  {&_swigt__p_IMP__algebra__GridIndexDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Line3D[] = {  {&_swigt__p_IMP__algebra__Line3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__LinearFit2D[] = {  {&_swigt__p_IMP__algebra__LinearFit2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__LogEmbeddingDT_1_t[] = {  {&_swigt__p_IMP__algebra__LogEmbeddingDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__LogEmbeddingDT_2_t[] = {  {&_swigt__p_IMP__algebra__LogEmbeddingDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__LogEmbeddingDT_3_t[] = {  {&_swigt__p_IMP__algebra__LogEmbeddingDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__LogEmbeddingDT_4_t[] = {  {&_swigt__p_IMP__algebra__LogEmbeddingDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__LogEmbeddingDT_5_t[] = {  {&_swigt__p_IMP__algebra__LogEmbeddingDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__LogEmbeddingDT_6_t[] = {  {&_swigt__p_IMP__algebra__LogEmbeddingDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__LogEmbeddingDT__1_t[] = {  {&_swigt__p_IMP__algebra__LogEmbeddingDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__MaxVectorKDMetric[] = {  {&_swigt__p_IMP__algebra__MaxVectorKDMetric, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__NearestNeighborDT_1_t[] = {  {&_swigt__p_IMP__algebra__NearestNeighborDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__NearestNeighborDT_2_t[] = {  {&_swigt__p_IMP__algebra__NearestNeighborDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__NearestNeighborDT_3_t[] = {  {&_swigt__p_IMP__algebra__NearestNeighborDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__NearestNeighborDT_4_t[] = {  {&_swigt__p_IMP__algebra__NearestNeighborDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__NearestNeighborDT_5_t[] = {  {&_swigt__p_IMP__algebra__NearestNeighborDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__NearestNeighborDT_6_t[] = {  {&_swigt__p_IMP__algebra__NearestNeighborDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__NearestNeighborDT__1_t[] = {  {&_swigt__p_IMP__algebra__NearestNeighborDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__ParabolicFit2D[] = {  {&_swigt__p_IMP__algebra__ParabolicFit2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Plane3D[] = {  {&_swigt__p_IMP__algebra__Plane3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_1_t[] = {  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_2_t[] = {  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_3_t[] = {  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_4_t[] = {  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_5_t[] = {  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_6_t[] = {  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT__1_t[] = {  {&_swigt__p_IMP__algebra__PrincipalComponentAnalysisDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__ReferenceFrame3D[] = {  {&_swigt__p_IMP__algebra__ReferenceFrame3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Reflection3D[] = {  {&_swigt__p_IMP__algebra__Reflection3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Rotation2D[] = {  {&_swigt__p_IMP__algebra__Rotation2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Rotation3D[] = {  {&_swigt__p_IMP__algebra__Rotation3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Segment3D[] = {  {&_swigt__p_IMP__algebra__Segment3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__SphereDT_1_t[] = {  {&_swigt__p_IMP__algebra__SphereDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__SphereDT_2_t[] = {  {&_swigt__p_IMP__algebra__SphereDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__SphereDT_3_t[] = {  {&_swigt__p_IMP__algebra__SphereDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__SphereDT_4_t[] = {  {&_swigt__p_IMP__algebra__SphereDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__SphereDT_5_t[] = {  {&_swigt__p_IMP__algebra__SphereDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__SphereDT_6_t[] = {  {&_swigt__p_IMP__algebra__SphereDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__SphereDT__1_t[] = {  {&_swigt__p_IMP__algebra__SphereDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__SpherePatch3D[] = {  {&_swigt__p_IMP__algebra__SpherePatch3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__SphericalVector3D[] = {  {&_swigt__p_IMP__algebra__SphericalVector3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Transformation2D[] = {  {&_swigt__p_IMP__algebra__Transformation2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Transformation3D[] = {  {&_swigt__p_IMP__algebra__Transformation3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__Triangle3D[] = {  {&_swigt__p_IMP__algebra__Triangle3D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnboundedGridRangeDT_1_t[] = {  {&_swigt__p_IMP__algebra__UnboundedGridRangeDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnboundedGridRangeDT_2_t[] = {  {&_swigt__p_IMP__algebra__UnboundedGridRangeDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnboundedGridRangeDT_3_t[] = {  {&_swigt__p_IMP__algebra__UnboundedGridRangeDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnboundedGridRangeDT_4_t[] = {  {&_swigt__p_IMP__algebra__UnboundedGridRangeDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnboundedGridRangeDT_5_t[] = {  {&_swigt__p_IMP__algebra__UnboundedGridRangeDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnboundedGridRangeDT_6_t[] = {  {&_swigt__p_IMP__algebra__UnboundedGridRangeDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnboundedGridRangeDT__1_t[] = {  {&_swigt__p_IMP__algebra__UnboundedGridRangeDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexDT_1_t[] = {  {&_swigt__p_IMP__algebra__UnitSimplexDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexDT_2_t[] = {  {&_swigt__p_IMP__algebra__UnitSimplexDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexDT_3_t[] = {  {&_swigt__p_IMP__algebra__UnitSimplexDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexDT_4_t[] = {  {&_swigt__p_IMP__algebra__UnitSimplexDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexDT_5_t[] = {  {&_swigt__p_IMP__algebra__UnitSimplexDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexDT_6_t[] = {  {&_swigt__p_IMP__algebra__UnitSimplexDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__UnitSimplexDT__1_t[] = {  {&_swigt__p_IMP__algebra__UnitSimplexDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorDT_1_t[] = {  {&_swigt__p_IMP__algebra__VectorDT_1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorDT_2_t[] = {  {&_swigt__p_IMP__algebra__VectorDT_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorDT_3_t[] = {  {&_swigt__p_IMP__algebra__VectorDT_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorDT_4_t[] = {  {&_swigt__p_IMP__algebra__VectorDT_4_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorDT_5_t[] = {  {&_swigt__p_IMP__algebra__VectorDT_5_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorDT_6_t[] = {  {&_swigt__p_IMP__algebra__VectorDT_6_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorDT__1_t[] = {  {&_swigt__p_IMP__algebra__VectorDT__1_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__algebra__VectorKDMetric[] = {  {&_swigt__p_IMP__algebra__VectorKDMetric, 0, 0, 0},  {&_swigt__p_IMP__algebra__EuclideanVectorKDMetric, _p_IMP__algebra__EuclideanVectorKDMetricTo_p_IMP__algebra__VectorKDMetric, 0, 0},  {&_swigt__p_IMP__algebra__MaxVectorKDMetric, _p_IMP__algebra__MaxVectorKDMetricTo_p_IMP__algebra__VectorKDMetric, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__AllBipartitePairContainer[] = {  {&_swigt__p_IMP__container__AllBipartitePairContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__AllPairContainer[] = {  {&_swigt__p_IMP__container__AllPairContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__CloseBipartitePairContainer[] = {  {&_swigt__p_IMP__container__CloseBipartitePairContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__ClosePairContainer[] = {  {&_swigt__p_IMP__container__ClosePairContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__ConnectingPairContainer[] = {  {&_swigt__p_IMP__container__ConnectingPairContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__ConsecutivePairContainer[] = {  {&_swigt__p_IMP__container__ConsecutivePairContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__ConsecutivePairFilter[] = {  {&_swigt__p_IMP__container__ConsecutivePairFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__DistributePairsScoreState[] = {  {&_swigt__p_IMP__container__DistributePairsScoreState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__DistributeQuadsScoreState[] = {  {&_swigt__p_IMP__container__DistributeQuadsScoreState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__DistributeSingletonsScoreState[] = {  {&_swigt__p_IMP__container__DistributeSingletonsScoreState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__DistributeTripletsScoreState[] = {  {&_swigt__p_IMP__container__DistributeTripletsScoreState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__DynamicListPairContainer[] = {  {&_swigt__p_IMP__container__DynamicListPairContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__DynamicListQuadContainer[] = {  {&_swigt__p_IMP__container__DynamicListQuadContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__DynamicListSingletonContainer[] = {  {&_swigt__p_IMP__container__DynamicListSingletonContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__DynamicListTripletContainer[] = {  {&_swigt__p_IMP__container__DynamicListTripletContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__EventPairsOptimizerState[] = {  {&_swigt__p_IMP__container__EventPairsOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__EventQuadsOptimizerState[] = {  {&_swigt__p_IMP__container__EventQuadsOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__EventSingletonsOptimizerState[] = {  {&_swigt__p_IMP__container__EventSingletonsOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__EventTripletsOptimizerState[] = {  {&_swigt__p_IMP__container__EventTripletsOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__ExclusiveConsecutivePairContainer[] = {  {&_swigt__p_IMP__container__ExclusiveConsecutivePairContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__ExclusiveConsecutivePairFilter[] = {  {&_swigt__p_IMP__container__ExclusiveConsecutivePairFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__InContainerPairFilter[] = {  {&_swigt__p_IMP__container__InContainerPairFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__InContainerQuadFilter[] = {  {&_swigt__p_IMP__container__InContainerQuadFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__InContainerSingletonFilter[] = {  {&_swigt__p_IMP__container__InContainerSingletonFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__InContainerTripletFilter[] = {  {&_swigt__p_IMP__container__InContainerTripletFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__ListPairContainer[] = {  {&_swigt__p_IMP__container__ListPairContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__ListQuadContainer[] = {  {&_swigt__p_IMP__container__ListQuadContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__ListSingletonContainer[] = {  {&_swigt__p_IMP__container__ListSingletonContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__ListTripletContainer[] = {  {&_swigt__p_IMP__container__ListTripletContainer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__MinimumPairRestraint[] = {  {&_swigt__p_IMP__container__MinimumPairRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__MinimumPairScore[] = {  {&_swigt__p_IMP__container__MinimumPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__MinimumQuadRestraint[] = {  {&_swigt__p_IMP__container__MinimumQuadRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__MinimumQuadScore[] = {  {&_swigt__p_IMP__container__MinimumQuadScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__MinimumSingletonRestraint[] = {  {&_swigt__p_IMP__container__MinimumSingletonRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__MinimumSingletonScore[] = {  {&_swigt__p_IMP__container__MinimumSingletonScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__MinimumTripletRestraint[] = {  {&_swigt__p_IMP__container__MinimumTripletRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__MinimumTripletScore[] = {  {&_swigt__p_IMP__container__MinimumTripletScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__PairContainerSet[] = {  {&_swigt__p_IMP__container__PairContainerSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__PairContainerStatistics[] = {  {&_swigt__p_IMP__container__PairContainerStatistics, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__PairsConstraint[] = {  {&_swigt__p_IMP__container__PairsConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__PairsOptimizerState[] = {  {&_swigt__p_IMP__container__PairsOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__PairsRestraint[] = {  {&_swigt__p_IMP__container__PairsRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__PredicatePairsRestraint[] = {  {&_swigt__p_IMP__container__PredicatePairsRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__PredicateQuadsRestraint[] = {  {&_swigt__p_IMP__container__PredicateQuadsRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__PredicateSingletonsRestraint[] = {  {&_swigt__p_IMP__container__PredicateSingletonsRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__PredicateTripletsRestraint[] = {  {&_swigt__p_IMP__container__PredicateTripletsRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__QuadContainerSet[] = {  {&_swigt__p_IMP__container__QuadContainerSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__QuadContainerStatistics[] = {  {&_swigt__p_IMP__container__QuadContainerStatistics, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__QuadsConstraint[] = {  {&_swigt__p_IMP__container__QuadsConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__QuadsOptimizerState[] = {  {&_swigt__p_IMP__container__QuadsOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__QuadsRestraint[] = {  {&_swigt__p_IMP__container__QuadsRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__SingletonContainerSet[] = {  {&_swigt__p_IMP__container__SingletonContainerSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__SingletonContainerStatistics[] = {  {&_swigt__p_IMP__container__SingletonContainerStatistics, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__SingletonsConstraint[] = {  {&_swigt__p_IMP__container__SingletonsConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__SingletonsOptimizerState[] = {  {&_swigt__p_IMP__container__SingletonsOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__SingletonsRestraint[] = {  {&_swigt__p_IMP__container__SingletonsRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__TripletContainerSet[] = {  {&_swigt__p_IMP__container__TripletContainerSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__TripletContainerStatistics[] = {  {&_swigt__p_IMP__container__TripletContainerStatistics, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__TripletsConstraint[] = {  {&_swigt__p_IMP__container__TripletsConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__TripletsOptimizerState[] = {  {&_swigt__p_IMP__container__TripletsOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__container__TripletsRestraint[] = {  {&_swigt__p_IMP__container__TripletsRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__AllSamePairPredicate[] = {  {&_swigt__p_IMP__core__AllSamePairPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__AllSameQuadPredicate[] = {  {&_swigt__p_IMP__core__AllSameQuadPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__AllSameSingletonPredicate[] = {  {&_swigt__p_IMP__core__AllSameSingletonPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__AllSameTripletPredicate[] = {  {&_swigt__p_IMP__core__AllSameTripletPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__AngleRestraint[] = {  {&_swigt__p_IMP__core__AngleRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__AngleTripletScore[] = {  {&_swigt__p_IMP__core__AngleTripletScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__AttributeSingletonPredicate[] = {  {&_swigt__p_IMP__core__AttributeSingletonPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__BallMover[] = {  {&_swigt__p_IMP__core__BallMover, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__BinormalTerm[] = {  {&_swigt__p_IMP__core__BinormalTerm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__BoxSweepClosePairsFinder[] = {  {&_swigt__p_IMP__core__BoxSweepClosePairsFinder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Centroid[] = {  {&_swigt__p_IMP__core__Centroid, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__CentroidOfRefined[] = {  {&_swigt__p_IMP__core__CentroidOfRefined, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ChecksScoreState[] = {  {&_swigt__p_IMP__core__ChecksScoreState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ChildrenRefiner[] = {  {&_swigt__p_IMP__core__ChildrenRefiner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ClosePairsFinder[] = {  {&_swigt__p_IMP__core__ClosePairsFinder, 0, 0, 0},  {&_swigt__p_IMP__core__BoxSweepClosePairsFinder, _p_IMP__core__BoxSweepClosePairsFinderTo_p_IMP__core__ClosePairsFinder, 0, 0},  {&_swigt__p_IMP__core__GridClosePairsFinder, _p_IMP__core__GridClosePairsFinderTo_p_IMP__core__ClosePairsFinder, 0, 0},  {&_swigt__p_IMP__core__NearestNeighborsClosePairsFinder, _p_IMP__core__NearestNeighborsClosePairsFinderTo_p_IMP__core__ClosePairsFinder, 0, 0},  {&_swigt__p_IMP__core__QuadraticClosePairsFinder, _p_IMP__core__QuadraticClosePairsFinderTo_p_IMP__core__ClosePairsFinder, 0, 0},  {&_swigt__p_IMP__core__RigidClosePairsFinder, _p_IMP__core__RigidClosePairsFinderTo_p_IMP__core__ClosePairsFinder, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ClosePairsPairScore[] = {  {&_swigt__p_IMP__core__ClosePairsPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ClosedCubicSpline[] = {  {&_swigt__p_IMP__core__ClosedCubicSpline, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ClusterProvenance[] = {  {&_swigt__p_IMP__core__ClusterProvenance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__CoinFlipPairPredicate[] = {  {&_swigt__p_IMP__core__CoinFlipPairPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__CoinFlipQuadPredicate[] = {  {&_swigt__p_IMP__core__CoinFlipQuadPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__CoinFlipSingletonPredicate[] = {  {&_swigt__p_IMP__core__CoinFlipSingletonPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__CoinFlipTripletPredicate[] = {  {&_swigt__p_IMP__core__CoinFlipTripletPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__CombineProvenance[] = {  {&_swigt__p_IMP__core__CombineProvenance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ConjugateGradients[] = {  {&_swigt__p_IMP__core__ConjugateGradients, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ConnectivityRestraint[] = {  {&_swigt__p_IMP__core__ConnectivityRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ConstantPairPredicate[] = {  {&_swigt__p_IMP__core__ConstantPairPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ConstantQuadPredicate[] = {  {&_swigt__p_IMP__core__ConstantQuadPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ConstantRestraint[] = {  {&_swigt__p_IMP__core__ConstantRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ConstantSingletonPredicate[] = {  {&_swigt__p_IMP__core__ConstantSingletonPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ConstantTripletPredicate[] = {  {&_swigt__p_IMP__core__ConstantTripletPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Cosine[] = {  {&_swigt__p_IMP__core__Cosine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Cover[] = {  {&_swigt__p_IMP__core__Cover, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__CoverRefined[] = {  {&_swigt__p_IMP__core__CoverRefined, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__DerivativesFromRefined[] = {  {&_swigt__p_IMP__core__DerivativesFromRefined, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__DerivativesToRefined[] = {  {&_swigt__p_IMP__core__DerivativesToRefined, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__DiameterRestraint[] = {  {&_swigt__p_IMP__core__DiameterRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__DihedralRestraint[] = {  {&_swigt__p_IMP__core__DihedralRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Direction[] = {  {&_swigt__p_IMP__core__Direction, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__DirectionAngle[] = {  {&_swigt__p_IMP__core__DirectionAngle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__DirectionMover[] = {  {&_swigt__p_IMP__core__DirectionMover, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__DistancePairScore[] = {  {&_swigt__p_IMP__core__DistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__DistanceRestraint[] = {  {&_swigt__p_IMP__core__DistanceRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__EdgePairGeometry[] = {  {&_swigt__p_IMP__core__EdgePairGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__EdgePairsGeometry[] = {  {&_swigt__p_IMP__core__EdgePairsGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ExcludedVolumeRestraint[] = {  {&_swigt__p_IMP__core__ExcludedVolumeRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__FilterProvenance[] = {  {&_swigt__p_IMP__core__FilterProvenance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__FixedRefiner[] = {  {&_swigt__p_IMP__core__FixedRefiner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Gaussian[] = {  {&_swigt__p_IMP__core__Gaussian, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t[] = {  {&_swigt__p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t[] = {  {&_swigt__p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t[] = {  {&_swigt__p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t[] = {  {&_swigt__p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__GridClosePairsFinder[] = {  {&_swigt__p_IMP__core__GridClosePairsFinder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Harmonic[] = {  {&_swigt__p_IMP__core__Harmonic, 0, 0, 0},  {&_swigt__p_IMP__core__HarmonicLowerBound, _p_IMP__core__HarmonicLowerBoundTo_p_IMP__core__Harmonic, 0, 0},  {&_swigt__p_IMP__core__HarmonicUpperBound, _p_IMP__core__HarmonicUpperBoundTo_p_IMP__core__Harmonic, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HarmonicDistancePairScore[] = {  {&_swigt__p_IMP__core__HarmonicDistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HarmonicLowerBound[] = {  {&_swigt__p_IMP__core__HarmonicLowerBound, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HarmonicSphereDistancePairScore[] = {  {&_swigt__p_IMP__core__HarmonicSphereDistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HarmonicSurfaceDepthPairScore[] = {  {&_swigt__p_IMP__core__HarmonicSurfaceDepthPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HarmonicSurfaceDistancePairScore[] = {  {&_swigt__p_IMP__core__HarmonicSurfaceDistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HarmonicSurfaceHeightPairScore[] = {  {&_swigt__p_IMP__core__HarmonicSurfaceHeightPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HarmonicUpperBound[] = {  {&_swigt__p_IMP__core__HarmonicUpperBound, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore[] = {  {&_swigt__p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HarmonicUpperBoundSphereDistancePairScore[] = {  {&_swigt__p_IMP__core__HarmonicUpperBoundSphereDistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HarmonicWell[] = {  {&_swigt__p_IMP__core__HarmonicWell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Hierarchy[] = {  {&_swigt__p_IMP__core__Hierarchy, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HierarchyCounter[] = {  {&_swigt__p_IMP__core__HierarchyCounter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__HierarchyTraits[] = {  {&_swigt__p_IMP__core__HierarchyTraits, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__InBoundingBox3DSingletonPredicate[] = {  {&_swigt__p_IMP__core__InBoundingBox3DSingletonPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__IsCollisionPairPredicate[] = {  {&_swigt__p_IMP__core__IsCollisionPairPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__KClosePairsPairScore[] = {  {&_swigt__p_IMP__core__KClosePairsPairScore, 0, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDistancePairScore, _p_IMP__core__RigidBodyDistancePairScoreTo_p_IMP__core__KClosePairsPairScore, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__LateralSurfaceConstraint[] = {  {&_swigt__p_IMP__core__LateralSurfaceConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__LeavesRefiner[] = {  {&_swigt__p_IMP__core__LeavesRefiner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Linear[] = {  {&_swigt__p_IMP__core__Linear, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__LogNormalMover[] = {  {&_swigt__p_IMP__core__LogNormalMover, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__MCCGSampler[] = {  {&_swigt__p_IMP__core__MCCGSampler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__MSConnectivityRestraint[] = {  {&_swigt__p_IMP__core__MSConnectivityRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__MinimumRestraint[] = {  {&_swigt__p_IMP__core__MinimumRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__MonteCarlo[] = {  {&_swigt__p_IMP__core__MonteCarlo, 0, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithBasinHopping, _p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__core__MonteCarlo, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithLocalOptimization, _p_IMP__core__MonteCarloWithLocalOptimizationTo_p_IMP__core__MonteCarlo, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__MonteCarloMover[] = {  {&_swigt__p_IMP__core__MonteCarloMover, 0, 0, 0},  {&_swigt__p_IMP__core__BallMover, _p_IMP__core__BallMoverTo_p_IMP__core__MonteCarloMover, 0, 0},  {&_swigt__p_IMP__core__DirectionMover, _p_IMP__core__DirectionMoverTo_p_IMP__core__MonteCarloMover, 0, 0},  {&_swigt__p_IMP__core__LogNormalMover, _p_IMP__core__LogNormalMoverTo_p_IMP__core__MonteCarloMover, 0, 0},  {&_swigt__p_IMP__core__NormalMover, _p_IMP__core__NormalMoverTo_p_IMP__core__MonteCarloMover, 0, 0},  {&_swigt__p_IMP__core__RigidBodyMover, _p_IMP__core__RigidBodyMoverTo_p_IMP__core__MonteCarloMover, 0, 0},  {&_swigt__p_IMP__core__RigidBodyTunneler, _p_IMP__core__RigidBodyTunnelerTo_p_IMP__core__MonteCarloMover, 0, 0},  {&_swigt__p_IMP__core__SerialMover, _p_IMP__core__SerialMoverTo_p_IMP__core__MonteCarloMover, 0, 0},  {&_swigt__p_IMP__core__SubsetMover, _p_IMP__core__SubsetMoverTo_p_IMP__core__MonteCarloMover, 0, 0},  {&_swigt__p_IMP__core__SurfaceMover, _p_IMP__core__SurfaceMoverTo_p_IMP__core__MonteCarloMover, 0, 0},  {&_swigt__p_IMP__core__TransformationSymmetryMover, _p_IMP__core__TransformationSymmetryMoverTo_p_IMP__core__MonteCarloMover, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__MonteCarloMoverResult[] = {  {&_swigt__p_IMP__core__MonteCarloMoverResult, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__MonteCarloWithBasinHopping[] = {  {&_swigt__p_IMP__core__MonteCarloWithBasinHopping, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__MonteCarloWithLocalOptimization[] = {  {&_swigt__p_IMP__core__MonteCarloWithLocalOptimization, 0, 0, 0},  {&_swigt__p_IMP__core__MonteCarloWithBasinHopping, _p_IMP__core__MonteCarloWithBasinHoppingTo_p_IMP__core__MonteCarloWithLocalOptimization, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__MoveStatisticsScoreState[] = {  {&_swigt__p_IMP__core__MoveStatisticsScoreState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__MultipleBinormalRestraint[] = {  {&_swigt__p_IMP__core__MultipleBinormalRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__NearestNeighborsClosePairsFinder[] = {  {&_swigt__p_IMP__core__NearestNeighborsClosePairsFinder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__NeighborsTable[] = {  {&_swigt__p_IMP__core__NeighborsTable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__NonRigidMember[] = {  {&_swigt__p_IMP__core__NonRigidMember, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__NormalMover[] = {  {&_swigt__p_IMP__core__NormalMover, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__NormalizedSphereDistancePairScore[] = {  {&_swigt__p_IMP__core__NormalizedSphereDistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__OpenCubicSpline[] = {  {&_swigt__p_IMP__core__OpenCubicSpline, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__OrderedTypePairPredicate[] = {  {&_swigt__p_IMP__core__OrderedTypePairPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__OrderedTypeQuadPredicate[] = {  {&_swigt__p_IMP__core__OrderedTypeQuadPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__OrderedTypeSingletonPredicate[] = {  {&_swigt__p_IMP__core__OrderedTypeSingletonPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__OrderedTypeTripletPredicate[] = {  {&_swigt__p_IMP__core__OrderedTypeTripletPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__PairConstraint[] = {  {&_swigt__p_IMP__core__PairConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__PairRestraint[] = {  {&_swigt__p_IMP__core__PairRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Provenance[] = {  {&_swigt__p_IMP__core__Provenance, 0, 0, 0},  {&_swigt__p_IMP__core__ClusterProvenance, _p_IMP__core__ClusterProvenanceTo_p_IMP__core__Provenance, 0, 0},  {&_swigt__p_IMP__core__CombineProvenance, _p_IMP__core__CombineProvenanceTo_p_IMP__core__Provenance, 0, 0},  {&_swigt__p_IMP__core__FilterProvenance, _p_IMP__core__FilterProvenanceTo_p_IMP__core__Provenance, 0, 0},  {&_swigt__p_IMP__core__SampleProvenance, _p_IMP__core__SampleProvenanceTo_p_IMP__core__Provenance, 0, 0},  {&_swigt__p_IMP__core__ScriptProvenance, _p_IMP__core__ScriptProvenanceTo_p_IMP__core__Provenance, 0, 0},  {&_swigt__p_IMP__core__SoftwareProvenance, _p_IMP__core__SoftwareProvenanceTo_p_IMP__core__Provenance, 0, 0},  {&_swigt__p_IMP__core__StructureProvenance, _p_IMP__core__StructureProvenanceTo_p_IMP__core__Provenance, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Provenanced[] = {  {&_swigt__p_IMP__core__Provenanced, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__QuadConstraint[] = {  {&_swigt__p_IMP__core__QuadConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__QuadRestraint[] = {  {&_swigt__p_IMP__core__QuadRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__QuadraticClosePairsFinder[] = {  {&_swigt__p_IMP__core__QuadraticClosePairsFinder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Reference[] = {  {&_swigt__p_IMP__core__Reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RefinedPairsPairScore[] = {  {&_swigt__p_IMP__core__RefinedPairsPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RestraintsScoringFunction[] = {  {&_swigt__p_IMP__core__RestraintsScoringFunction, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBody[] = {  {&_swigt__p_IMP__core__RigidBody, 0, 0, 0},  {&_swigt__p_IMP__core__Gaussian, _p_IMP__core__GaussianTo_p_IMP__core__RigidBody, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyAnglePairScore[] = {  {&_swigt__p_IMP__core__RigidBodyAnglePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyDerivativeGeometry[] = {  {&_swigt__p_IMP__core__RigidBodyDerivativeGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyDerivativesGeometry[] = {  {&_swigt__p_IMP__core__RigidBodyDerivativesGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyDistancePairScore[] = {  {&_swigt__p_IMP__core__RigidBodyDistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyFrameGeometry[] = {  {&_swigt__p_IMP__core__RigidBodyFrameGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyFramesGeometry[] = {  {&_swigt__p_IMP__core__RigidBodyFramesGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyHierarchyGeometry[] = {  {&_swigt__p_IMP__core__RigidBodyHierarchyGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyMember[] = {  {&_swigt__p_IMP__core__RigidBodyMember, 0, 0, 0},  {&_swigt__p_IMP__core__NonRigidMember, _p_IMP__core__NonRigidMemberTo_p_IMP__core__RigidBodyMember, 0, 0},  {&_swigt__p_IMP__core__RigidMember, _p_IMP__core__RigidMemberTo_p_IMP__core__RigidBodyMember, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyMover[] = {  {&_swigt__p_IMP__core__RigidBodyMover, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyTorque[] = {  {&_swigt__p_IMP__core__RigidBodyTorque, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyTunneler[] = {  {&_swigt__p_IMP__core__RigidBodyTunneler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidBodyUmbrella[] = {  {&_swigt__p_IMP__core__RigidBodyUmbrella, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidClosePairsFinder[] = {  {&_swigt__p_IMP__core__RigidClosePairsFinder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidMember[] = {  {&_swigt__p_IMP__core__RigidMember, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__RigidMembersRefiner[] = {  {&_swigt__p_IMP__core__RigidMembersRefiner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SampleProvenance[] = {  {&_swigt__p_IMP__core__SampleProvenance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__ScriptProvenance[] = {  {&_swigt__p_IMP__core__ScriptProvenance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SerialMover[] = {  {&_swigt__p_IMP__core__SerialMover, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SingletonConstraint[] = {  {&_swigt__p_IMP__core__SingletonConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SingletonRestraint[] = {  {&_swigt__p_IMP__core__SingletonRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SoftSpherePairScore[] = {  {&_swigt__p_IMP__core__SoftSpherePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SoftSubSurfacePairScore[] = {  {&_swigt__p_IMP__core__SoftSubSurfacePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SoftSuperSurfacePairScore[] = {  {&_swigt__p_IMP__core__SoftSuperSurfacePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SoftwareProvenance[] = {  {&_swigt__p_IMP__core__SoftwareProvenance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SphereDistancePairScore[] = {  {&_swigt__p_IMP__core__SphereDistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SphereDistanceToSingletonScore[] = {  {&_swigt__p_IMP__core__SphereDistanceToSingletonScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SteepestDescent[] = {  {&_swigt__p_IMP__core__SteepestDescent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__StructureProvenance[] = {  {&_swigt__p_IMP__core__StructureProvenance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SubsetMover[] = {  {&_swigt__p_IMP__core__SubsetMover, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Surface[] = {  {&_swigt__p_IMP__core__Surface, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SurfaceDepthPairScore[] = {  {&_swigt__p_IMP__core__SurfaceDepthPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SurfaceDistancePairScore[] = {  {&_swigt__p_IMP__core__SurfaceDistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SurfaceGeometry[] = {  {&_swigt__p_IMP__core__SurfaceGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SurfaceGeometryConstraint[] = {  {&_swigt__p_IMP__core__SurfaceGeometryConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SurfaceHeightPairScore[] = {  {&_swigt__p_IMP__core__SurfaceHeightPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SurfaceMover[] = {  {&_swigt__p_IMP__core__SurfaceMover, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SurfaceSymmetryConstraint[] = {  {&_swigt__p_IMP__core__SurfaceSymmetryConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__SurfaceTetheredChain[] = {  {&_swigt__p_IMP__core__SurfaceTetheredChain, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TableRefiner[] = {  {&_swigt__p_IMP__core__TableRefiner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Transform[] = {  {&_swigt__p_IMP__core__Transform, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TransformationAndReflectionSymmetry[] = {  {&_swigt__p_IMP__core__TransformationAndReflectionSymmetry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TransformationSymmetry[] = {  {&_swigt__p_IMP__core__TransformationSymmetry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TransformationSymmetryMover[] = {  {&_swigt__p_IMP__core__TransformationSymmetryMover, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TransformedDistancePairScore[] = {  {&_swigt__p_IMP__core__TransformedDistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TripletConstraint[] = {  {&_swigt__p_IMP__core__TripletConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TripletRestraint[] = {  {&_swigt__p_IMP__core__TripletRestraint, 0, 0, 0},  {&_swigt__p_IMP__core__AngleRestraint, _p_IMP__core__AngleRestraintTo_p_IMP__core__TripletRestraint, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_t[] = {  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_t[] = {  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_t[] = {  {&_swigt__p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__Typed[] = {  {&_swigt__p_IMP__core__Typed, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__TypedPairScore[] = {  {&_swigt__p_IMP__core__TypedPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__UnorderedTypePairPredicate[] = {  {&_swigt__p_IMP__core__UnorderedTypePairPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__UnorderedTypeQuadPredicate[] = {  {&_swigt__p_IMP__core__UnorderedTypeQuadPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__UnorderedTypeSingletonPredicate[] = {  {&_swigt__p_IMP__core__UnorderedTypeSingletonPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__UnorderedTypeTripletPredicate[] = {  {&_swigt__p_IMP__core__UnorderedTypeTripletPredicate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__VolumeRestraint[] = {  {&_swigt__p_IMP__core__VolumeRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__WeightedDerivativesToRefined[] = {  {&_swigt__p_IMP__core__WeightedDerivativesToRefined, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__WeightedSphereDistancePairScore[] = {  {&_swigt__p_IMP__core__WeightedSphereDistancePairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__WeightedSum[] = {  {&_swigt__p_IMP__core__WeightedSum, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__WeightedSumOfExponential[] = {  {&_swigt__p_IMP__core__WeightedSumOfExponential, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__WriteRestraintScoresOptimizerState[] = {  {&_swigt__p_IMP__core__WriteRestraintScoresOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__XYZ[] = {  {&_swigt__p_IMP__core__XYZ, 0, 0, 0},  {&_swigt__p_IMP__core__Centroid, _p_IMP__core__CentroidTo_p_IMP__core__XYZ, 0, 0},  {&_swigt__p_IMP__core__Cover, _p_IMP__core__CoverTo_p_IMP__core__XYZ, 0, 0},  {&_swigt__p_IMP__core__Gaussian, _p_IMP__core__GaussianTo_p_IMP__core__XYZ, 0, 0},  {&_swigt__p_IMP__core__NonRigidMember, _p_IMP__core__NonRigidMemberTo_p_IMP__core__XYZ, 0, 0},  {&_swigt__p_IMP__core__RigidBody, _p_IMP__core__RigidBodyTo_p_IMP__core__XYZ, 0, 0},  {&_swigt__p_IMP__core__RigidBodyMember, _p_IMP__core__RigidBodyMemberTo_p_IMP__core__XYZ, 0, 0},  {&_swigt__p_IMP__core__RigidMember, _p_IMP__core__RigidMemberTo_p_IMP__core__XYZ, 0, 0},  {&_swigt__p_IMP__core__Surface, _p_IMP__core__SurfaceTo_p_IMP__core__XYZ, 0, 0},  {&_swigt__p_IMP__core__XYZR, _p_IMP__core__XYZRTo_p_IMP__core__XYZ, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__XYZDerivativeGeometry[] = {  {&_swigt__p_IMP__core__XYZDerivativeGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__XYZDerivativesGeometry[] = {  {&_swigt__p_IMP__core__XYZDerivativesGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__XYZR[] = {  {&_swigt__p_IMP__core__XYZR, 0, 0, 0},  {&_swigt__p_IMP__core__Cover, _p_IMP__core__CoverTo_p_IMP__core__XYZR, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__XYZRGeometry[] = {  {&_swigt__p_IMP__core__XYZRGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__core__XYZRsGeometry[] = {  {&_swigt__p_IMP__core__XYZRsGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__BoundingBoxGeometry[] = {  {&_swigt__p_IMP__display__BoundingBoxGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__Color[] = {  {&_swigt__p_IMP__display__Color, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__Colored[] = {  {&_swigt__p_IMP__display__Colored, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__CylinderGeometry[] = {  {&_swigt__p_IMP__display__CylinderGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__EllipsoidGeometry[] = {  {&_swigt__p_IMP__display__EllipsoidGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__FilterGeometry[] = {  {&_swigt__p_IMP__display__FilterGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__Geometry[] = {  {&_swigt__p_IMP__display__Geometry, 0, 0, 0},  {&_swigt__p_IMP__core__EdgePairGeometry, _p_IMP__core__EdgePairGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__EdgePairsGeometry, _p_IMP__core__EdgePairsGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDerivativeGeometry, _p_IMP__core__RigidBodyDerivativeGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDerivativesGeometry, _p_IMP__core__RigidBodyDerivativesGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__RigidBodyFrameGeometry, _p_IMP__core__RigidBodyFrameGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__RigidBodyFramesGeometry, _p_IMP__core__RigidBodyFramesGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__RigidBodyHierarchyGeometry, _p_IMP__core__RigidBodyHierarchyGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__RigidBodyTorque, _p_IMP__core__RigidBodyTorqueTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__SurfaceGeometry, _p_IMP__core__SurfaceGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__XYZDerivativeGeometry, _p_IMP__core__XYZDerivativeGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__XYZDerivativesGeometry, _p_IMP__core__XYZDerivativesGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__XYZRGeometry, _p_IMP__core__XYZRGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__core__XYZRsGeometry, _p_IMP__core__XYZRsGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__BoundingBoxGeometry, _p_IMP__display__BoundingBoxGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__CylinderGeometry, _p_IMP__display__CylinderGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__EllipsoidGeometry, _p_IMP__display__EllipsoidGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__FilterGeometry, _p_IMP__display__FilterGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__GeometrySet, _p_IMP__display__GeometrySetTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__IsosurfaceGeometry, _p_IMP__display__IsosurfaceGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__LabelGeometry, _p_IMP__display__LabelGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__PairGeometry, _p_IMP__display__PairGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__PairsGeometry, _p_IMP__display__PairsGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__PlaneGeometry, _p_IMP__display__PlaneGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__PointGeometry, _p_IMP__display__PointGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__PolygonGeometry, _p_IMP__display__PolygonGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__ReferenceFrameGeometry, _p_IMP__display__ReferenceFrameGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__RestraintGeometry, _p_IMP__display__RestraintGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__RestraintSetGeometry, _p_IMP__display__RestraintSetGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__SegmentGeometry, _p_IMP__display__SegmentGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__SingletonGeometry, _p_IMP__display__SingletonGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__SingletonsGeometry, _p_IMP__display__SingletonsGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__SkinSurfaceGeometry, _p_IMP__display__SkinSurfaceGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__SphereGeometry, _p_IMP__display__SphereGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__SurfaceMeshGeometry, _p_IMP__display__SurfaceMeshGeometryTo_p_IMP__display__Geometry, 0, 0},  {&_swigt__p_IMP__display__TriangleGeometry, _p_IMP__display__TriangleGeometryTo_p_IMP__display__Geometry, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__GeometrySet[] = {  {&_swigt__p_IMP__display__GeometrySet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__IsosurfaceGeometry[] = {  {&_swigt__p_IMP__display__IsosurfaceGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__LabelGeometry[] = {  {&_swigt__p_IMP__display__LabelGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__PairGeometry[] = {  {&_swigt__p_IMP__display__PairGeometry, 0, 0, 0},  {&_swigt__p_IMP__core__EdgePairGeometry, _p_IMP__core__EdgePairGeometryTo_p_IMP__display__PairGeometry, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__PairsGeometry[] = {  {&_swigt__p_IMP__display__PairsGeometry, 0, 0, 0},  {&_swigt__p_IMP__core__EdgePairsGeometry, _p_IMP__core__EdgePairsGeometryTo_p_IMP__display__PairsGeometry, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__PlaneGeometry[] = {  {&_swigt__p_IMP__display__PlaneGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__PointGeometry[] = {  {&_swigt__p_IMP__display__PointGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__PolygonGeometry[] = {  {&_swigt__p_IMP__display__PolygonGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__PymolWriter[] = {  {&_swigt__p_IMP__display__PymolWriter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__ReferenceFrameGeometry[] = {  {&_swigt__p_IMP__display__ReferenceFrameGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__RestraintGeometry[] = {  {&_swigt__p_IMP__display__RestraintGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__RestraintSetGeometry[] = {  {&_swigt__p_IMP__display__RestraintSetGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__SegmentGeometry[] = {  {&_swigt__p_IMP__display__SegmentGeometry, 0, 0, 0},  {&_swigt__p_IMP__core__RigidBodyTorque, _p_IMP__core__RigidBodyTorqueTo_p_IMP__display__SegmentGeometry, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__SingletonGeometry[] = {  {&_swigt__p_IMP__display__SingletonGeometry, 0, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDerivativeGeometry, _p_IMP__core__RigidBodyDerivativeGeometryTo_p_IMP__display__SingletonGeometry, 0, 0},  {&_swigt__p_IMP__core__RigidBodyFrameGeometry, _p_IMP__core__RigidBodyFrameGeometryTo_p_IMP__display__SingletonGeometry, 0, 0},  {&_swigt__p_IMP__core__RigidBodyHierarchyGeometry, _p_IMP__core__RigidBodyHierarchyGeometryTo_p_IMP__display__SingletonGeometry, 0, 0},  {&_swigt__p_IMP__core__XYZDerivativeGeometry, _p_IMP__core__XYZDerivativeGeometryTo_p_IMP__display__SingletonGeometry, 0, 0},  {&_swigt__p_IMP__core__XYZRGeometry, _p_IMP__core__XYZRGeometryTo_p_IMP__display__SingletonGeometry, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__SingletonsGeometry[] = {  {&_swigt__p_IMP__display__SingletonsGeometry, 0, 0, 0},  {&_swigt__p_IMP__core__RigidBodyDerivativesGeometry, _p_IMP__core__RigidBodyDerivativesGeometryTo_p_IMP__display__SingletonsGeometry, 0, 0},  {&_swigt__p_IMP__core__RigidBodyFramesGeometry, _p_IMP__core__RigidBodyFramesGeometryTo_p_IMP__display__SingletonsGeometry, 0, 0},  {&_swigt__p_IMP__core__XYZDerivativesGeometry, _p_IMP__core__XYZDerivativesGeometryTo_p_IMP__display__SingletonsGeometry, 0, 0},  {&_swigt__p_IMP__core__XYZRsGeometry, _p_IMP__core__XYZRsGeometryTo_p_IMP__display__SingletonsGeometry, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__SkinSurfaceGeometry[] = {  {&_swigt__p_IMP__display__SkinSurfaceGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__SphereGeometry[] = {  {&_swigt__p_IMP__display__SphereGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__SurfaceMeshGeometry[] = {  {&_swigt__p_IMP__display__SurfaceMeshGeometry, 0, 0, 0},  {&_swigt__p_IMP__display__IsosurfaceGeometry, _p_IMP__display__IsosurfaceGeometryTo_p_IMP__display__SurfaceMeshGeometry, 0, 0},  {&_swigt__p_IMP__display__SkinSurfaceGeometry, _p_IMP__display__SkinSurfaceGeometryTo_p_IMP__display__SurfaceMeshGeometry, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__TextWriter[] = {  {&_swigt__p_IMP__display__TextWriter, 0, 0, 0},  {&_swigt__p_IMP__display__PymolWriter, _p_IMP__display__PymolWriterTo_p_IMP__display__TextWriter, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__TriangleGeometry[] = {  {&_swigt__p_IMP__display__TriangleGeometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__WriteOptimizerState[] = {  {&_swigt__p_IMP__display__WriteOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__Writer[] = {  {&_swigt__p_IMP__display__Writer, 0, 0, 0},  {&_swigt__p_IMP__display__PymolWriter, _p_IMP__display__PymolWriterTo_p_IMP__display__Writer, 0, 0},  {&_swigt__p_IMP__display__TextWriter, _p_IMP__display__TextWriterTo_p_IMP__display__Writer, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__display__WriterAdaptor[] = {  {&_swigt__p_IMP__display__WriterAdaptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__insulinsecretion__CaChannelOpeningOptimizerState[] = {  {&_swigt__p_IMP__insulinsecretion__CaChannelOpeningOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__insulinsecretion__CaChannelStateDecorator[] = {  {&_swigt__p_IMP__insulinsecretion__CaChannelStateDecorator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__insulinsecretion__DockingStateDecorator[] = {  {&_swigt__p_IMP__insulinsecretion__DockingStateDecorator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__insulinsecretion__InsulinSecretionOptimizerState[] = {  {&_swigt__p_IMP__insulinsecretion__InsulinSecretionOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__insulinsecretion__MaturationStateDecorator[] = {  {&_swigt__p_IMP__insulinsecretion__MaturationStateDecorator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore[] = {  {&_swigt__p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__insulinsecretion__SecretionCounterDecorator[] = {  {&_swigt__p_IMP__insulinsecretion__SecretionCounterDecorator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__insulinsecretion__VesicleDockingOptimizerState[] = {  {&_swigt__p_IMP__insulinsecretion__VesicleDockingOptimizerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__insulinsecretion__VesicleTraffickingSingletonScore[] = {  {&_swigt__p_IMP__insulinsecretion__VesicleTraffickingSingletonScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_t[] = {  {&_swigt__p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___ConstOptimizer[] = {  {&_swigt__p_IMP__internal___ConstOptimizer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___ConstPairScore[] = {  {&_swigt__p_IMP__internal___ConstPairScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___ConstRestraint[] = {  {&_swigt__p_IMP__internal___ConstRestraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___ConstSingletonScore[] = {  {&_swigt__p_IMP__internal___ConstSingletonScore, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___Protection[] = {  {&_swigt__p_IMP__internal___Protection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___TestObject[] = {  {&_swigt__p_IMP__internal___TestObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___TestValue[] = {  {&_swigt__p_IMP__internal___TestValue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___TrivialDecorator[] = {  {&_swigt__p_IMP__internal___TrivialDecorator, 0, 0, 0},  {&_swigt__p_IMP__internal___TrivialDerivedDecorator, _p_IMP__internal___TrivialDerivedDecoratorTo_p_IMP__internal___TrivialDecorator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___TrivialDerivedDecorator[] = {  {&_swigt__p_IMP__internal___TrivialDerivedDecorator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__internal___TrivialTraitsDecorator[] = {  {&_swigt__p_IMP__internal___TrivialTraitsDecorator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__HarmonicLowerBound_t[] = {  {&_swigt__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__HarmonicLowerBound_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t[] = {  {&_swigt__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t[] = {  {&_swigt__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t[] = {  {&_swigt__p_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__HarmonicLowerBound_t[] = {  {&_swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__HarmonicLowerBound_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__HarmonicUpperBound_t_t[] = {  {&_swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__HarmonicUpperBound_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t[] = {  {&_swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t[] = {  {&_swigt__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Index[] = {  {&_swigt__p_Index, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IndexArgument[] = {  {&_swigt__p_IndexArgument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Modifier[] = {  {&_swigt__p_Modifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_P[] = {  {&_swigt__p_P, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ParentDecorator[] = {  {&_swigt__p_ParentDecorator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PassContainedIndexType[] = {  {&_swigt__p_PassContainedIndexType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PassIndexArgument[] = {  {&_swigt__p_PassIndexArgument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ScoreIsGoodPair[] = {  {&_swigt__p_ScoreIsGoodPair, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexDescriptor[] = {  {&_swigt__p_VertexDescriptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexDescriptors[] = {  {&_swigt__p_VertexDescriptors, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexName[] = {  {&_swigt__p_VertexName, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_first_type[] = {  {&_swigt__p_first_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_second_type[] = {  {&_swigt__p_second_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__invalid_argument[] = {  {&_swigt__p_std__invalid_argument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostream[] = {  {&_swigt__p_std__ostream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_IMP__algebra__VectorDT_3_t_IMP__algebra__VectorDT_4_t_t[] = {  {&_swigt__p_std__pairT_IMP__algebra__VectorDT_3_t_IMP__algebra__VectorDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_IMP__algebra__VectorDT_3_t_double_t[] = {  {&_swigt__p_std__pairT_IMP__algebra__VectorDT_3_t_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_IMP__algebra__VectorDT_3_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t[] = {  {&_swigt__p_std__pairT_IMP__algebra__VectorDT_3_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t[] = {  {&_swigt__p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_4_t_t[] = {  {&_swigt__p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_double_double_t[] = {  {&_swigt__p_std__pairT_double_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_int_int_t[] = {  {&_swigt__p_std__pairT_int_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t[] = {  {&_swigt__p_std__pairT_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__IMP_INSULINSECRETION_SwigPyIterator[] = {  {&_swigt__p_swig__IMP_INSULINSECRETION_SwigPyIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Argument,
  _swigc__p_ContainedIndexType,
  _swigc__p_ContainedIndexTypes,
  _swigc__p_ContainedType,
  _swigc__p_ContainedTypes,
  _swigc__p_DecoratorHasTraits,
  _swigc__p_DecoratorTraits,
  _swigc__p_Eigen__ArrayXXd,
  _swigc__p_Eigen__ArrayXXf,
  _swigc__p_Eigen__Matrix3d,
  _swigc__p_Eigen__MatrixXd,
  _swigc__p_Eigen__MatrixXf,
  _swigc__p_Eigen__Vector3d,
  _swigc__p_Eigen__VectorXd,
  _swigc__p_Eigen__VectorXf,
  _swigc__p_ExtendedIndex,
  _swigc__p_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t,
  _swigc__p_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t,
  _swigc__p_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t,
  _swigc__p_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t,
  _swigc__p_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t,
  _swigc__p_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t,
  _swigc__p_IMP__AttributeOptimizer,
  _swigc__p_IMP__CheckLevel,
  _swigc__p_IMP__Configuration,
  _swigc__p_IMP__ConfigurationSet,
  _swigc__p_IMP__Constraint,
  _swigc__p_IMP__Container,
  _swigc__p_IMP__CreateLogContext,
  _swigc__p_IMP__Decorator,
  _swigc__p_IMP__DerivativeAccumulator,
  _swigc__p_IMP__EvaluationState,
  _swigc__p_IMP__FloatIndex,
  _swigc__p_IMP__IndexT_IMP__ParticleIndexTag_t,
  _swigc__p_IMP__KeyT_0_t,
  _swigc__p_IMP__KeyT_10_t,
  _swigc__p_IMP__KeyT_11_t,
  _swigc__p_IMP__KeyT_12_t,
  _swigc__p_IMP__KeyT_13_t,
  _swigc__p_IMP__KeyT_14_t,
  _swigc__p_IMP__KeyT_15_t,
  _swigc__p_IMP__KeyT_1_t,
  _swigc__p_IMP__KeyT_2_t,
  _swigc__p_IMP__KeyT_34897493_t,
  _swigc__p_IMP__KeyT_3_t,
  _swigc__p_IMP__KeyT_4_t,
  _swigc__p_IMP__KeyT_5_t,
  _swigc__p_IMP__KeyT_6_t,
  _swigc__p_IMP__KeyT_7_t,
  _swigc__p_IMP__KeyT_8_t,
  _swigc__p_IMP__KeyT_9_t,
  _swigc__p_IMP__Model,
  _swigc__p_IMP__ModelObject,
  _swigc__p_IMP__NonCopyable,
  _swigc__p_IMP__Object,
  _swigc__p_IMP__Optimizer,
  _swigc__p_IMP__OptimizerState,
  _swigc__p_IMP__PairContainer,
  _swigc__p_IMP__PairModifier,
  _swigc__p_IMP__PairPredicate,
  _swigc__p_IMP__PairScore,
  _swigc__p_IMP__Particle,
  _swigc__p_IMP__ParticleAdaptor,
  _swigc__p_IMP__ParticleIndexesAdaptor,
  _swigc__p_IMP__ParticleInputs,
  _swigc__p_IMP__QuadContainer,
  _swigc__p_IMP__QuadModifier,
  _swigc__p_IMP__QuadPredicate,
  _swigc__p_IMP__QuadScore,
  _swigc__p_IMP__RAII,
  _swigc__p_IMP__Refiner,
  _swigc__p_IMP__Restraint,
  _swigc__p_IMP__RestraintInfo,
  _swigc__p_IMP__RestraintSet,
  _swigc__p_IMP__Sampler,
  _swigc__p_IMP__SaveToConfigurationSetOptimizerState,
  _swigc__p_IMP__ScopedSetAttributeT_IMP__KeyT_0_t_double_t,
  _swigc__p_IMP__ScoreAccumulator,
  _swigc__p_IMP__ScoreState,
  _swigc__p_IMP__ScoringFunction,
  _swigc__p_IMP__SetCheckState,
  _swigc__p_IMP__SetLogState,
  _swigc__p_IMP__SetLogTarget,
  _swigc__p_IMP__SetNumberOfThreads,
  _swigc__p_IMP__SingletonContainer,
  _swigc__p_IMP__SingletonContainerAdaptor,
  _swigc__p_IMP__SingletonModifier,
  _swigc__p_IMP__SingletonPredicate,
  _swigc__p_IMP__SingletonScore,
  _swigc__p_IMP__TripletContainer,
  _swigc__p_IMP__TripletModifier,
  _swigc__p_IMP__TripletPredicate,
  _swigc__p_IMP__TripletScore,
  _swigc__p_IMP__UnaryFunction,
  _swigc__p_IMP__Undecorator,
  _swigc__p_IMP__Value,
  _swigc__p_IMP__VectorT_IMP__ArrayT_2_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t,
  _swigc__p_IMP__VectorT_IMP__ArrayT_2_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t,
  _swigc__p_IMP__VectorT_IMP__ArrayT_3_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t,
  _swigc__p_IMP__VectorT_IMP__ArrayT_3_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t,
  _swigc__p_IMP__VectorT_IMP__ArrayT_4_IMP__IndexT_IMP__ParticleIndexTag_t_IMP__IndexT_IMP__ParticleIndexTag_t_t_t,
  _swigc__p_IMP__VectorT_IMP__ArrayT_4_WeakPointerT_IMP__Particle_t_IMP__Particle_p_t_t,
  _swigc__p_IMP__VectorT_IMP__DerivativeAccumulator_t,
  _swigc__p_IMP__VectorT_IMP__EvaluationState_t,
  _swigc__p_IMP__VectorT_IMP__FloatIndex_t,
  _swigc__p_IMP__VectorT_IMP__IndexT_IMP__ParticleIndexTag_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_0_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_10_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_11_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_12_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_13_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_14_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_15_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_34897493_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_7_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_8_t_t,
  _swigc__p_IMP__VectorT_IMP__KeyT_9_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__AttributeOptimizer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__ConfigurationSet_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Configuration_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Constraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Container_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__ModelObject_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Model_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Object_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__OptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Optimizer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__PairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__PairModifier_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__PairPredicate_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__PairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__QuadContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__QuadModifier_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__QuadPredicate_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__QuadScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Refiner_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__RestraintSet_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Restraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Sampler_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__ScoreState_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__ScoringFunction_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__SingletonContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__SingletonModifier_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__SingletonPredicate_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__SingletonScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__TripletContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__TripletModifier_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__TripletPredicate_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__TripletScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__UnaryFunction_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__Undecorator_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__algebra__VectorKDMetric_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__AllBipartitePairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__AllPairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ClosePairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ConnectingPairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ConsecutivePairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListPairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListQuadContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListSingletonContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__DynamicListTripletContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerPairFilter_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerQuadFilter_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerSingletonFilter_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__InContainerTripletFilter_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ListPairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ListQuadContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ListSingletonContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__ListTripletContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumPairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumQuadScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumSingletonScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__MinimumTripletScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsConstraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__PairsRestraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsConstraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__QuadsRestraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsConstraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__SingletonsRestraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsConstraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__container__TripletsRestraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__DistancePairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicDistancePairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__HarmonicWell_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__MonteCarloMover_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometryConstraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__core__SurfaceGeometry_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__display__Geometry_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__display__TextWriter_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__display__Writer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstOptimizer_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstPairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstRestraint_t_t,
  _swigc__p_IMP__VectorT_IMP__PointerT_IMP__internal___ConstSingletonScore_t_t,
  _swigc__p_IMP__VectorT_IMP__ScoreAccumulator_t,
  _swigc__p_IMP__VectorT_IMP__SetCheckState_t,
  _swigc__p_IMP__VectorT_IMP__SetLogState_t,
  _swigc__p_IMP__VectorT_IMP__TextInput_t,
  _swigc__p_IMP__VectorT_IMP__TextOutput_t,
  _swigc__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_double_t_t_t,
  _swigc__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_int_t_t_t,
  _swigc__p_IMP__VectorT_IMP__VectorT_IMP__VectorT_std__string_t_t_t,
  _swigc__p_IMP__VectorT_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t_t,
  _swigc__p_IMP__VectorT_IMP__VectorT_WeakPointerT_IMP__Particle_t_t_t,
  _swigc__p_IMP__VectorT_IMP__VectorT_double_t_t,
  _swigc__p_IMP__VectorT_IMP__VectorT_int_t_t,
  _swigc__p_IMP__VectorT_IMP__VectorT_std__pairT_double_double_t_t_t,
  _swigc__p_IMP__VectorT_IMP__VectorT_std__pairT_int_int_t_t_t,
  _swigc__p_IMP__VectorT_IMP__VectorT_std__string_t_t,
  _swigc__p_IMP__VectorT_IMP__VersionInfo_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__AttributeOptimizer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__ConfigurationSet_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Configuration_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Constraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Container_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__ModelObject_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Model_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Object_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__OptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Optimizer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairModifier_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairPredicate_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__PairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadModifier_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadPredicate_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__QuadScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Refiner_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__RestraintSet_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Restraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Sampler_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoreState_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__ScoringFunction_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonModifier_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonPredicate_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__SingletonScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletModifier_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletPredicate_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__TripletScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__UnaryFunction_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__Undecorator_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__algebra__VectorKDMetric_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllBipartitePairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__AllPairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ClosePairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConnectingPairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ConsecutivePairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListPairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListQuadContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListSingletonContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__DynamicListTripletContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerPairFilter_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerQuadFilter_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerSingletonFilter_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__InContainerTripletFilter_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListPairContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListQuadContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListSingletonContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__ListTripletContainer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumPairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumQuadScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumSingletonScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__MinimumTripletScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsConstraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__PairsRestraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsConstraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__QuadsRestraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsConstraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__SingletonsRestraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsConstraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__container__TripletsRestraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__DistancePairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicDistancePairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicUpperBoundSphereDiameterPairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__HarmonicWell_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__MonteCarloMover_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometryConstraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__core__SurfaceGeometry_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Geometry_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__TextWriter_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__display__Writer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__CaChannelOpeningOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__InsulinSecretionOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__insulinsecretion__VesicleDockingOptimizerState_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstOptimizer_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstPairScore_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstRestraint_t_t,
  _swigc__p_IMP__VectorT_IMP__WeakPointerT_IMP__internal___ConstSingletonScore_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundedGridRangeDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__BoundingBoxDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Cone3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__ConnollySurfacePoint_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Cylinder3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__DefaultEmbeddingDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Ellipsoid3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__ExtendedGridIndexDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__FixedXYZ_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Gaussian3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__GridIndexDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Line3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__LinearFit2D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__LogEmbeddingDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__ParabolicFit2D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Plane3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__PrincipalComponentAnalysisDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__ReferenceFrame3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Reflection3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Rotation2D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Rotation3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Segment3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__SphereDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__SphereDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__SpherePatch3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__SphericalVector3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Transformation2D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Transformation3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__Triangle3D_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnboundedGridRangeDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__UnitSimplexDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_1_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_2_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_3_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_4_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_5_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__VectorDT_6_t_t,
  _swigc__p_IMP__VectorT_IMP__algebra__VectorDT__1_t_t,
  _swigc__p_IMP__VectorT_IMP__core__BinormalTerm_t,
  _swigc__p_IMP__VectorT_IMP__core__Centroid_t,
  _swigc__p_IMP__VectorT_IMP__core__Cover_t,
  _swigc__p_IMP__VectorT_IMP__core__DirectionAngle_t,
  _swigc__p_IMP__VectorT_IMP__core__Direction_t,
  _swigc__p_IMP__VectorT_IMP__core__Gaussian_t,
  _swigc__p_IMP__VectorT_IMP__core__HierarchyCounter_t,
  _swigc__p_IMP__VectorT_IMP__core__HierarchyTraits_t,
  _swigc__p_IMP__VectorT_IMP__core__Hierarchy_t,
  _swigc__p_IMP__VectorT_IMP__core__MonteCarloMoverResult_t,
  _swigc__p_IMP__VectorT_IMP__core__Reference_t,
  _swigc__p_IMP__VectorT_IMP__core__RigidBodyMember_t,
  _swigc__p_IMP__VectorT_IMP__core__RigidBody_t,
  _swigc__p_IMP__VectorT_IMP__core__RigidMember_t,
  _swigc__p_IMP__VectorT_IMP__core__Surface_t,
  _swigc__p_IMP__VectorT_IMP__core__Typed_t,
  _swigc__p_IMP__VectorT_IMP__core__XYZR_t,
  _swigc__p_IMP__VectorT_IMP__core__XYZ_t,
  _swigc__p_IMP__VectorT_IMP__display__Color_t,
  _swigc__p_IMP__VectorT_IMP__display__Colored_t,
  _swigc__p_IMP__VectorT_IMP__display__GeometryProcessor_t,
  _swigc__p_IMP__VectorT_IMP__display__WriterAdaptor_t,
  _swigc__p_IMP__VectorT_IMP__internal___Protection_t,
  _swigc__p_IMP__VectorT_IMP__internal___TestValue_t,
  _swigc__p_IMP__VectorT_IMP__internal___TrivialDecorator_t,
  _swigc__p_IMP__VectorT_IMP__internal___TrivialDerivedDecorator_t,
  _swigc__p_IMP__VectorT_IMP__internal___TrivialTraitsDecorator_t,
  _swigc__p_IMP__VectorT_PointerT_IMP__Particle_t_t,
  _swigc__p_IMP__VectorT_WeakPointerT_IMP__Particle_t_t,
  _swigc__p_IMP__VectorT_double_t,
  _swigc__p_IMP__VectorT_int_t,
  _swigc__p_IMP__VectorT_std__pairT_IMP__algebra__VectorDT_3_t_double_t_t,
  _swigc__p_IMP__VectorT_std__pairT_double_double_t_t,
  _swigc__p_IMP__VectorT_std__pairT_int_int_t_t,
  _swigc__p_IMP__VectorT_std__string_t,
  _swigc__p_IMP__VersionInfo,
  _swigc__p_IMP__WarningContext,
  _swigc__p_IMP__algebra__BoundedGridRangeDT_1_t,
  _swigc__p_IMP__algebra__BoundedGridRangeDT_2_t,
  _swigc__p_IMP__algebra__BoundedGridRangeDT_3_t,
  _swigc__p_IMP__algebra__BoundedGridRangeDT_4_t,
  _swigc__p_IMP__algebra__BoundedGridRangeDT_5_t,
  _swigc__p_IMP__algebra__BoundedGridRangeDT_6_t,
  _swigc__p_IMP__algebra__BoundedGridRangeDT__1_t,
  _swigc__p_IMP__algebra__BoundingBoxDT_1_t,
  _swigc__p_IMP__algebra__BoundingBoxDT_2_t,
  _swigc__p_IMP__algebra__BoundingBoxDT_3_t,
  _swigc__p_IMP__algebra__BoundingBoxDT_4_t,
  _swigc__p_IMP__algebra__BoundingBoxDT_5_t,
  _swigc__p_IMP__algebra__BoundingBoxDT_6_t,
  _swigc__p_IMP__algebra__BoundingBoxDT__1_t,
  _swigc__p_IMP__algebra__Cone3D,
  _swigc__p_IMP__algebra__ConnollySurfacePoint,
  _swigc__p_IMP__algebra__Cylinder3D,
  _swigc__p_IMP__algebra__DefaultEmbeddingDT_1_t,
  _swigc__p_IMP__algebra__DefaultEmbeddingDT_2_t,
  _swigc__p_IMP__algebra__DefaultEmbeddingDT_3_t,
  _swigc__p_IMP__algebra__DefaultEmbeddingDT_4_t,
  _swigc__p_IMP__algebra__DefaultEmbeddingDT_5_t,
  _swigc__p_IMP__algebra__DefaultEmbeddingDT_6_t,
  _swigc__p_IMP__algebra__DefaultEmbeddingDT__1_t,
  _swigc__p_IMP__algebra__DynamicNearestNeighbor3D,
  _swigc__p_IMP__algebra__Ellipsoid3D,
  _swigc__p_IMP__algebra__EuclideanVectorKDMetric,
  _swigc__p_IMP__algebra__ExtendedGridIndexDT_1_t,
  _swigc__p_IMP__algebra__ExtendedGridIndexDT_2_t,
  _swigc__p_IMP__algebra__ExtendedGridIndexDT_3_t,
  _swigc__p_IMP__algebra__ExtendedGridIndexDT_4_t,
  _swigc__p_IMP__algebra__ExtendedGridIndexDT_5_t,
  _swigc__p_IMP__algebra__ExtendedGridIndexDT_6_t,
  _swigc__p_IMP__algebra__ExtendedGridIndexDT__1_t,
  _swigc__p_IMP__algebra__FixedXYZ,
  _swigc__p_IMP__algebra__Gaussian3D,
  _swigc__p_IMP__algebra__GeometricPrimitiveDT_1_t,
  _swigc__p_IMP__algebra__GeometricPrimitiveDT_2_t,
  _swigc__p_IMP__algebra__GeometricPrimitiveDT_3_t,
  _swigc__p_IMP__algebra__GeometricPrimitiveDT_4_t,
  _swigc__p_IMP__algebra__GeometricPrimitiveDT_5_t,
  _swigc__p_IMP__algebra__GeometricPrimitiveDT_6_t,
  _swigc__p_IMP__algebra__GeometricPrimitiveDT__1_t,
  _swigc__p_IMP__algebra__GridIndexDT_1_t,
  _swigc__p_IMP__algebra__GridIndexDT_2_t,
  _swigc__p_IMP__algebra__GridIndexDT_3_t,
  _swigc__p_IMP__algebra__GridIndexDT_4_t,
  _swigc__p_IMP__algebra__GridIndexDT_5_t,
  _swigc__p_IMP__algebra__GridIndexDT_6_t,
  _swigc__p_IMP__algebra__GridIndexDT__1_t,
  _swigc__p_IMP__algebra__Line3D,
  _swigc__p_IMP__algebra__LinearFit2D,
  _swigc__p_IMP__algebra__LogEmbeddingDT_1_t,
  _swigc__p_IMP__algebra__LogEmbeddingDT_2_t,
  _swigc__p_IMP__algebra__LogEmbeddingDT_3_t,
  _swigc__p_IMP__algebra__LogEmbeddingDT_4_t,
  _swigc__p_IMP__algebra__LogEmbeddingDT_5_t,
  _swigc__p_IMP__algebra__LogEmbeddingDT_6_t,
  _swigc__p_IMP__algebra__LogEmbeddingDT__1_t,
  _swigc__p_IMP__algebra__MaxVectorKDMetric,
  _swigc__p_IMP__algebra__NearestNeighborDT_1_t,
  _swigc__p_IMP__algebra__NearestNeighborDT_2_t,
  _swigc__p_IMP__algebra__NearestNeighborDT_3_t,
  _swigc__p_IMP__algebra__NearestNeighborDT_4_t,
  _swigc__p_IMP__algebra__NearestNeighborDT_5_t,
  _swigc__p_IMP__algebra__NearestNeighborDT_6_t,
  _swigc__p_IMP__algebra__NearestNeighborDT__1_t,
  _swigc__p_IMP__algebra__ParabolicFit2D,
  _swigc__p_IMP__algebra__Plane3D,
  _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_1_t,
  _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_2_t,
  _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_3_t,
  _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_4_t,
  _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_5_t,
  _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT_6_t,
  _swigc__p_IMP__algebra__PrincipalComponentAnalysisDT__1_t,
  _swigc__p_IMP__algebra__ReferenceFrame3D,
  _swigc__p_IMP__algebra__Reflection3D,
  _swigc__p_IMP__algebra__Rotation2D,
  _swigc__p_IMP__algebra__Rotation3D,
  _swigc__p_IMP__algebra__Segment3D,
  _swigc__p_IMP__algebra__SphereDT_1_t,
  _swigc__p_IMP__algebra__SphereDT_2_t,
  _swigc__p_IMP__algebra__SphereDT_3_t,
  _swigc__p_IMP__algebra__SphereDT_4_t,
  _swigc__p_IMP__algebra__SphereDT_5_t,
  _swigc__p_IMP__algebra__SphereDT_6_t,
  _swigc__p_IMP__algebra__SphereDT__1_t,
  _swigc__p_IMP__algebra__SpherePatch3D,
  _swigc__p_IMP__algebra__SphericalVector3D,
  _swigc__p_IMP__algebra__Transformation2D,
  _swigc__p_IMP__algebra__Transformation3D,
  _swigc__p_IMP__algebra__Triangle3D,
  _swigc__p_IMP__algebra__UnboundedGridRangeDT_1_t,
  _swigc__p_IMP__algebra__UnboundedGridRangeDT_2_t,
  _swigc__p_IMP__algebra__UnboundedGridRangeDT_3_t,
  _swigc__p_IMP__algebra__UnboundedGridRangeDT_4_t,
  _swigc__p_IMP__algebra__UnboundedGridRangeDT_5_t,
  _swigc__p_IMP__algebra__UnboundedGridRangeDT_6_t,
  _swigc__p_IMP__algebra__UnboundedGridRangeDT__1_t,
  _swigc__p_IMP__algebra__UnitSimplexBaseDT_1_t,
  _swigc__p_IMP__algebra__UnitSimplexBaseDT_2_t,
  _swigc__p_IMP__algebra__UnitSimplexBaseDT_3_t,
  _swigc__p_IMP__algebra__UnitSimplexBaseDT_4_t,
  _swigc__p_IMP__algebra__UnitSimplexBaseDT_5_t,
  _swigc__p_IMP__algebra__UnitSimplexBaseDT_6_t,
  _swigc__p_IMP__algebra__UnitSimplexBaseDT__1_t,
  _swigc__p_IMP__algebra__UnitSimplexDT_1_t,
  _swigc__p_IMP__algebra__UnitSimplexDT_2_t,
  _swigc__p_IMP__algebra__UnitSimplexDT_3_t,
  _swigc__p_IMP__algebra__UnitSimplexDT_4_t,
  _swigc__p_IMP__algebra__UnitSimplexDT_5_t,
  _swigc__p_IMP__algebra__UnitSimplexDT_6_t,
  _swigc__p_IMP__algebra__UnitSimplexDT__1_t,
  _swigc__p_IMP__algebra__VectorBaseDT_1_t,
  _swigc__p_IMP__algebra__VectorBaseDT_2_t,
  _swigc__p_IMP__algebra__VectorBaseDT_3_t,
  _swigc__p_IMP__algebra__VectorBaseDT_4_t,
  _swigc__p_IMP__algebra__VectorBaseDT_5_t,
  _swigc__p_IMP__algebra__VectorBaseDT_6_t,
  _swigc__p_IMP__algebra__VectorBaseDT__1_t,
  _swigc__p_IMP__algebra__VectorDT_1_t,
  _swigc__p_IMP__algebra__VectorDT_2_t,
  _swigc__p_IMP__algebra__VectorDT_3_t,
  _swigc__p_IMP__algebra__VectorDT_4_t,
  _swigc__p_IMP__algebra__VectorDT_5_t,
  _swigc__p_IMP__algebra__VectorDT_6_t,
  _swigc__p_IMP__algebra__VectorDT__1_t,
  _swigc__p_IMP__algebra__VectorKDMetric,
  _swigc__p_IMP__container__AllBipartitePairContainer,
  _swigc__p_IMP__container__AllPairContainer,
  _swigc__p_IMP__container__CloseBipartitePairContainer,
  _swigc__p_IMP__container__ClosePairContainer,
  _swigc__p_IMP__container__ConnectingPairContainer,
  _swigc__p_IMP__container__ConsecutivePairContainer,
  _swigc__p_IMP__container__ConsecutivePairFilter,
  _swigc__p_IMP__container__DistributePairsScoreState,
  _swigc__p_IMP__container__DistributeQuadsScoreState,
  _swigc__p_IMP__container__DistributeSingletonsScoreState,
  _swigc__p_IMP__container__DistributeTripletsScoreState,
  _swigc__p_IMP__container__DynamicListPairContainer,
  _swigc__p_IMP__container__DynamicListQuadContainer,
  _swigc__p_IMP__container__DynamicListSingletonContainer,
  _swigc__p_IMP__container__DynamicListTripletContainer,
  _swigc__p_IMP__container__EventPairsOptimizerState,
  _swigc__p_IMP__container__EventQuadsOptimizerState,
  _swigc__p_IMP__container__EventSingletonsOptimizerState,
  _swigc__p_IMP__container__EventTripletsOptimizerState,
  _swigc__p_IMP__container__ExclusiveConsecutivePairContainer,
  _swigc__p_IMP__container__ExclusiveConsecutivePairFilter,
  _swigc__p_IMP__container__InContainerPairFilter,
  _swigc__p_IMP__container__InContainerQuadFilter,
  _swigc__p_IMP__container__InContainerSingletonFilter,
  _swigc__p_IMP__container__InContainerTripletFilter,
  _swigc__p_IMP__container__ListPairContainer,
  _swigc__p_IMP__container__ListQuadContainer,
  _swigc__p_IMP__container__ListSingletonContainer,
  _swigc__p_IMP__container__ListTripletContainer,
  _swigc__p_IMP__container__MinimumPairRestraint,
  _swigc__p_IMP__container__MinimumPairScore,
  _swigc__p_IMP__container__MinimumQuadRestraint,
  _swigc__p_IMP__container__MinimumQuadScore,
  _swigc__p_IMP__container__MinimumSingletonRestraint,
  _swigc__p_IMP__container__MinimumSingletonScore,
  _swigc__p_IMP__container__MinimumTripletRestraint,
  _swigc__p_IMP__container__MinimumTripletScore,
  _swigc__p_IMP__container__PairContainerSet,
  _swigc__p_IMP__container__PairContainerStatistics,
  _swigc__p_IMP__container__PairsConstraint,
  _swigc__p_IMP__container__PairsOptimizerState,
  _swigc__p_IMP__container__PairsRestraint,
  _swigc__p_IMP__container__PredicatePairsRestraint,
  _swigc__p_IMP__container__PredicateQuadsRestraint,
  _swigc__p_IMP__container__PredicateSingletonsRestraint,
  _swigc__p_IMP__container__PredicateTripletsRestraint,
  _swigc__p_IMP__container__QuadContainerSet,
  _swigc__p_IMP__container__QuadContainerStatistics,
  _swigc__p_IMP__container__QuadsConstraint,
  _swigc__p_IMP__container__QuadsOptimizerState,
  _swigc__p_IMP__container__QuadsRestraint,
  _swigc__p_IMP__container__SingletonContainerSet,
  _swigc__p_IMP__container__SingletonContainerStatistics,
  _swigc__p_IMP__container__SingletonsConstraint,
  _swigc__p_IMP__container__SingletonsOptimizerState,
  _swigc__p_IMP__container__SingletonsRestraint,
  _swigc__p_IMP__container__TripletContainerSet,
  _swigc__p_IMP__container__TripletContainerStatistics,
  _swigc__p_IMP__container__TripletsConstraint,
  _swigc__p_IMP__container__TripletsOptimizerState,
  _swigc__p_IMP__container__TripletsRestraint,
  _swigc__p_IMP__core__AllSamePairPredicate,
  _swigc__p_IMP__core__AllSameQuadPredicate,
  _swigc__p_IMP__core__AllSameSingletonPredicate,
  _swigc__p_IMP__core__AllSameTripletPredicate,
  _swigc__p_IMP__core__AngleRestraint,
  _swigc__p_IMP__core__AngleTripletScore,
  _swigc__p_IMP__core__AttributeSingletonPredicate,
  _swigc__p_IMP__core__BallMover,
  _swigc__p_IMP__core__BinormalTerm,
  _swigc__p_IMP__core__BoxSweepClosePairsFinder,
  _swigc__p_IMP__core__Centroid,
  _swigc__p_IMP__core__CentroidOfRefined,
  _swigc__p_IMP__core__ChecksScoreState,
  _swigc__p_IMP__core__ChildrenRefiner,
  _swigc__p_IMP__core__ClosePairsFinder,
  _swigc__p_IMP__core__ClosePairsPairScore,
  _swigc__p_IMP__core__ClosedCubicSpline,
  _swigc__p_IMP__core__ClusterProvenance,
  _swigc__p_IMP__core__CoinFlipPairPredicate,
  _swigc__p_IMP__core__CoinFlipQuadPredicate,
  _swigc__p_IMP__core__CoinFlipSingletonPredicate,
  _swigc__p_IMP__core__CoinFlipTripletPredicate,
  _swigc__p_IMP__core__CombineProvenance,
  _swigc__p_IMP__core__ConjugateGradients,
  _swigc__p_IMP__core__ConnectivityRestraint,
  _swigc__p_IMP__core__ConstantPairPredicate,
  _swigc__p_IMP__core__ConstantQuadPredicate,
  _swigc__p_IMP__core__ConstantRestraint,
  _swigc__p_IMP__core__ConstantSingletonPredicate,
  _swigc__p_IMP__core__ConstantTripletPredicate,
  _swigc__p_IMP__core__Cosine,
  _swigc__p_IMP__core__Cover,
  _swigc__p_IMP__core__CoverRefined,
  _swigc__p_IMP__core__DerivativesFromRefined,
  _swigc__p_IMP__core__DerivativesToRefined,
  _swigc__p_IMP__core__DiameterRestraint,
  _swigc__p_IMP__core__DihedralRestraint,
  _swigc__p_IMP__core__Direction,
  _swigc__p_IMP__core__DirectionAngle,
  _swigc__p_IMP__core__DirectionMover,
  _swigc__p_IMP__core__DistancePairScore,
  _swigc__p_IMP__core__DistanceRestraint,
  _swigc__p_IMP__core__EdgePairGeometry,
  _swigc__p_IMP__core__EdgePairsGeometry,
  _swigc__p_IMP__core__ExcludedVolumeRestraint,
  _swigc__p_IMP__core__FilterProvenance,
  _swigc__p_IMP__core__FixedRefiner,
  _swigc__p_IMP__core__Gaussian,
  _swigc__p_IMP__core__GenericAttributeSingletonScoreT_IMP__UnaryFunction_t,
  _swigc__p_IMP__core__GenericBoundingBox3DSingletonScoreT_IMP__UnaryFunction_t,
  _swigc__p_IMP__core__GenericBoundingSphere3DSingletonScoreT_IMP__UnaryFunction_t,
  _swigc__p_IMP__core__GenericDistanceToSingletonScoreT_IMP__UnaryFunction_t,
  _swigc__p_IMP__core__GridClosePairsFinder,
  _swigc__p_IMP__core__Harmonic,
  _swigc__p_IMP__core__HarmonicDistancePairScore,
  _swigc__p_IMP__core__HarmonicLowerBound,
  _swigc__p_IMP__core__HarmonicSphereDistancePairScore,
  _swigc__p_IMP__core__HarmonicSurfaceDepthPairScore,
  _swigc__p_IMP__core__HarmonicSurfaceDistancePairScore,
  _swigc__p_IMP__core__HarmonicSurfaceHeightPairScore,
  _swigc__p_IMP__core__HarmonicUpperBound,
  _swigc__p_IMP__core__HarmonicUpperBoundSphereDiameterPairScore,
  _swigc__p_IMP__core__HarmonicUpperBoundSphereDistancePairScore,
  _swigc__p_IMP__core__HarmonicWell,
  _swigc__p_IMP__core__Hierarchy,
  _swigc__p_IMP__core__HierarchyCounter,
  _swigc__p_IMP__core__HierarchyTraits,
  _swigc__p_IMP__core__InBoundingBox3DSingletonPredicate,
  _swigc__p_IMP__core__IsCollisionPairPredicate,
  _swigc__p_IMP__core__KClosePairsPairScore,
  _swigc__p_IMP__core__LateralSurfaceConstraint,
  _swigc__p_IMP__core__LeavesRefiner,
  _swigc__p_IMP__core__Linear,
  _swigc__p_IMP__core__LogNormalMover,
  _swigc__p_IMP__core__MCCGSampler,
  _swigc__p_IMP__core__MSConnectivityRestraint,
  _swigc__p_IMP__core__MinimumRestraint,
  _swigc__p_IMP__core__MonteCarlo,
  _swigc__p_IMP__core__MonteCarloMover,
  _swigc__p_IMP__core__MonteCarloMoverResult,
  _swigc__p_IMP__core__MonteCarloWithBasinHopping,
  _swigc__p_IMP__core__MonteCarloWithLocalOptimization,
  _swigc__p_IMP__core__MoveStatisticsScoreState,
  _swigc__p_IMP__core__MultipleBinormalRestraint,
  _swigc__p_IMP__core__NearestNeighborsClosePairsFinder,
  _swigc__p_IMP__core__NeighborsTable,
  _swigc__p_IMP__core__NonRigidMember,
  _swigc__p_IMP__core__NormalMover,
  _swigc__p_IMP__core__NormalizedSphereDistancePairScore,
  _swigc__p_IMP__core__OpenCubicSpline,
  _swigc__p_IMP__core__OrderedTypePairPredicate,
  _swigc__p_IMP__core__OrderedTypeQuadPredicate,
  _swigc__p_IMP__core__OrderedTypeSingletonPredicate,
  _swigc__p_IMP__core__OrderedTypeTripletPredicate,
  _swigc__p_IMP__core__PairConstraint,
  _swigc__p_IMP__core__PairRestraint,
  _swigc__p_IMP__core__Provenance,
  _swigc__p_IMP__core__Provenanced,
  _swigc__p_IMP__core__QuadConstraint,
  _swigc__p_IMP__core__QuadRestraint,
  _swigc__p_IMP__core__QuadraticClosePairsFinder,
  _swigc__p_IMP__core__Reference,
  _swigc__p_IMP__core__RefinedPairsPairScore,
  _swigc__p_IMP__core__RestraintsScoringFunction,
  _swigc__p_IMP__core__RigidBody,
  _swigc__p_IMP__core__RigidBodyAnglePairScore,
  _swigc__p_IMP__core__RigidBodyDerivativeGeometry,
  _swigc__p_IMP__core__RigidBodyDerivativesGeometry,
  _swigc__p_IMP__core__RigidBodyDistancePairScore,
  _swigc__p_IMP__core__RigidBodyFrameGeometry,
  _swigc__p_IMP__core__RigidBodyFramesGeometry,
  _swigc__p_IMP__core__RigidBodyHierarchyGeometry,
  _swigc__p_IMP__core__RigidBodyMember,
  _swigc__p_IMP__core__RigidBodyMover,
  _swigc__p_IMP__core__RigidBodyTorque,
  _swigc__p_IMP__core__RigidBodyTunneler,
  _swigc__p_IMP__core__RigidBodyUmbrella,
  _swigc__p_IMP__core__RigidClosePairsFinder,
  _swigc__p_IMP__core__RigidMember,
  _swigc__p_IMP__core__RigidMembersRefiner,
  _swigc__p_IMP__core__SampleProvenance,
  _swigc__p_IMP__core__ScriptProvenance,
  _swigc__p_IMP__core__SerialMover,
  _swigc__p_IMP__core__SingletonConstraint,
  _swigc__p_IMP__core__SingletonRestraint,
  _swigc__p_IMP__core__SoftSpherePairScore,
  _swigc__p_IMP__core__SoftSubSurfacePairScore,
  _swigc__p_IMP__core__SoftSuperSurfacePairScore,
  _swigc__p_IMP__core__SoftwareProvenance,
  _swigc__p_IMP__core__SphereDistancePairScore,
  _swigc__p_IMP__core__SphereDistanceToSingletonScore,
  _swigc__p_IMP__core__SteepestDescent,
  _swigc__p_IMP__core__StructureProvenance,
  _swigc__p_IMP__core__SubsetMover,
  _swigc__p_IMP__core__Surface,
  _swigc__p_IMP__core__SurfaceDepthPairScore,
  _swigc__p_IMP__core__SurfaceDistancePairScore,
  _swigc__p_IMP__core__SurfaceGeometry,
  _swigc__p_IMP__core__SurfaceGeometryConstraint,
  _swigc__p_IMP__core__SurfaceHeightPairScore,
  _swigc__p_IMP__core__SurfaceMover,
  _swigc__p_IMP__core__SurfaceSymmetryConstraint,
  _swigc__p_IMP__core__SurfaceTetheredChain,
  _swigc__p_IMP__core__TableRefiner,
  _swigc__p_IMP__core__Transform,
  _swigc__p_IMP__core__TransformationAndReflectionSymmetry,
  _swigc__p_IMP__core__TransformationSymmetry,
  _swigc__p_IMP__core__TransformationSymmetryMover,
  _swigc__p_IMP__core__TransformedDistancePairScore,
  _swigc__p_IMP__core__TripletConstraint,
  _swigc__p_IMP__core__TripletRestraint,
  _swigc__p_IMP__core__TruncatedHarmonicT_IMP__core__BOTH_t,
  _swigc__p_IMP__core__TruncatedHarmonicT_IMP__core__LOWER_t,
  _swigc__p_IMP__core__TruncatedHarmonicT_IMP__core__UPPER_t,
  _swigc__p_IMP__core__Typed,
  _swigc__p_IMP__core__TypedPairScore,
  _swigc__p_IMP__core__UnorderedTypePairPredicate,
  _swigc__p_IMP__core__UnorderedTypeQuadPredicate,
  _swigc__p_IMP__core__UnorderedTypeSingletonPredicate,
  _swigc__p_IMP__core__UnorderedTypeTripletPredicate,
  _swigc__p_IMP__core__VolumeRestraint,
  _swigc__p_IMP__core__WeightedDerivativesToRefined,
  _swigc__p_IMP__core__WeightedSphereDistancePairScore,
  _swigc__p_IMP__core__WeightedSum,
  _swigc__p_IMP__core__WeightedSumOfExponential,
  _swigc__p_IMP__core__WriteRestraintScoresOptimizerState,
  _swigc__p_IMP__core__XYZ,
  _swigc__p_IMP__core__XYZDerivativeGeometry,
  _swigc__p_IMP__core__XYZDerivativesGeometry,
  _swigc__p_IMP__core__XYZR,
  _swigc__p_IMP__core__XYZRGeometry,
  _swigc__p_IMP__core__XYZRsGeometry,
  _swigc__p_IMP__display__BoundingBoxGeometry,
  _swigc__p_IMP__display__Color,
  _swigc__p_IMP__display__Colored,
  _swigc__p_IMP__display__CylinderGeometry,
  _swigc__p_IMP__display__EllipsoidGeometry,
  _swigc__p_IMP__display__FilterGeometry,
  _swigc__p_IMP__display__Geometry,
  _swigc__p_IMP__display__GeometrySet,
  _swigc__p_IMP__display__IsosurfaceGeometry,
  _swigc__p_IMP__display__LabelGeometry,
  _swigc__p_IMP__display__PairGeometry,
  _swigc__p_IMP__display__PairsGeometry,
  _swigc__p_IMP__display__PlaneGeometry,
  _swigc__p_IMP__display__PointGeometry,
  _swigc__p_IMP__display__PolygonGeometry,
  _swigc__p_IMP__display__PymolWriter,
  _swigc__p_IMP__display__ReferenceFrameGeometry,
  _swigc__p_IMP__display__RestraintGeometry,
  _swigc__p_IMP__display__RestraintSetGeometry,
  _swigc__p_IMP__display__SegmentGeometry,
  _swigc__p_IMP__display__SingletonGeometry,
  _swigc__p_IMP__display__SingletonsGeometry,
  _swigc__p_IMP__display__SkinSurfaceGeometry,
  _swigc__p_IMP__display__SphereGeometry,
  _swigc__p_IMP__display__SurfaceMeshGeometry,
  _swigc__p_IMP__display__TextWriter,
  _swigc__p_IMP__display__TriangleGeometry,
  _swigc__p_IMP__display__WriteOptimizerState,
  _swigc__p_IMP__display__Writer,
  _swigc__p_IMP__display__WriterAdaptor,
  _swigc__p_IMP__insulinsecretion__CaChannelOpeningOptimizerState,
  _swigc__p_IMP__insulinsecretion__CaChannelStateDecorator,
  _swigc__p_IMP__insulinsecretion__DockingStateDecorator,
  _swigc__p_IMP__insulinsecretion__InsulinSecretionOptimizerState,
  _swigc__p_IMP__insulinsecretion__MaturationStateDecorator,
  _swigc__p_IMP__insulinsecretion__RadialDistributionFunctionSingletonScore,
  _swigc__p_IMP__insulinsecretion__SecretionCounterDecorator,
  _swigc__p_IMP__insulinsecretion__VesicleDockingOptimizerState,
  _swigc__p_IMP__insulinsecretion__VesicleTraffickingSingletonScore,
  _swigc__p_IMP__internal__BoostDigraphT_IMP__DependencyGraph_IMP__ModelObject_p_IMP__ShowDependencyGraphVertex_t,
  _swigc__p_IMP__internal___ConstOptimizer,
  _swigc__p_IMP__internal___ConstPairScore,
  _swigc__p_IMP__internal___ConstRestraint,
  _swigc__p_IMP__internal___ConstSingletonScore,
  _swigc__p_IMP__internal___LogPairScore,
  _swigc__p_IMP__internal___Protection,
  _swigc__p_IMP__internal___TestObject,
  _swigc__p_IMP__internal___TestValue,
  _swigc__p_IMP__internal___TrivialDecorator,
  _swigc__p_IMP__internal___TrivialDerivedDecorator,
  _swigc__p_IMP__internal___TrivialTraitsDecorator,
  _swigc__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__HarmonicLowerBound_t,
  _swigc__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t,
  _swigc__p_IMP__score_functor__PointToSphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t,
  _swigc__p_IMP__score_functor__ScoreUnaryFunctionT_IMP__score_functor__OpenCubicSpline_2_t,
  _swigc__p_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t,
  _swigc__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__HarmonicLowerBound_t,
  _swigc__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__HarmonicUpperBound_t_t,
  _swigc__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__ShiftT_IMP__score_functor__Harmonic_t_t,
  _swigc__p_IMP__score_functor__SphereDistanceT_IMP__score_functor__UnaryFunctionEvaluate_t,
  _swigc__p_Index,
  _swigc__p_IndexArgument,
  _swigc__p_Modifier,
  _swigc__p_P,
  _swigc__p_ParentDecorator,
  _swigc__p_PassContainedIndexType,
  _swigc__p_PassIndexArgument,
  _swigc__p_ScoreIsGoodPair,
  _swigc__p_VertexDescriptor,
  _swigc__p_VertexDescriptors,
  _swigc__p_VertexName,
  _swigc__p_char,
  _swigc__p_double,
  _swigc__p_first_type,
  _swigc__p_float,
  _swigc__p_int,
  _swigc__p_second_type,
  _swigc__p_size_t,
  _swigc__p_std__invalid_argument,
  _swigc__p_std__ostream,
  _swigc__p_std__pairT_IMP__algebra__VectorDT_3_t_IMP__algebra__VectorDT_4_t_t,
  _swigc__p_std__pairT_IMP__algebra__VectorDT_3_t_double_t,
  _swigc__p_std__pairT_IMP__algebra__VectorDT_3_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t,
  _swigc__p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t,
  _swigc__p_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_4_t_t,
  _swigc__p_std__pairT_double_double_t,
  _swigc__p_std__pairT_int_int_t,
  _swigc__p_std__pairT_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_std__pairT_IMP__algebra__VectorDT_4_t_IMP__algebra__VectorDT_3_t_t_t,
  _swigc__p_std__string,
  _swigc__p_swig__IMP_INSULINSECRETION_SwigPyIterator,
  _swigc__p_unsigned_int,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif

#ifndef SWIG_INIT_CLIENT_DATA_TYPE
#define SWIG_INIT_CLIENT_DATA_TYPE void *
#endif

SWIGRUNTIME void
SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------
   * Patch %callback methods' docstrings to hold the callback ptrs
   * -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods, const swig_const_info *const_table, swig_type_info **types, swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        const swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              memcpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              memcpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
#ifdef __cplusplus
}
#endif




/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md, *globals;
  
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    SwigPyObject_own,
    SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif
  
  (void)globals;
  
  /* Create singletons now to avoid potential deadlocks with multi-threaded usage after module initialization */
  SWIG_This();
  SWIG_Python_TypeCache();
  SwigPyPacked_type();
#ifndef SWIGPYTHON_BUILTIN
  SwigPyObject_type();
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule(SWIG_name, SwigMethods);
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();
  
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  SWIG_Python_SetConstant(d, "IMP_DEBUG",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_RELEASE",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_SILENT",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_PROGRESS",SWIG_From_int(static_cast< int >(2)));
  SWIG_Python_SetConstant(d, "IMP_TERSE",SWIG_From_int(static_cast< int >(3)));
  SWIG_Python_SetConstant(d, "IMP_VERBOSE",SWIG_From_int(static_cast< int >(4)));
  SWIG_Python_SetConstant(d, "IMP_MEMORY",SWIG_From_int(static_cast< int >(5)));
  SWIG_Python_SetConstant(d, "IMP_NONE",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_USAGE",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INTERNAL",SWIG_From_int(static_cast< int >(2)));
  SWIG_Python_SetConstant(d, "IMP_KERNEL_HAS_LOG4CXX",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_COMPILER_HAS_CEREAL_RAW_POINTER",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_COMPILER_HAS_DEBUG_VECTOR",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_COMPILER_HAS_RANDOM_SHUFFLE",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_COMPILER_HAS_THREE_WAY",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_KERNEL_HAS_BOOST_RANDOM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_KERNEL_HAS_GPERFTOOLS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_KERNEL_HAS_NUMPY",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_KERNEL_HAS_TCMALLOC_HEAPCHECKER",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_KERNEL_HAS_TCMALLOC_HEAPPROFILER",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMPKERNEL_SHOW_WARNINGS",SWIG_From_int(static_cast< int >(0)));
  
  {
    /* Create or load kernel exception class */
    
    
    
    
    
    PyObject *base = PyImport_ImportModule("_IMP_kernel");
    PyObject *base_dict = PyModule_GetDict(base);
    imp_exception = PyDict_GetItemString(base_dict, "Exception");
    
    
    /* Create or load exception subclasses */
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,20,CREATE_EXCEPTION_CLASS@*/
    
    
    
    
    
    imp_internal_exception = PyDict_GetItemString(base_dict, "InternalException")
    
    /*@SWIG@*/;
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,20,CREATE_EXCEPTION_CLASS@*/
    
    
    
    
    
    imp_model_exception = PyDict_GetItemString(base_dict, "ModelException")
    
    /*@SWIG@*/;
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,20,CREATE_EXCEPTION_CLASS@*/
    
    
    
    
    
    imp_usage_exception = PyDict_GetItemString(base_dict, "UsageException")
    
    /*@SWIG@*/;
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,20,CREATE_EXCEPTION_CLASS@*/
    
    
    
    
    
    imp_event_exception = PyDict_GetItemString(base_dict, "EventException")
    
    /*@SWIG@*/;
    
    /* Create or load subclasses that also derive from Python classes */
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,30,CREATE_EXCEPTION_CLASS_PYTHON@*/
    
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,20,CREATE_EXCEPTION_CLASS@*/
    
    
    
    
    
    imp_index_exception = PyDict_GetItemString(base_dict, "IndexException")
    
    /*@SWIG@*/
    
    
    
    
    
    
    
    
    
    
    /*@SWIG@*/
    ;
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,30,CREATE_EXCEPTION_CLASS_PYTHON@*/
    
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,20,CREATE_EXCEPTION_CLASS@*/
    
    
    
    
    
    imp_io_exception = PyDict_GetItemString(base_dict, "IOException")
    
    /*@SWIG@*/
    
    
    
    
    
    
    
    
    
    
    /*@SWIG@*/;
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,30,CREATE_EXCEPTION_CLASS_PYTHON@*/
    
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,20,CREATE_EXCEPTION_CLASS@*/
    
    
    
    
    
    imp_value_exception = PyDict_GetItemString(base_dict, "ValueException")
    
    /*@SWIG@*/
    
    
    
    
    
    
    
    
    
    
    /*@SWIG@*/
    ;
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,30,CREATE_EXCEPTION_CLASS_PYTHON@*/
    
    /*@SWIG:/usr/local/share/IMP/swig/IMP_kernel.exceptions.i,20,CREATE_EXCEPTION_CLASS@*/
    
    
    
    
    
    imp_type_exception = PyDict_GetItemString(base_dict, "TypeException")
    
    /*@SWIG@*/
    
    
    
    
    
    
    
    
    
    
    /*@SWIG@*/
    ;
    
    
    Py_DECREF(base);
    
  }
  
  
  numpy_import_retval = _import_array();
  /* If numpy was not found, continue anyway without numpy support */
  PyErr_Clear();
  
  SWIG_Python_SetConstant(d, "IMP_C_OPEN_BINARY",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_CGAL_HAS_BOOST_FILESYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CGAL_HAS_BOOST_PROGRAMOPTIONS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CGAL_HAS_BOOST_RANDOM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CGAL_HAS_BOOST_SYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CGAL_HAS_GPERFTOOLS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CGAL_HAS_NUMPY",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMPCGAL_SHOW_WARNINGS",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_ALGEBRA_HAS_IMP_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_ALGEBRA_HAS_ANN",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_ALGEBRA_HAS_BOOST_FILESYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_ALGEBRA_HAS_BOOST_PROGRAMOPTIONS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_ALGEBRA_HAS_BOOST_RANDOM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_ALGEBRA_HAS_BOOST_SYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_ALGEBRA_HAS_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_ALGEBRA_HAS_GPERFTOOLS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_ALGEBRA_HAS_NUMPY",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMPALGEBRA_SHOW_WARNINGS",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_DISPLAY_HAS_IMP_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_DISPLAY_HAS_ANN",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_DISPLAY_HAS_BOOST_FILESYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_DISPLAY_HAS_BOOST_PROGRAMOPTIONS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_DISPLAY_HAS_BOOST_RANDOM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_DISPLAY_HAS_BOOST_SYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_DISPLAY_HAS_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_DISPLAY_HAS_GPERFTOOLS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_DISPLAY_HAS_NUMPY",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMPDISPLAY_SHOW_WARNINGS",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_SCORE_FUNCTOR_HAS_IMP_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_SCORE_FUNCTOR_HAS_ANN",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_SCORE_FUNCTOR_HAS_BOOST_FILESYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_SCORE_FUNCTOR_HAS_BOOST_PROGRAMOPTIONS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_SCORE_FUNCTOR_HAS_BOOST_RANDOM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_SCORE_FUNCTOR_HAS_BOOST_SYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_SCORE_FUNCTOR_HAS_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_SCORE_FUNCTOR_HAS_GPERFTOOLS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_SCORE_FUNCTOR_HAS_HDF5",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_SCORE_FUNCTOR_HAS_NUMPY",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMPSCOREFUNCTOR_SHOW_WARNINGS",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_IMP_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_IMP_KERNEL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_ANN",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_BOOST_FILESYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_BOOST_PROGRAMOPTIONS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_BOOST_RANDOM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_BOOST_SYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_GPERFTOOLS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_HDF5",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CORE_HAS_NUMPY",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMPCORE_SHOW_WARNINGS",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_IMP_ALGEBRA",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_IMP_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_IMP_DISPLAY",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_IMP_KERNEL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_IMP_SCORE_FUNCTOR",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_ANN",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_BOOST_FILESYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_BOOST_PROGRAMOPTIONS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_BOOST_RANDOM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_BOOST_SYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_GPERFTOOLS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_HDF5",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_NUMPY",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_PYTHON_IHM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_GOOGLE_DENSE_HASH_MAP",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_CONTAINER_HAS_ROBIN_MAP",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMPCONTAINER_SHOW_WARNINGS",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_IMP_ALGEBRA",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_IMP_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_IMP_DISPLAY",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_IMP_KERNEL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_IMP_SCORE_FUNCTOR",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_ANN",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_BOOST_FILESYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_BOOST_PROGRAMOPTIONS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_BOOST_RANDOM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_BOOST_SYSTEM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_CGAL",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_GPERFTOOLS",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_HDF5",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_NUMPY",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMP_INSULINSECRETION_HAS_PYTHON_IHM",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "IMPINSULINSECRETION_SHOW_WARNINGS",SWIG_From_int(static_cast< int >(0)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

